#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = require('fs');
var glob = require('glob');
var path = require('path');
var yargs = _interopDefault(require('yargs'));
var chokidar = require('chokidar');
var semver = require('semver');
var $protobuf = require('protobufjs/minimal');
var Long = _interopDefault(require('long'));
var moo = require('moo');
var protobufjs = require('protobufjs');
var TarjanGraphConstructor = _interopDefault(require('tarjan-graph'));
var childProcess = require('child_process');
var PromisePool = require('promise-pool-executor');
var bigquery = require('@google-cloud/bigquery');
var sizeof = _interopDefault(require('object-sizeof'));
var getPort = _interopDefault(require('get-port'));
var net = require('net');
var ssh2 = require('ssh2');
var pg = require('pg');
var QueryStream = _interopDefault(require('pg-query-stream'));
var Presto = require('presto-client');
var https = require('https');
var mssql = require('mssql');
var util = require('util');
var EventEmitter = require('events');
var EventEmitter__default = _interopDefault(EventEmitter);
require('cron-parser');
var Analytics = _interopDefault(require('analytics-node'));
var os = require('os');
var readlineSync = require('readline-sync');
var uuid = require('uuid');
var untildify = _interopDefault(require('untildify'));
var jsBeautify = require('js-beautify');
var sqlFormatter = require('sql-formatter');

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

const dataform = $root.dataform = (() => {

    /**
     * Namespace dataform.
     * @exports dataform
     * @namespace
     */
    const dataform = {};

    dataform.ProjectConfig = (function() {

        /**
         * Properties of a ProjectConfig.
         * @memberof dataform
         * @interface IProjectConfig
         * @property {string|null} [warehouse] ProjectConfig warehouse
         * @property {string|null} [defaultDatabase] ProjectConfig defaultDatabase
         * @property {string|null} [defaultSchema] ProjectConfig defaultSchema
         * @property {string|null} [assertionSchema] ProjectConfig assertionSchema
         * @property {Object.<string,string>|null} [vars] ProjectConfig vars
         * @property {number|null} [concurrentQueryLimit] ProjectConfig concurrentQueryLimit
         * @property {number|null} [idempotentActionRetries] ProjectConfig idempotentActionRetries
         * @property {string|null} [databaseSuffix] ProjectConfig databaseSuffix
         * @property {string|null} [schemaSuffix] ProjectConfig schemaSuffix
         * @property {string|null} [tablePrefix] ProjectConfig tablePrefix
         * @property {boolean|null} [useRunCache] ProjectConfig useRunCache
         * @property {string|null} [gcloudProjectId] ProjectConfig gcloudProjectId
         */

        /**
         * Constructs a new ProjectConfig.
         * @memberof dataform
         * @classdesc Represents a ProjectConfig.
         * @implements IProjectConfig
         * @constructor
         * @param {dataform.IProjectConfig=} [properties] Properties to set
         */
        function ProjectConfig(properties) {
            this.vars = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProjectConfig warehouse.
         * @member {string} warehouse
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.warehouse = "";

        /**
         * ProjectConfig defaultDatabase.
         * @member {string} defaultDatabase
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultDatabase = "";

        /**
         * ProjectConfig defaultSchema.
         * @member {string} defaultSchema
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultSchema = "";

        /**
         * ProjectConfig assertionSchema.
         * @member {string} assertionSchema
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.assertionSchema = "";

        /**
         * ProjectConfig vars.
         * @member {Object.<string,string>} vars
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.vars = $util.emptyObject;

        /**
         * ProjectConfig concurrentQueryLimit.
         * @member {number} concurrentQueryLimit
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.concurrentQueryLimit = 0;

        /**
         * ProjectConfig idempotentActionRetries.
         * @member {number} idempotentActionRetries
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.idempotentActionRetries = 0;

        /**
         * ProjectConfig databaseSuffix.
         * @member {string} databaseSuffix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.databaseSuffix = "";

        /**
         * ProjectConfig schemaSuffix.
         * @member {string} schemaSuffix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.schemaSuffix = "";

        /**
         * ProjectConfig tablePrefix.
         * @member {string} tablePrefix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.tablePrefix = "";

        /**
         * ProjectConfig useRunCache.
         * @member {boolean} useRunCache
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.useRunCache = false;

        /**
         * ProjectConfig gcloudProjectId.
         * @member {string} gcloudProjectId
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.gcloudProjectId = "";

        /**
         * Creates a new ProjectConfig instance using the specified properties.
         * @function create
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig=} [properties] Properties to set
         * @returns {dataform.ProjectConfig} ProjectConfig instance
         */
        ProjectConfig.create = function create(properties) {
            return new ProjectConfig(properties);
        };

        /**
         * Encodes the specified ProjectConfig message. Does not implicitly {@link dataform.ProjectConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig} message ProjectConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProjectConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.warehouse);
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.defaultSchema);
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.assertionSchema);
            if (message.gcloudProjectId != null && message.hasOwnProperty("gcloudProjectId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.gcloudProjectId);
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.schemaSuffix);
            if (message.idempotentActionRetries != null && message.hasOwnProperty("idempotentActionRetries"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.idempotentActionRetries);
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.defaultDatabase);
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.useRunCache);
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.tablePrefix);
            if (message.concurrentQueryLimit != null && message.hasOwnProperty("concurrentQueryLimit"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.concurrentQueryLimit);
            if (message.vars != null && message.hasOwnProperty("vars"))
                for (let keys = Object.keys(message.vars), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.vars[keys[i]]).ldelim();
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.databaseSuffix);
            return writer;
        };

        /**
         * Encodes the specified ProjectConfig message, length delimited. Does not implicitly {@link dataform.ProjectConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig} message ProjectConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProjectConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProjectConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ProjectConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ProjectConfig} ProjectConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProjectConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ProjectConfig(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.warehouse = reader.string();
                    break;
                case 9:
                    message.defaultDatabase = reader.string();
                    break;
                case 2:
                    message.defaultSchema = reader.string();
                    break;
                case 5:
                    message.assertionSchema = reader.string();
                    break;
                case 14:
                    reader.skip().pos++;
                    if (message.vars === $util.emptyObject)
                        message.vars = {};
                    key = reader.string();
                    reader.pos++;
                    message.vars[key] = reader.string();
                    break;
                case 13:
                    message.concurrentQueryLimit = reader.int32();
                    break;
                case 8:
                    message.idempotentActionRetries = reader.int32();
                    break;
                case 15:
                    message.databaseSuffix = reader.string();
                    break;
                case 7:
                    message.schemaSuffix = reader.string();
                    break;
                case 11:
                    message.tablePrefix = reader.string();
                    break;
                case 10:
                    message.useRunCache = reader.bool();
                    break;
                case 6:
                    message.gcloudProjectId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProjectConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ProjectConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ProjectConfig} ProjectConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProjectConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProjectConfig message.
         * @function verify
         * @memberof dataform.ProjectConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProjectConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                if (!$util.isString(message.warehouse))
                    return "warehouse: string expected";
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                if (!$util.isString(message.defaultDatabase))
                    return "defaultDatabase: string expected";
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                if (!$util.isString(message.defaultSchema))
                    return "defaultSchema: string expected";
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                if (!$util.isString(message.assertionSchema))
                    return "assertionSchema: string expected";
            if (message.vars != null && message.hasOwnProperty("vars")) {
                if (!$util.isObject(message.vars))
                    return "vars: object expected";
                let key = Object.keys(message.vars);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.vars[key[i]]))
                        return "vars: string{k:string} expected";
            }
            if (message.concurrentQueryLimit != null && message.hasOwnProperty("concurrentQueryLimit"))
                if (!$util.isInteger(message.concurrentQueryLimit))
                    return "concurrentQueryLimit: integer expected";
            if (message.idempotentActionRetries != null && message.hasOwnProperty("idempotentActionRetries"))
                if (!$util.isInteger(message.idempotentActionRetries))
                    return "idempotentActionRetries: integer expected";
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                if (!$util.isString(message.databaseSuffix))
                    return "databaseSuffix: string expected";
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                if (!$util.isString(message.schemaSuffix))
                    return "schemaSuffix: string expected";
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                if (!$util.isString(message.tablePrefix))
                    return "tablePrefix: string expected";
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                if (typeof message.useRunCache !== "boolean")
                    return "useRunCache: boolean expected";
            if (message.gcloudProjectId != null && message.hasOwnProperty("gcloudProjectId"))
                if (!$util.isString(message.gcloudProjectId))
                    return "gcloudProjectId: string expected";
            return null;
        };

        /**
         * Creates a ProjectConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ProjectConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ProjectConfig} ProjectConfig
         */
        ProjectConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ProjectConfig)
                return object;
            let message = new $root.dataform.ProjectConfig();
            if (object.warehouse != null)
                message.warehouse = String(object.warehouse);
            if (object.defaultDatabase != null)
                message.defaultDatabase = String(object.defaultDatabase);
            if (object.defaultSchema != null)
                message.defaultSchema = String(object.defaultSchema);
            if (object.assertionSchema != null)
                message.assertionSchema = String(object.assertionSchema);
            if (object.vars) {
                if (typeof object.vars !== "object")
                    throw TypeError(".dataform.ProjectConfig.vars: object expected");
                message.vars = {};
                for (let keys = Object.keys(object.vars), i = 0; i < keys.length; ++i)
                    message.vars[keys[i]] = String(object.vars[keys[i]]);
            }
            if (object.concurrentQueryLimit != null)
                message.concurrentQueryLimit = object.concurrentQueryLimit | 0;
            if (object.idempotentActionRetries != null)
                message.idempotentActionRetries = object.idempotentActionRetries | 0;
            if (object.databaseSuffix != null)
                message.databaseSuffix = String(object.databaseSuffix);
            if (object.schemaSuffix != null)
                message.schemaSuffix = String(object.schemaSuffix);
            if (object.tablePrefix != null)
                message.tablePrefix = String(object.tablePrefix);
            if (object.useRunCache != null)
                message.useRunCache = Boolean(object.useRunCache);
            if (object.gcloudProjectId != null)
                message.gcloudProjectId = String(object.gcloudProjectId);
            return message;
        };

        /**
         * Creates a plain object from a ProjectConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.ProjectConfig} message ProjectConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProjectConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.vars = {};
            if (options.defaults) {
                object.warehouse = "";
                object.defaultSchema = "";
                object.assertionSchema = "";
                object.gcloudProjectId = "";
                object.schemaSuffix = "";
                object.idempotentActionRetries = 0;
                object.defaultDatabase = "";
                object.useRunCache = false;
                object.tablePrefix = "";
                object.concurrentQueryLimit = 0;
                object.databaseSuffix = "";
            }
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                object.warehouse = message.warehouse;
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                object.defaultSchema = message.defaultSchema;
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                object.assertionSchema = message.assertionSchema;
            if (message.gcloudProjectId != null && message.hasOwnProperty("gcloudProjectId"))
                object.gcloudProjectId = message.gcloudProjectId;
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                object.schemaSuffix = message.schemaSuffix;
            if (message.idempotentActionRetries != null && message.hasOwnProperty("idempotentActionRetries"))
                object.idempotentActionRetries = message.idempotentActionRetries;
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                object.defaultDatabase = message.defaultDatabase;
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                object.useRunCache = message.useRunCache;
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                object.tablePrefix = message.tablePrefix;
            if (message.concurrentQueryLimit != null && message.hasOwnProperty("concurrentQueryLimit"))
                object.concurrentQueryLimit = message.concurrentQueryLimit;
            let keys2;
            if (message.vars && (keys2 = Object.keys(message.vars)).length) {
                object.vars = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.vars[keys2[j]] = message.vars[keys2[j]];
            }
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                object.databaseSuffix = message.databaseSuffix;
            return object;
        };

        /**
         * Converts this ProjectConfig to JSON.
         * @function toJSON
         * @memberof dataform.ProjectConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProjectConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProjectConfig;
    })();

    dataform.Environments = (function() {

        /**
         * Properties of an Environments.
         * @memberof dataform
         * @interface IEnvironments
         * @property {Array.<dataform.Environments.IEnvironment>|null} [environments] Environments environments
         * @property {Array.<dataform.Environments.INotificationChannel>|null} [notificationChannels] Environments notificationChannels
         */

        /**
         * Constructs a new Environments.
         * @memberof dataform
         * @classdesc Represents an Environments.
         * @implements IEnvironments
         * @constructor
         * @param {dataform.IEnvironments=} [properties] Properties to set
         */
        function Environments(properties) {
            this.environments = [];
            this.notificationChannels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Environments environments.
         * @member {Array.<dataform.Environments.IEnvironment>} environments
         * @memberof dataform.Environments
         * @instance
         */
        Environments.prototype.environments = $util.emptyArray;

        /**
         * Environments notificationChannels.
         * @member {Array.<dataform.Environments.INotificationChannel>} notificationChannels
         * @memberof dataform.Environments
         * @instance
         */
        Environments.prototype.notificationChannels = $util.emptyArray;

        /**
         * Creates a new Environments instance using the specified properties.
         * @function create
         * @memberof dataform.Environments
         * @static
         * @param {dataform.IEnvironments=} [properties] Properties to set
         * @returns {dataform.Environments} Environments instance
         */
        Environments.create = function create(properties) {
            return new Environments(properties);
        };

        /**
         * Encodes the specified Environments message. Does not implicitly {@link dataform.Environments.verify|verify} messages.
         * @function encode
         * @memberof dataform.Environments
         * @static
         * @param {dataform.IEnvironments} message Environments message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Environments.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.environments != null && message.environments.length)
                for (let i = 0; i < message.environments.length; ++i)
                    $root.dataform.Environments.Environment.encode(message.environments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.notificationChannels != null && message.notificationChannels.length)
                for (let i = 0; i < message.notificationChannels.length; ++i)
                    $root.dataform.Environments.NotificationChannel.encode(message.notificationChannels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Environments message, length delimited. Does not implicitly {@link dataform.Environments.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Environments
         * @static
         * @param {dataform.IEnvironments} message Environments message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Environments.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Environments message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Environments
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Environments} Environments
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Environments.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.environments && message.environments.length))
                        message.environments = [];
                    message.environments.push($root.dataform.Environments.Environment.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.notificationChannels && message.notificationChannels.length))
                        message.notificationChannels = [];
                    message.notificationChannels.push($root.dataform.Environments.NotificationChannel.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Environments message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Environments
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Environments} Environments
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Environments.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Environments message.
         * @function verify
         * @memberof dataform.Environments
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Environments.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.environments != null && message.hasOwnProperty("environments")) {
                if (!Array.isArray(message.environments))
                    return "environments: array expected";
                for (let i = 0; i < message.environments.length; ++i) {
                    let error = $root.dataform.Environments.Environment.verify(message.environments[i]);
                    if (error)
                        return "environments." + error;
                }
            }
            if (message.notificationChannels != null && message.hasOwnProperty("notificationChannels")) {
                if (!Array.isArray(message.notificationChannels))
                    return "notificationChannels: array expected";
                for (let i = 0; i < message.notificationChannels.length; ++i) {
                    let error = $root.dataform.Environments.NotificationChannel.verify(message.notificationChannels[i]);
                    if (error)
                        return "notificationChannels." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Environments message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Environments
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Environments} Environments
         */
        Environments.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Environments)
                return object;
            let message = new $root.dataform.Environments();
            if (object.environments) {
                if (!Array.isArray(object.environments))
                    throw TypeError(".dataform.Environments.environments: array expected");
                message.environments = [];
                for (let i = 0; i < object.environments.length; ++i) {
                    if (typeof object.environments[i] !== "object")
                        throw TypeError(".dataform.Environments.environments: object expected");
                    message.environments[i] = $root.dataform.Environments.Environment.fromObject(object.environments[i]);
                }
            }
            if (object.notificationChannels) {
                if (!Array.isArray(object.notificationChannels))
                    throw TypeError(".dataform.Environments.notificationChannels: array expected");
                message.notificationChannels = [];
                for (let i = 0; i < object.notificationChannels.length; ++i) {
                    if (typeof object.notificationChannels[i] !== "object")
                        throw TypeError(".dataform.Environments.notificationChannels: object expected");
                    message.notificationChannels[i] = $root.dataform.Environments.NotificationChannel.fromObject(object.notificationChannels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Environments message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Environments
         * @static
         * @param {dataform.Environments} message Environments
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Environments.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.environments = [];
                object.notificationChannels = [];
            }
            if (message.environments && message.environments.length) {
                object.environments = [];
                for (let j = 0; j < message.environments.length; ++j)
                    object.environments[j] = $root.dataform.Environments.Environment.toObject(message.environments[j], options);
            }
            if (message.notificationChannels && message.notificationChannels.length) {
                object.notificationChannels = [];
                for (let j = 0; j < message.notificationChannels.length; ++j)
                    object.notificationChannels[j] = $root.dataform.Environments.NotificationChannel.toObject(message.notificationChannels[j], options);
            }
            return object;
        };

        /**
         * Converts this Environments to JSON.
         * @function toJSON
         * @memberof dataform.Environments
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Environments.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Environments.Environment = (function() {

            /**
             * Properties of an Environment.
             * @memberof dataform.Environments
             * @interface IEnvironment
             * @property {string|null} [name] Environment name
             * @property {string|null} [gitRef] Environment gitRef
             * @property {dataform.Environments.Environment.IGitReference|null} [gitReference] Environment gitReference
             * @property {dataform.IProjectConfig|null} [configOverride] Environment configOverride
             * @property {Array.<dataform.Environments.Environment.ISchedule>|null} [schedules] Environment schedules
             */

            /**
             * Constructs a new Environment.
             * @memberof dataform.Environments
             * @classdesc Represents an Environment.
             * @implements IEnvironment
             * @constructor
             * @param {dataform.Environments.IEnvironment=} [properties] Properties to set
             */
            function Environment(properties) {
                this.schedules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Environment name.
             * @member {string} name
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.name = "";

            /**
             * Environment gitRef.
             * @member {string} gitRef
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.gitRef = "";

            /**
             * Environment gitReference.
             * @member {dataform.Environments.Environment.IGitReference|null|undefined} gitReference
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.gitReference = null;

            /**
             * Environment configOverride.
             * @member {dataform.IProjectConfig|null|undefined} configOverride
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.configOverride = null;

            /**
             * Environment schedules.
             * @member {Array.<dataform.Environments.Environment.ISchedule>} schedules
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.schedules = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Environment gitSettings.
             * @member {"gitRef"|"gitReference"|undefined} gitSettings
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Object.defineProperty(Environment.prototype, "gitSettings", {
                get: $util.oneOfGetter($oneOfFields = ["gitRef", "gitReference"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Environment instance using the specified properties.
             * @function create
             * @memberof dataform.Environments.Environment
             * @static
             * @param {dataform.Environments.IEnvironment=} [properties] Properties to set
             * @returns {dataform.Environments.Environment} Environment instance
             */
            Environment.create = function create(properties) {
                return new Environment(properties);
            };

            /**
             * Encodes the specified Environment message. Does not implicitly {@link dataform.Environments.Environment.verify|verify} messages.
             * @function encode
             * @memberof dataform.Environments.Environment
             * @static
             * @param {dataform.Environments.IEnvironment} message Environment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Environment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.gitReference != null && message.hasOwnProperty("gitReference"))
                    $root.dataform.Environments.Environment.GitReference.encode(message.gitReference, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.configOverride != null && message.hasOwnProperty("configOverride"))
                    $root.dataform.ProjectConfig.encode(message.configOverride, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.schedules != null && message.schedules.length)
                    for (let i = 0; i < message.schedules.length; ++i)
                        $root.dataform.Environments.Environment.Schedule.encode(message.schedules[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.gitRef != null && message.hasOwnProperty("gitRef"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.gitRef);
                return writer;
            };

            /**
             * Encodes the specified Environment message, length delimited. Does not implicitly {@link dataform.Environments.Environment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.Environments.Environment
             * @static
             * @param {dataform.Environments.IEnvironment} message Environment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Environment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Environment message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.Environments.Environment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.Environments.Environment} Environment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Environment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 5:
                        message.gitRef = reader.string();
                        break;
                    case 2:
                        message.gitReference = $root.dataform.Environments.Environment.GitReference.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.configOverride = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.schedules && message.schedules.length))
                            message.schedules = [];
                        message.schedules.push($root.dataform.Environments.Environment.Schedule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Environment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.Environments.Environment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.Environments.Environment} Environment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Environment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Environment message.
             * @function verify
             * @memberof dataform.Environments.Environment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Environment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.gitRef != null && message.hasOwnProperty("gitRef")) {
                    properties.gitSettings = 1;
                    if (!$util.isString(message.gitRef))
                        return "gitRef: string expected";
                }
                if (message.gitReference != null && message.hasOwnProperty("gitReference")) {
                    if (properties.gitSettings === 1)
                        return "gitSettings: multiple values";
                    properties.gitSettings = 1;
                    {
                        let error = $root.dataform.Environments.Environment.GitReference.verify(message.gitReference);
                        if (error)
                            return "gitReference." + error;
                    }
                }
                if (message.configOverride != null && message.hasOwnProperty("configOverride")) {
                    let error = $root.dataform.ProjectConfig.verify(message.configOverride);
                    if (error)
                        return "configOverride." + error;
                }
                if (message.schedules != null && message.hasOwnProperty("schedules")) {
                    if (!Array.isArray(message.schedules))
                        return "schedules: array expected";
                    for (let i = 0; i < message.schedules.length; ++i) {
                        let error = $root.dataform.Environments.Environment.Schedule.verify(message.schedules[i]);
                        if (error)
                            return "schedules." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Environment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.Environments.Environment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.Environments.Environment} Environment
             */
            Environment.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.Environments.Environment)
                    return object;
                let message = new $root.dataform.Environments.Environment();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.gitRef != null)
                    message.gitRef = String(object.gitRef);
                if (object.gitReference != null) {
                    if (typeof object.gitReference !== "object")
                        throw TypeError(".dataform.Environments.Environment.gitReference: object expected");
                    message.gitReference = $root.dataform.Environments.Environment.GitReference.fromObject(object.gitReference);
                }
                if (object.configOverride != null) {
                    if (typeof object.configOverride !== "object")
                        throw TypeError(".dataform.Environments.Environment.configOverride: object expected");
                    message.configOverride = $root.dataform.ProjectConfig.fromObject(object.configOverride);
                }
                if (object.schedules) {
                    if (!Array.isArray(object.schedules))
                        throw TypeError(".dataform.Environments.Environment.schedules: array expected");
                    message.schedules = [];
                    for (let i = 0; i < object.schedules.length; ++i) {
                        if (typeof object.schedules[i] !== "object")
                            throw TypeError(".dataform.Environments.Environment.schedules: object expected");
                        message.schedules[i] = $root.dataform.Environments.Environment.Schedule.fromObject(object.schedules[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Environment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.Environments.Environment
             * @static
             * @param {dataform.Environments.Environment} message Environment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Environment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.schedules = [];
                if (options.defaults) {
                    object.name = "";
                    object.configOverride = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.gitReference != null && message.hasOwnProperty("gitReference")) {
                    object.gitReference = $root.dataform.Environments.Environment.GitReference.toObject(message.gitReference, options);
                    if (options.oneofs)
                        object.gitSettings = "gitReference";
                }
                if (message.configOverride != null && message.hasOwnProperty("configOverride"))
                    object.configOverride = $root.dataform.ProjectConfig.toObject(message.configOverride, options);
                if (message.schedules && message.schedules.length) {
                    object.schedules = [];
                    for (let j = 0; j < message.schedules.length; ++j)
                        object.schedules[j] = $root.dataform.Environments.Environment.Schedule.toObject(message.schedules[j], options);
                }
                if (message.gitRef != null && message.hasOwnProperty("gitRef")) {
                    object.gitRef = message.gitRef;
                    if (options.oneofs)
                        object.gitSettings = "gitRef";
                }
                return object;
            };

            /**
             * Converts this Environment to JSON.
             * @function toJSON
             * @memberof dataform.Environments.Environment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Environment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Environment.GitReference = (function() {

                /**
                 * Properties of a GitReference.
                 * @memberof dataform.Environments.Environment
                 * @interface IGitReference
                 * @property {string|null} [branch] GitReference branch
                 * @property {string|null} [commitSha] GitReference commitSha
                 */

                /**
                 * Constructs a new GitReference.
                 * @memberof dataform.Environments.Environment
                 * @classdesc Represents a GitReference.
                 * @implements IGitReference
                 * @constructor
                 * @param {dataform.Environments.Environment.IGitReference=} [properties] Properties to set
                 */
                function GitReference(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GitReference branch.
                 * @member {string} branch
                 * @memberof dataform.Environments.Environment.GitReference
                 * @instance
                 */
                GitReference.prototype.branch = "";

                /**
                 * GitReference commitSha.
                 * @member {string} commitSha
                 * @memberof dataform.Environments.Environment.GitReference
                 * @instance
                 */
                GitReference.prototype.commitSha = "";

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * GitReference gitReference.
                 * @member {"branch"|"commitSha"|undefined} gitReference
                 * @memberof dataform.Environments.Environment.GitReference
                 * @instance
                 */
                Object.defineProperty(GitReference.prototype, "gitReference", {
                    get: $util.oneOfGetter($oneOfFields = ["branch", "commitSha"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new GitReference instance using the specified properties.
                 * @function create
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {dataform.Environments.Environment.IGitReference=} [properties] Properties to set
                 * @returns {dataform.Environments.Environment.GitReference} GitReference instance
                 */
                GitReference.create = function create(properties) {
                    return new GitReference(properties);
                };

                /**
                 * Encodes the specified GitReference message. Does not implicitly {@link dataform.Environments.Environment.GitReference.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {dataform.Environments.Environment.IGitReference} message GitReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GitReference.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.branch != null && message.hasOwnProperty("branch"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.branch);
                    if (message.commitSha != null && message.hasOwnProperty("commitSha"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.commitSha);
                    return writer;
                };

                /**
                 * Encodes the specified GitReference message, length delimited. Does not implicitly {@link dataform.Environments.Environment.GitReference.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {dataform.Environments.Environment.IGitReference} message GitReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GitReference.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GitReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.Environments.Environment.GitReference} GitReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GitReference.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment.GitReference();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.branch = reader.string();
                            break;
                        case 2:
                            message.commitSha = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GitReference message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.Environments.Environment.GitReference} GitReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GitReference.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GitReference message.
                 * @function verify
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GitReference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.branch != null && message.hasOwnProperty("branch")) {
                        properties.gitReference = 1;
                        if (!$util.isString(message.branch))
                            return "branch: string expected";
                    }
                    if (message.commitSha != null && message.hasOwnProperty("commitSha")) {
                        if (properties.gitReference === 1)
                            return "gitReference: multiple values";
                        properties.gitReference = 1;
                        if (!$util.isString(message.commitSha))
                            return "commitSha: string expected";
                    }
                    return null;
                };

                /**
                 * Creates a GitReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.Environments.Environment.GitReference} GitReference
                 */
                GitReference.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.Environments.Environment.GitReference)
                        return object;
                    let message = new $root.dataform.Environments.Environment.GitReference();
                    if (object.branch != null)
                        message.branch = String(object.branch);
                    if (object.commitSha != null)
                        message.commitSha = String(object.commitSha);
                    return message;
                };

                /**
                 * Creates a plain object from a GitReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {dataform.Environments.Environment.GitReference} message GitReference
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GitReference.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.branch != null && message.hasOwnProperty("branch")) {
                        object.branch = message.branch;
                        if (options.oneofs)
                            object.gitReference = "branch";
                    }
                    if (message.commitSha != null && message.hasOwnProperty("commitSha")) {
                        object.commitSha = message.commitSha;
                        if (options.oneofs)
                            object.gitReference = "commitSha";
                    }
                    return object;
                };

                /**
                 * Converts this GitReference to JSON.
                 * @function toJSON
                 * @memberof dataform.Environments.Environment.GitReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GitReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GitReference;
            })();

            Environment.Schedule = (function() {

                /**
                 * Properties of a Schedule.
                 * @memberof dataform.Environments.Environment
                 * @interface ISchedule
                 * @property {string|null} [name] Schedule name
                 * @property {string|null} [cron] Schedule cron
                 * @property {Array.<string>|null} [tags] Schedule tags
                 * @property {dataform.Environments.Environment.Schedule.IOptions|null} [options] Schedule options
                 * @property {boolean|null} [disabled] Schedule disabled
                 * @property {Array.<dataform.Environments.Environment.Schedule.INotificationRequirement>|null} [notify] Schedule notify
                 */

                /**
                 * Constructs a new Schedule.
                 * @memberof dataform.Environments.Environment
                 * @classdesc Represents a Schedule.
                 * @implements ISchedule
                 * @constructor
                 * @param {dataform.Environments.Environment.ISchedule=} [properties] Properties to set
                 */
                function Schedule(properties) {
                    this.tags = [];
                    this.notify = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Schedule name.
                 * @member {string} name
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.name = "";

                /**
                 * Schedule cron.
                 * @member {string} cron
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.cron = "";

                /**
                 * Schedule tags.
                 * @member {Array.<string>} tags
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.tags = $util.emptyArray;

                /**
                 * Schedule options.
                 * @member {dataform.Environments.Environment.Schedule.IOptions|null|undefined} options
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.options = null;

                /**
                 * Schedule disabled.
                 * @member {boolean} disabled
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.disabled = false;

                /**
                 * Schedule notify.
                 * @member {Array.<dataform.Environments.Environment.Schedule.INotificationRequirement>} notify
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.notify = $util.emptyArray;

                /**
                 * Creates a new Schedule instance using the specified properties.
                 * @function create
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {dataform.Environments.Environment.ISchedule=} [properties] Properties to set
                 * @returns {dataform.Environments.Environment.Schedule} Schedule instance
                 */
                Schedule.create = function create(properties) {
                    return new Schedule(properties);
                };

                /**
                 * Encodes the specified Schedule message. Does not implicitly {@link dataform.Environments.Environment.Schedule.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {dataform.Environments.Environment.ISchedule} message Schedule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Schedule.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.cron != null && message.hasOwnProperty("cron"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.cron);
                    if (message.tags != null && message.tags.length)
                        for (let i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tags[i]);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.dataform.Environments.Environment.Schedule.Options.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.disabled != null && message.hasOwnProperty("disabled"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.disabled);
                    if (message.notify != null && message.notify.length)
                        for (let i = 0; i < message.notify.length; ++i)
                            $root.dataform.Environments.Environment.Schedule.NotificationRequirement.encode(message.notify[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Schedule message, length delimited. Does not implicitly {@link dataform.Environments.Environment.Schedule.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {dataform.Environments.Environment.ISchedule} message Schedule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Schedule.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Schedule message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.Environments.Environment.Schedule} Schedule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Schedule.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment.Schedule();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.cron = reader.string();
                            break;
                        case 3:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        case 4:
                            message.options = $root.dataform.Environments.Environment.Schedule.Options.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.disabled = reader.bool();
                            break;
                        case 6:
                            if (!(message.notify && message.notify.length))
                                message.notify = [];
                            message.notify.push($root.dataform.Environments.Environment.Schedule.NotificationRequirement.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Schedule message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.Environments.Environment.Schedule} Schedule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Schedule.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Schedule message.
                 * @function verify
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Schedule.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.cron != null && message.hasOwnProperty("cron"))
                        if (!$util.isString(message.cron))
                            return "cron: string expected";
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (let i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.dataform.Environments.Environment.Schedule.Options.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.disabled != null && message.hasOwnProperty("disabled"))
                        if (typeof message.disabled !== "boolean")
                            return "disabled: boolean expected";
                    if (message.notify != null && message.hasOwnProperty("notify")) {
                        if (!Array.isArray(message.notify))
                            return "notify: array expected";
                        for (let i = 0; i < message.notify.length; ++i) {
                            let error = $root.dataform.Environments.Environment.Schedule.NotificationRequirement.verify(message.notify[i]);
                            if (error)
                                return "notify." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Schedule message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.Environments.Environment.Schedule} Schedule
                 */
                Schedule.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.Environments.Environment.Schedule)
                        return object;
                    let message = new $root.dataform.Environments.Environment.Schedule();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.cron != null)
                        message.cron = String(object.cron);
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".dataform.Environments.Environment.Schedule.tags: array expected");
                        message.tags = [];
                        for (let i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".dataform.Environments.Environment.Schedule.options: object expected");
                        message.options = $root.dataform.Environments.Environment.Schedule.Options.fromObject(object.options);
                    }
                    if (object.disabled != null)
                        message.disabled = Boolean(object.disabled);
                    if (object.notify) {
                        if (!Array.isArray(object.notify))
                            throw TypeError(".dataform.Environments.Environment.Schedule.notify: array expected");
                        message.notify = [];
                        for (let i = 0; i < object.notify.length; ++i) {
                            if (typeof object.notify[i] !== "object")
                                throw TypeError(".dataform.Environments.Environment.Schedule.notify: object expected");
                            message.notify[i] = $root.dataform.Environments.Environment.Schedule.NotificationRequirement.fromObject(object.notify[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Schedule message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {dataform.Environments.Environment.Schedule} message Schedule
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Schedule.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.tags = [];
                        object.notify = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.cron = "";
                        object.options = null;
                        object.disabled = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.cron != null && message.hasOwnProperty("cron"))
                        object.cron = message.cron;
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (let j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.dataform.Environments.Environment.Schedule.Options.toObject(message.options, options);
                    if (message.disabled != null && message.hasOwnProperty("disabled"))
                        object.disabled = message.disabled;
                    if (message.notify && message.notify.length) {
                        object.notify = [];
                        for (let j = 0; j < message.notify.length; ++j)
                            object.notify[j] = $root.dataform.Environments.Environment.Schedule.NotificationRequirement.toObject(message.notify[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Schedule to JSON.
                 * @function toJSON
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Schedule.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Schedule.Options = (function() {

                    /**
                     * Properties of an Options.
                     * @memberof dataform.Environments.Environment.Schedule
                     * @interface IOptions
                     * @property {boolean|null} [includeDependencies] Options includeDependencies
                     * @property {boolean|null} [includeDependents] Options includeDependents
                     * @property {boolean|null} [fullRefresh] Options fullRefresh
                     */

                    /**
                     * Constructs a new Options.
                     * @memberof dataform.Environments.Environment.Schedule
                     * @classdesc Represents an Options.
                     * @implements IOptions
                     * @constructor
                     * @param {dataform.Environments.Environment.Schedule.IOptions=} [properties] Properties to set
                     */
                    function Options(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Options includeDependencies.
                     * @member {boolean} includeDependencies
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @instance
                     */
                    Options.prototype.includeDependencies = false;

                    /**
                     * Options includeDependents.
                     * @member {boolean} includeDependents
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @instance
                     */
                    Options.prototype.includeDependents = false;

                    /**
                     * Options fullRefresh.
                     * @member {boolean} fullRefresh
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @instance
                     */
                    Options.prototype.fullRefresh = false;

                    /**
                     * Creates a new Options instance using the specified properties.
                     * @function create
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.IOptions=} [properties] Properties to set
                     * @returns {dataform.Environments.Environment.Schedule.Options} Options instance
                     */
                    Options.create = function create(properties) {
                        return new Options(properties);
                    };

                    /**
                     * Encodes the specified Options message. Does not implicitly {@link dataform.Environments.Environment.Schedule.Options.verify|verify} messages.
                     * @function encode
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.IOptions} message Options message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Options.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includeDependencies);
                        if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fullRefresh);
                        if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.includeDependents);
                        return writer;
                    };

                    /**
                     * Encodes the specified Options message, length delimited. Does not implicitly {@link dataform.Environments.Environment.Schedule.Options.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.IOptions} message Options message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Options.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Options message from the specified reader or buffer.
                     * @function decode
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {dataform.Environments.Environment.Schedule.Options} Options
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Options.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment.Schedule.Options();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 4:
                                message.includeDependencies = reader.bool();
                                break;
                            case 6:
                                message.includeDependents = reader.bool();
                                break;
                            case 5:
                                message.fullRefresh = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Options message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {dataform.Environments.Environment.Schedule.Options} Options
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Options.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Options message.
                     * @function verify
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Options.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                            if (typeof message.includeDependencies !== "boolean")
                                return "includeDependencies: boolean expected";
                        if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                            if (typeof message.includeDependents !== "boolean")
                                return "includeDependents: boolean expected";
                        if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                            if (typeof message.fullRefresh !== "boolean")
                                return "fullRefresh: boolean expected";
                        return null;
                    };

                    /**
                     * Creates an Options message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {dataform.Environments.Environment.Schedule.Options} Options
                     */
                    Options.fromObject = function fromObject(object) {
                        if (object instanceof $root.dataform.Environments.Environment.Schedule.Options)
                            return object;
                        let message = new $root.dataform.Environments.Environment.Schedule.Options();
                        if (object.includeDependencies != null)
                            message.includeDependencies = Boolean(object.includeDependencies);
                        if (object.includeDependents != null)
                            message.includeDependents = Boolean(object.includeDependents);
                        if (object.fullRefresh != null)
                            message.fullRefresh = Boolean(object.fullRefresh);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Options message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.Options} message Options
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Options.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.includeDependencies = false;
                            object.fullRefresh = false;
                            object.includeDependents = false;
                        }
                        if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                            object.includeDependencies = message.includeDependencies;
                        if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                            object.fullRefresh = message.fullRefresh;
                        if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                            object.includeDependents = message.includeDependents;
                        return object;
                    };

                    /**
                     * Converts this Options to JSON.
                     * @function toJSON
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Options.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Options;
                })();

                Schedule.NotificationRequirement = (function() {

                    /**
                     * Properties of a NotificationRequirement.
                     * @memberof dataform.Environments.Environment.Schedule
                     * @interface INotificationRequirement
                     * @property {string|null} [channel] NotificationRequirement channel
                     * @property {Array.<dataform.Environments.Environment.Schedule.NotificationRequirement.CompletionStatus>|null} [statuses] NotificationRequirement statuses
                     */

                    /**
                     * Constructs a new NotificationRequirement.
                     * @memberof dataform.Environments.Environment.Schedule
                     * @classdesc Represents a NotificationRequirement.
                     * @implements INotificationRequirement
                     * @constructor
                     * @param {dataform.Environments.Environment.Schedule.INotificationRequirement=} [properties] Properties to set
                     */
                    function NotificationRequirement(properties) {
                        this.statuses = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * NotificationRequirement channel.
                     * @member {string} channel
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @instance
                     */
                    NotificationRequirement.prototype.channel = "";

                    /**
                     * NotificationRequirement statuses.
                     * @member {Array.<dataform.Environments.Environment.Schedule.NotificationRequirement.CompletionStatus>} statuses
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @instance
                     */
                    NotificationRequirement.prototype.statuses = $util.emptyArray;

                    /**
                     * Creates a new NotificationRequirement instance using the specified properties.
                     * @function create
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.INotificationRequirement=} [properties] Properties to set
                     * @returns {dataform.Environments.Environment.Schedule.NotificationRequirement} NotificationRequirement instance
                     */
                    NotificationRequirement.create = function create(properties) {
                        return new NotificationRequirement(properties);
                    };

                    /**
                     * Encodes the specified NotificationRequirement message. Does not implicitly {@link dataform.Environments.Environment.Schedule.NotificationRequirement.verify|verify} messages.
                     * @function encode
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.INotificationRequirement} message NotificationRequirement message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NotificationRequirement.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                        if (message.statuses != null && message.statuses.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (let i = 0; i < message.statuses.length; ++i)
                                writer.int32(message.statuses[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };

                    /**
                     * Encodes the specified NotificationRequirement message, length delimited. Does not implicitly {@link dataform.Environments.Environment.Schedule.NotificationRequirement.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.INotificationRequirement} message NotificationRequirement message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NotificationRequirement.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a NotificationRequirement message from the specified reader or buffer.
                     * @function decode
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {dataform.Environments.Environment.Schedule.NotificationRequirement} NotificationRequirement
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NotificationRequirement.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment.Schedule.NotificationRequirement();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.channel = reader.string();
                                break;
                            case 2:
                                if (!(message.statuses && message.statuses.length))
                                    message.statuses = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.statuses.push(reader.int32());
                                } else
                                    message.statuses.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a NotificationRequirement message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {dataform.Environments.Environment.Schedule.NotificationRequirement} NotificationRequirement
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NotificationRequirement.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a NotificationRequirement message.
                     * @function verify
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NotificationRequirement.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            if (!$util.isString(message.channel))
                                return "channel: string expected";
                        if (message.statuses != null && message.hasOwnProperty("statuses")) {
                            if (!Array.isArray(message.statuses))
                                return "statuses: array expected";
                            for (let i = 0; i < message.statuses.length; ++i)
                                switch (message.statuses[i]) {
                                default:
                                    return "statuses: enum value[] expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                        }
                        return null;
                    };

                    /**
                     * Creates a NotificationRequirement message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {dataform.Environments.Environment.Schedule.NotificationRequirement} NotificationRequirement
                     */
                    NotificationRequirement.fromObject = function fromObject(object) {
                        if (object instanceof $root.dataform.Environments.Environment.Schedule.NotificationRequirement)
                            return object;
                        let message = new $root.dataform.Environments.Environment.Schedule.NotificationRequirement();
                        if (object.channel != null)
                            message.channel = String(object.channel);
                        if (object.statuses) {
                            if (!Array.isArray(object.statuses))
                                throw TypeError(".dataform.Environments.Environment.Schedule.NotificationRequirement.statuses: array expected");
                            message.statuses = [];
                            for (let i = 0; i < object.statuses.length; ++i)
                                switch (object.statuses[i]) {
                                default:
                                case "UNKNOWN":
                                case 0:
                                    message.statuses[i] = 0;
                                    break;
                                case "SUCCESS":
                                case 1:
                                    message.statuses[i] = 1;
                                    break;
                                case "FAILURE":
                                case 2:
                                    message.statuses[i] = 2;
                                    break;
                                }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a NotificationRequirement message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.NotificationRequirement} message NotificationRequirement
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NotificationRequirement.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.statuses = [];
                        if (options.defaults)
                            object.channel = "";
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            object.channel = message.channel;
                        if (message.statuses && message.statuses.length) {
                            object.statuses = [];
                            for (let j = 0; j < message.statuses.length; ++j)
                                object.statuses[j] = options.enums === String ? $root.dataform.Environments.Environment.Schedule.NotificationRequirement.CompletionStatus[message.statuses[j]] : message.statuses[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this NotificationRequirement to JSON.
                     * @function toJSON
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NotificationRequirement.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * CompletionStatus enum.
                     * @name dataform.Environments.Environment.Schedule.NotificationRequirement.CompletionStatus
                     * @enum {string}
                     * @property {number} UNKNOWN=0 UNKNOWN value
                     * @property {number} SUCCESS=1 SUCCESS value
                     * @property {number} FAILURE=2 FAILURE value
                     */
                    NotificationRequirement.CompletionStatus = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN"] = 0;
                        values[valuesById[1] = "SUCCESS"] = 1;
                        values[valuesById[2] = "FAILURE"] = 2;
                        return values;
                    })();

                    return NotificationRequirement;
                })();

                return Schedule;
            })();

            return Environment;
        })();

        Environments.NotificationChannel = (function() {

            /**
             * Properties of a NotificationChannel.
             * @memberof dataform.Environments
             * @interface INotificationChannel
             * @property {string|null} [name] NotificationChannel name
             * @property {dataform.Environments.NotificationChannel.IEmailNotificationChannel|null} [email] NotificationChannel email
             * @property {dataform.Environments.NotificationChannel.ISlackNotificationChannel|null} [slack] NotificationChannel slack
             */

            /**
             * Constructs a new NotificationChannel.
             * @memberof dataform.Environments
             * @classdesc Represents a NotificationChannel.
             * @implements INotificationChannel
             * @constructor
             * @param {dataform.Environments.INotificationChannel=} [properties] Properties to set
             */
            function NotificationChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotificationChannel name.
             * @member {string} name
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.name = "";

            /**
             * NotificationChannel email.
             * @member {dataform.Environments.NotificationChannel.IEmailNotificationChannel|null|undefined} email
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.email = null;

            /**
             * NotificationChannel slack.
             * @member {dataform.Environments.NotificationChannel.ISlackNotificationChannel|null|undefined} slack
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.slack = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NotificationChannel channel.
             * @member {"email"|"slack"|undefined} channel
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             */
            Object.defineProperty(NotificationChannel.prototype, "channel", {
                get: $util.oneOfGetter($oneOfFields = ["email", "slack"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NotificationChannel instance using the specified properties.
             * @function create
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {dataform.Environments.INotificationChannel=} [properties] Properties to set
             * @returns {dataform.Environments.NotificationChannel} NotificationChannel instance
             */
            NotificationChannel.create = function create(properties) {
                return new NotificationChannel(properties);
            };

            /**
             * Encodes the specified NotificationChannel message. Does not implicitly {@link dataform.Environments.NotificationChannel.verify|verify} messages.
             * @function encode
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {dataform.Environments.INotificationChannel} message NotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.email != null && message.hasOwnProperty("email"))
                    $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.encode(message.email, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.slack != null && message.hasOwnProperty("slack"))
                    $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.encode(message.slack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NotificationChannel message, length delimited. Does not implicitly {@link dataform.Environments.NotificationChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {dataform.Environments.INotificationChannel} message NotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotificationChannel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.Environments.NotificationChannel} NotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.NotificationChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.email = $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.slack = $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotificationChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.Environments.NotificationChannel} NotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotificationChannel message.
             * @function verify
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotificationChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties.channel = 1;
                    {
                        let error = $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.verify(message.email);
                        if (error)
                            return "email." + error;
                    }
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    if (properties.channel === 1)
                        return "channel: multiple values";
                    properties.channel = 1;
                    {
                        let error = $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.verify(message.slack);
                        if (error)
                            return "slack." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NotificationChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.Environments.NotificationChannel} NotificationChannel
             */
            NotificationChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.Environments.NotificationChannel)
                    return object;
                let message = new $root.dataform.Environments.NotificationChannel();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.email != null) {
                    if (typeof object.email !== "object")
                        throw TypeError(".dataform.Environments.NotificationChannel.email: object expected");
                    message.email = $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.fromObject(object.email);
                }
                if (object.slack != null) {
                    if (typeof object.slack !== "object")
                        throw TypeError(".dataform.Environments.NotificationChannel.slack: object expected");
                    message.slack = $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.fromObject(object.slack);
                }
                return message;
            };

            /**
             * Creates a plain object from a NotificationChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {dataform.Environments.NotificationChannel} message NotificationChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotificationChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.email != null && message.hasOwnProperty("email")) {
                    object.email = $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.toObject(message.email, options);
                    if (options.oneofs)
                        object.channel = "email";
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    object.slack = $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.toObject(message.slack, options);
                    if (options.oneofs)
                        object.channel = "slack";
                }
                return object;
            };

            /**
             * Converts this NotificationChannel to JSON.
             * @function toJSON
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotificationChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            NotificationChannel.EmailNotificationChannel = (function() {

                /**
                 * Properties of an EmailNotificationChannel.
                 * @memberof dataform.Environments.NotificationChannel
                 * @interface IEmailNotificationChannel
                 * @property {Array.<string>|null} [to] EmailNotificationChannel to
                 */

                /**
                 * Constructs a new EmailNotificationChannel.
                 * @memberof dataform.Environments.NotificationChannel
                 * @classdesc Represents an EmailNotificationChannel.
                 * @implements IEmailNotificationChannel
                 * @constructor
                 * @param {dataform.Environments.NotificationChannel.IEmailNotificationChannel=} [properties] Properties to set
                 */
                function EmailNotificationChannel(properties) {
                    this.to = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EmailNotificationChannel to.
                 * @member {Array.<string>} to
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @instance
                 */
                EmailNotificationChannel.prototype.to = $util.emptyArray;

                /**
                 * Creates a new EmailNotificationChannel instance using the specified properties.
                 * @function create
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.IEmailNotificationChannel=} [properties] Properties to set
                 * @returns {dataform.Environments.NotificationChannel.EmailNotificationChannel} EmailNotificationChannel instance
                 */
                EmailNotificationChannel.create = function create(properties) {
                    return new EmailNotificationChannel(properties);
                };

                /**
                 * Encodes the specified EmailNotificationChannel message. Does not implicitly {@link dataform.Environments.NotificationChannel.EmailNotificationChannel.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.IEmailNotificationChannel} message EmailNotificationChannel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmailNotificationChannel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.to != null && message.to.length)
                        for (let i = 0; i < message.to.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.to[i]);
                    return writer;
                };

                /**
                 * Encodes the specified EmailNotificationChannel message, length delimited. Does not implicitly {@link dataform.Environments.NotificationChannel.EmailNotificationChannel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.IEmailNotificationChannel} message EmailNotificationChannel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmailNotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EmailNotificationChannel message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.Environments.NotificationChannel.EmailNotificationChannel} EmailNotificationChannel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmailNotificationChannel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.NotificationChannel.EmailNotificationChannel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.to && message.to.length))
                                message.to = [];
                            message.to.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EmailNotificationChannel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.Environments.NotificationChannel.EmailNotificationChannel} EmailNotificationChannel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmailNotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EmailNotificationChannel message.
                 * @function verify
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EmailNotificationChannel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.to != null && message.hasOwnProperty("to")) {
                        if (!Array.isArray(message.to))
                            return "to: array expected";
                        for (let i = 0; i < message.to.length; ++i)
                            if (!$util.isString(message.to[i]))
                                return "to: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates an EmailNotificationChannel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.Environments.NotificationChannel.EmailNotificationChannel} EmailNotificationChannel
                 */
                EmailNotificationChannel.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.Environments.NotificationChannel.EmailNotificationChannel)
                        return object;
                    let message = new $root.dataform.Environments.NotificationChannel.EmailNotificationChannel();
                    if (object.to) {
                        if (!Array.isArray(object.to))
                            throw TypeError(".dataform.Environments.NotificationChannel.EmailNotificationChannel.to: array expected");
                        message.to = [];
                        for (let i = 0; i < object.to.length; ++i)
                            message.to[i] = String(object.to[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an EmailNotificationChannel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.EmailNotificationChannel} message EmailNotificationChannel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EmailNotificationChannel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.to = [];
                    if (message.to && message.to.length) {
                        object.to = [];
                        for (let j = 0; j < message.to.length; ++j)
                            object.to[j] = message.to[j];
                    }
                    return object;
                };

                /**
                 * Converts this EmailNotificationChannel to JSON.
                 * @function toJSON
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EmailNotificationChannel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EmailNotificationChannel;
            })();

            NotificationChannel.SlackNotificationChannel = (function() {

                /**
                 * Properties of a SlackNotificationChannel.
                 * @memberof dataform.Environments.NotificationChannel
                 * @interface ISlackNotificationChannel
                 * @property {string|null} [webhookUrl] SlackNotificationChannel webhookUrl
                 */

                /**
                 * Constructs a new SlackNotificationChannel.
                 * @memberof dataform.Environments.NotificationChannel
                 * @classdesc Represents a SlackNotificationChannel.
                 * @implements ISlackNotificationChannel
                 * @constructor
                 * @param {dataform.Environments.NotificationChannel.ISlackNotificationChannel=} [properties] Properties to set
                 */
                function SlackNotificationChannel(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SlackNotificationChannel webhookUrl.
                 * @member {string} webhookUrl
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @instance
                 */
                SlackNotificationChannel.prototype.webhookUrl = "";

                /**
                 * Creates a new SlackNotificationChannel instance using the specified properties.
                 * @function create
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.ISlackNotificationChannel=} [properties] Properties to set
                 * @returns {dataform.Environments.NotificationChannel.SlackNotificationChannel} SlackNotificationChannel instance
                 */
                SlackNotificationChannel.create = function create(properties) {
                    return new SlackNotificationChannel(properties);
                };

                /**
                 * Encodes the specified SlackNotificationChannel message. Does not implicitly {@link dataform.Environments.NotificationChannel.SlackNotificationChannel.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.ISlackNotificationChannel} message SlackNotificationChannel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlackNotificationChannel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.webhookUrl);
                    return writer;
                };

                /**
                 * Encodes the specified SlackNotificationChannel message, length delimited. Does not implicitly {@link dataform.Environments.NotificationChannel.SlackNotificationChannel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.ISlackNotificationChannel} message SlackNotificationChannel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlackNotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SlackNotificationChannel message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.Environments.NotificationChannel.SlackNotificationChannel} SlackNotificationChannel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlackNotificationChannel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.NotificationChannel.SlackNotificationChannel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.webhookUrl = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SlackNotificationChannel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.Environments.NotificationChannel.SlackNotificationChannel} SlackNotificationChannel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlackNotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SlackNotificationChannel message.
                 * @function verify
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SlackNotificationChannel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                        if (!$util.isString(message.webhookUrl))
                            return "webhookUrl: string expected";
                    return null;
                };

                /**
                 * Creates a SlackNotificationChannel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.Environments.NotificationChannel.SlackNotificationChannel} SlackNotificationChannel
                 */
                SlackNotificationChannel.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.Environments.NotificationChannel.SlackNotificationChannel)
                        return object;
                    let message = new $root.dataform.Environments.NotificationChannel.SlackNotificationChannel();
                    if (object.webhookUrl != null)
                        message.webhookUrl = String(object.webhookUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a SlackNotificationChannel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.SlackNotificationChannel} message SlackNotificationChannel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SlackNotificationChannel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.webhookUrl = "";
                    if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                        object.webhookUrl = message.webhookUrl;
                    return object;
                };

                /**
                 * Converts this SlackNotificationChannel to JSON.
                 * @function toJSON
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SlackNotificationChannel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SlackNotificationChannel;
            })();

            return NotificationChannel;
        })();

        return Environments;
    })();

    dataform.RunConfig = (function() {

        /**
         * Properties of a RunConfig.
         * @memberof dataform
         * @interface IRunConfig
         * @property {Array.<string>|null} [actions] RunConfig actions
         * @property {Array.<string>|null} [tags] RunConfig tags
         * @property {boolean|null} [includeDependencies] RunConfig includeDependencies
         * @property {boolean|null} [includeDependents] RunConfig includeDependents
         * @property {boolean|null} [fullRefresh] RunConfig fullRefresh
         * @property {number|null} [timeoutMillis] RunConfig timeoutMillis
         * @property {boolean|null} [useRunCache] RunConfig useRunCache
         * @property {boolean|null} [disableSetMetadata] RunConfig disableSetMetadata
         */

        /**
         * Constructs a new RunConfig.
         * @memberof dataform
         * @classdesc Represents a RunConfig.
         * @implements IRunConfig
         * @constructor
         * @param {dataform.IRunConfig=} [properties] Properties to set
         */
        function RunConfig(properties) {
            this.actions = [];
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RunConfig actions.
         * @member {Array.<string>} actions
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.actions = $util.emptyArray;

        /**
         * RunConfig tags.
         * @member {Array.<string>} tags
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.tags = $util.emptyArray;

        /**
         * RunConfig includeDependencies.
         * @member {boolean} includeDependencies
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.includeDependencies = false;

        /**
         * RunConfig includeDependents.
         * @member {boolean} includeDependents
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.includeDependents = false;

        /**
         * RunConfig fullRefresh.
         * @member {boolean} fullRefresh
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.fullRefresh = false;

        /**
         * RunConfig timeoutMillis.
         * @member {number} timeoutMillis
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.timeoutMillis = 0;

        /**
         * RunConfig useRunCache.
         * @member {boolean} useRunCache
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.useRunCache = false;

        /**
         * RunConfig disableSetMetadata.
         * @member {boolean} disableSetMetadata
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.disableSetMetadata = false;

        /**
         * Creates a new RunConfig instance using the specified properties.
         * @function create
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig=} [properties] Properties to set
         * @returns {dataform.RunConfig} RunConfig instance
         */
        RunConfig.create = function create(properties) {
            return new RunConfig(properties);
        };

        /**
         * Encodes the specified RunConfig message. Does not implicitly {@link dataform.RunConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig} message RunConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.actions[i]);
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fullRefresh);
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeDependencies);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.timeoutMillis);
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.useRunCache);
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.disableSetMetadata);
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.includeDependents);
            return writer;
        };

        /**
         * Encodes the specified RunConfig message, length delimited. Does not implicitly {@link dataform.RunConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig} message RunConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RunConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RunConfig} RunConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RunConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.actions && message.actions.length))
                        message.actions = [];
                    message.actions.push(reader.string());
                    break;
                case 5:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 3:
                    message.includeDependencies = reader.bool();
                    break;
                case 11:
                    message.includeDependents = reader.bool();
                    break;
                case 2:
                    message.fullRefresh = reader.bool();
                    break;
                case 7:
                    message.timeoutMillis = reader.int32();
                    break;
                case 8:
                    message.useRunCache = reader.bool();
                    break;
                case 9:
                    message.disableSetMetadata = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RunConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RunConfig} RunConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunConfig message.
         * @function verify
         * @memberof dataform.RunConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i)
                    if (!$util.isString(message.actions[i]))
                        return "actions: string[] expected";
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                if (typeof message.includeDependencies !== "boolean")
                    return "includeDependencies: boolean expected";
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                if (typeof message.includeDependents !== "boolean")
                    return "includeDependents: boolean expected";
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                if (typeof message.fullRefresh !== "boolean")
                    return "fullRefresh: boolean expected";
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                if (!$util.isInteger(message.timeoutMillis))
                    return "timeoutMillis: integer expected";
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                if (typeof message.useRunCache !== "boolean")
                    return "useRunCache: boolean expected";
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                if (typeof message.disableSetMetadata !== "boolean")
                    return "disableSetMetadata: boolean expected";
            return null;
        };

        /**
         * Creates a RunConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RunConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RunConfig} RunConfig
         */
        RunConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RunConfig)
                return object;
            let message = new $root.dataform.RunConfig();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.RunConfig.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i)
                    message.actions[i] = String(object.actions[i]);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.RunConfig.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.includeDependencies != null)
                message.includeDependencies = Boolean(object.includeDependencies);
            if (object.includeDependents != null)
                message.includeDependents = Boolean(object.includeDependents);
            if (object.fullRefresh != null)
                message.fullRefresh = Boolean(object.fullRefresh);
            if (object.timeoutMillis != null)
                message.timeoutMillis = object.timeoutMillis | 0;
            if (object.useRunCache != null)
                message.useRunCache = Boolean(object.useRunCache);
            if (object.disableSetMetadata != null)
                message.disableSetMetadata = Boolean(object.disableSetMetadata);
            return message;
        };

        /**
         * Creates a plain object from a RunConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.RunConfig} message RunConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.tags = [];
            }
            if (options.defaults) {
                object.fullRefresh = false;
                object.includeDependencies = false;
                object.timeoutMillis = 0;
                object.useRunCache = false;
                object.disableSetMetadata = false;
                object.includeDependents = false;
            }
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = message.actions[j];
            }
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                object.fullRefresh = message.fullRefresh;
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                object.includeDependencies = message.includeDependencies;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                object.timeoutMillis = message.timeoutMillis;
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                object.useRunCache = message.useRunCache;
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                object.disableSetMetadata = message.disableSetMetadata;
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                object.includeDependents = message.includeDependents;
            return object;
        };

        /**
         * Converts this RunConfig to JSON.
         * @function toJSON
         * @memberof dataform.RunConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunConfig;
    })();

    dataform.GenerateIndexConfig = (function() {

        /**
         * Properties of a GenerateIndexConfig.
         * @memberof dataform
         * @interface IGenerateIndexConfig
         * @property {dataform.ICompileConfig|null} [compileConfig] GenerateIndexConfig compileConfig
         * @property {Array.<string>|null} [includePaths] GenerateIndexConfig includePaths
         * @property {Array.<string>|null} [definitionPaths] GenerateIndexConfig definitionPaths
         * @property {string|null} [returnOverride] GenerateIndexConfig returnOverride
         */

        /**
         * Constructs a new GenerateIndexConfig.
         * @memberof dataform
         * @classdesc Represents a GenerateIndexConfig.
         * @implements IGenerateIndexConfig
         * @constructor
         * @param {dataform.IGenerateIndexConfig=} [properties] Properties to set
         */
        function GenerateIndexConfig(properties) {
            this.includePaths = [];
            this.definitionPaths = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenerateIndexConfig compileConfig.
         * @member {dataform.ICompileConfig|null|undefined} compileConfig
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.compileConfig = null;

        /**
         * GenerateIndexConfig includePaths.
         * @member {Array.<string>} includePaths
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.includePaths = $util.emptyArray;

        /**
         * GenerateIndexConfig definitionPaths.
         * @member {Array.<string>} definitionPaths
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.definitionPaths = $util.emptyArray;

        /**
         * GenerateIndexConfig returnOverride.
         * @member {string} returnOverride
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.returnOverride = "";

        /**
         * Creates a new GenerateIndexConfig instance using the specified properties.
         * @function create
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig=} [properties] Properties to set
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig instance
         */
        GenerateIndexConfig.create = function create(properties) {
            return new GenerateIndexConfig(properties);
        };

        /**
         * Encodes the specified GenerateIndexConfig message. Does not implicitly {@link dataform.GenerateIndexConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig} message GenerateIndexConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenerateIndexConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig"))
                $root.dataform.CompileConfig.encode(message.compileConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.includePaths != null && message.includePaths.length)
                for (let i = 0; i < message.includePaths.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.includePaths[i]);
            if (message.definitionPaths != null && message.definitionPaths.length)
                for (let i = 0; i < message.definitionPaths.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.definitionPaths[i]);
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.returnOverride);
            return writer;
        };

        /**
         * Encodes the specified GenerateIndexConfig message, length delimited. Does not implicitly {@link dataform.GenerateIndexConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig} message GenerateIndexConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenerateIndexConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenerateIndexConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenerateIndexConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.GenerateIndexConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.compileConfig = $root.dataform.CompileConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.includePaths && message.includePaths.length))
                        message.includePaths = [];
                    message.includePaths.push(reader.string());
                    break;
                case 3:
                    if (!(message.definitionPaths && message.definitionPaths.length))
                        message.definitionPaths = [];
                    message.definitionPaths.push(reader.string());
                    break;
                case 4:
                    message.returnOverride = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenerateIndexConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenerateIndexConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenerateIndexConfig message.
         * @function verify
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenerateIndexConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig")) {
                let error = $root.dataform.CompileConfig.verify(message.compileConfig);
                if (error)
                    return "compileConfig." + error;
            }
            if (message.includePaths != null && message.hasOwnProperty("includePaths")) {
                if (!Array.isArray(message.includePaths))
                    return "includePaths: array expected";
                for (let i = 0; i < message.includePaths.length; ++i)
                    if (!$util.isString(message.includePaths[i]))
                        return "includePaths: string[] expected";
            }
            if (message.definitionPaths != null && message.hasOwnProperty("definitionPaths")) {
                if (!Array.isArray(message.definitionPaths))
                    return "definitionPaths: array expected";
                for (let i = 0; i < message.definitionPaths.length; ++i)
                    if (!$util.isString(message.definitionPaths[i]))
                        return "definitionPaths: string[] expected";
            }
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                if (!$util.isString(message.returnOverride))
                    return "returnOverride: string expected";
            return null;
        };

        /**
         * Creates a GenerateIndexConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         */
        GenerateIndexConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.GenerateIndexConfig)
                return object;
            let message = new $root.dataform.GenerateIndexConfig();
            if (object.compileConfig != null) {
                if (typeof object.compileConfig !== "object")
                    throw TypeError(".dataform.GenerateIndexConfig.compileConfig: object expected");
                message.compileConfig = $root.dataform.CompileConfig.fromObject(object.compileConfig);
            }
            if (object.includePaths) {
                if (!Array.isArray(object.includePaths))
                    throw TypeError(".dataform.GenerateIndexConfig.includePaths: array expected");
                message.includePaths = [];
                for (let i = 0; i < object.includePaths.length; ++i)
                    message.includePaths[i] = String(object.includePaths[i]);
            }
            if (object.definitionPaths) {
                if (!Array.isArray(object.definitionPaths))
                    throw TypeError(".dataform.GenerateIndexConfig.definitionPaths: array expected");
                message.definitionPaths = [];
                for (let i = 0; i < object.definitionPaths.length; ++i)
                    message.definitionPaths[i] = String(object.definitionPaths[i]);
            }
            if (object.returnOverride != null)
                message.returnOverride = String(object.returnOverride);
            return message;
        };

        /**
         * Creates a plain object from a GenerateIndexConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.GenerateIndexConfig} message GenerateIndexConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenerateIndexConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.includePaths = [];
                object.definitionPaths = [];
            }
            if (options.defaults) {
                object.compileConfig = null;
                object.returnOverride = "";
            }
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig"))
                object.compileConfig = $root.dataform.CompileConfig.toObject(message.compileConfig, options);
            if (message.includePaths && message.includePaths.length) {
                object.includePaths = [];
                for (let j = 0; j < message.includePaths.length; ++j)
                    object.includePaths[j] = message.includePaths[j];
            }
            if (message.definitionPaths && message.definitionPaths.length) {
                object.definitionPaths = [];
                for (let j = 0; j < message.definitionPaths.length; ++j)
                    object.definitionPaths[j] = message.definitionPaths[j];
            }
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                object.returnOverride = message.returnOverride;
            return object;
        };

        /**
         * Converts this GenerateIndexConfig to JSON.
         * @function toJSON
         * @memberof dataform.GenerateIndexConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenerateIndexConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenerateIndexConfig;
    })();

    dataform.CompileConfig = (function() {

        /**
         * Properties of a CompileConfig.
         * @memberof dataform
         * @interface ICompileConfig
         * @property {string|null} [projectDir] CompileConfig projectDir
         * @property {dataform.IProjectConfig|null} [projectConfigOverride] CompileConfig projectConfigOverride
         * @property {boolean|null} [compileSingleQuery] CompileConfig compileSingleQuery
         * @property {string|null} [query] CompileConfig query
         * @property {number|null} [timeoutMillis] CompileConfig timeoutMillis
         * @property {string|null} [schemaSuffixOverride] CompileConfig schemaSuffixOverride
         * @property {string|null} [returnOverride] CompileConfig returnOverride
         */

        /**
         * Constructs a new CompileConfig.
         * @memberof dataform
         * @classdesc Represents a CompileConfig.
         * @implements ICompileConfig
         * @constructor
         * @param {dataform.ICompileConfig=} [properties] Properties to set
         */
        function CompileConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompileConfig projectDir.
         * @member {string} projectDir
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.projectDir = "";

        /**
         * CompileConfig projectConfigOverride.
         * @member {dataform.IProjectConfig|null|undefined} projectConfigOverride
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.projectConfigOverride = null;

        /**
         * CompileConfig compileSingleQuery.
         * @member {boolean} compileSingleQuery
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.compileSingleQuery = false;

        /**
         * CompileConfig query.
         * @member {string} query
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.query = "";

        /**
         * CompileConfig timeoutMillis.
         * @member {number} timeoutMillis
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.timeoutMillis = 0;

        /**
         * CompileConfig schemaSuffixOverride.
         * @member {string} schemaSuffixOverride
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.schemaSuffixOverride = "";

        /**
         * CompileConfig returnOverride.
         * @member {string} returnOverride
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.returnOverride = "";

        /**
         * Creates a new CompileConfig instance using the specified properties.
         * @function create
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig=} [properties] Properties to set
         * @returns {dataform.CompileConfig} CompileConfig instance
         */
        CompileConfig.create = function create(properties) {
            return new CompileConfig(properties);
        };

        /**
         * Encodes the specified CompileConfig message. Does not implicitly {@link dataform.CompileConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig} message CompileConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectDir);
            if (message.schemaSuffixOverride != null && message.hasOwnProperty("schemaSuffixOverride"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaSuffixOverride);
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride"))
                $root.dataform.ProjectConfig.encode(message.projectConfigOverride, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.query);
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.returnOverride);
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.timeoutMillis);
            if (message.compileSingleQuery != null && message.hasOwnProperty("compileSingleQuery"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.compileSingleQuery);
            return writer;
        };

        /**
         * Encodes the specified CompileConfig message, length delimited. Does not implicitly {@link dataform.CompileConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig} message CompileConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompileConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompileConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompileConfig} CompileConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompileConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.projectDir = reader.string();
                    break;
                case 3:
                    message.projectConfigOverride = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.compileSingleQuery = reader.bool();
                    break;
                case 4:
                    message.query = reader.string();
                    break;
                case 6:
                    message.timeoutMillis = reader.int32();
                    break;
                case 2:
                    message.schemaSuffixOverride = reader.string();
                    break;
                case 5:
                    message.returnOverride = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompileConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompileConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompileConfig} CompileConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompileConfig message.
         * @function verify
         * @memberof dataform.CompileConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompileConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                if (!$util.isString(message.projectDir))
                    return "projectDir: string expected";
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfigOverride);
                if (error)
                    return "projectConfigOverride." + error;
            }
            if (message.compileSingleQuery != null && message.hasOwnProperty("compileSingleQuery"))
                if (typeof message.compileSingleQuery !== "boolean")
                    return "compileSingleQuery: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                if (!$util.isInteger(message.timeoutMillis))
                    return "timeoutMillis: integer expected";
            if (message.schemaSuffixOverride != null && message.hasOwnProperty("schemaSuffixOverride"))
                if (!$util.isString(message.schemaSuffixOverride))
                    return "schemaSuffixOverride: string expected";
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                if (!$util.isString(message.returnOverride))
                    return "returnOverride: string expected";
            return null;
        };

        /**
         * Creates a CompileConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompileConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompileConfig} CompileConfig
         */
        CompileConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompileConfig)
                return object;
            let message = new $root.dataform.CompileConfig();
            if (object.projectDir != null)
                message.projectDir = String(object.projectDir);
            if (object.projectConfigOverride != null) {
                if (typeof object.projectConfigOverride !== "object")
                    throw TypeError(".dataform.CompileConfig.projectConfigOverride: object expected");
                message.projectConfigOverride = $root.dataform.ProjectConfig.fromObject(object.projectConfigOverride);
            }
            if (object.compileSingleQuery != null)
                message.compileSingleQuery = Boolean(object.compileSingleQuery);
            if (object.query != null)
                message.query = String(object.query);
            if (object.timeoutMillis != null)
                message.timeoutMillis = object.timeoutMillis | 0;
            if (object.schemaSuffixOverride != null)
                message.schemaSuffixOverride = String(object.schemaSuffixOverride);
            if (object.returnOverride != null)
                message.returnOverride = String(object.returnOverride);
            return message;
        };

        /**
         * Creates a plain object from a CompileConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.CompileConfig} message CompileConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompileConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.projectDir = "";
                object.schemaSuffixOverride = "";
                object.projectConfigOverride = null;
                object.query = "";
                object.returnOverride = "";
                object.timeoutMillis = 0;
                object.compileSingleQuery = false;
            }
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                object.projectDir = message.projectDir;
            if (message.schemaSuffixOverride != null && message.hasOwnProperty("schemaSuffixOverride"))
                object.schemaSuffixOverride = message.schemaSuffixOverride;
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride"))
                object.projectConfigOverride = $root.dataform.ProjectConfig.toObject(message.projectConfigOverride, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                object.returnOverride = message.returnOverride;
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                object.timeoutMillis = message.timeoutMillis;
            if (message.compileSingleQuery != null && message.hasOwnProperty("compileSingleQuery"))
                object.compileSingleQuery = message.compileSingleQuery;
            return object;
        };

        /**
         * Converts this CompileConfig to JSON.
         * @function toJSON
         * @memberof dataform.CompileConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompileConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CompileConfig;
    })();

    dataform.Target = (function() {

        /**
         * Properties of a Target.
         * @memberof dataform
         * @interface ITarget
         * @property {string|null} [database] Target database
         * @property {string|null} [schema] Target schema
         * @property {string|null} [name] Target name
         */

        /**
         * Constructs a new Target.
         * @memberof dataform
         * @classdesc Represents a Target.
         * @implements ITarget
         * @constructor
         * @param {dataform.ITarget=} [properties] Properties to set
         */
        function Target(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Target database.
         * @member {string} database
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.database = "";

        /**
         * Target schema.
         * @member {string} schema
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.schema = "";

        /**
         * Target name.
         * @member {string} name
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.name = "";

        /**
         * Creates a new Target instance using the specified properties.
         * @function create
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget=} [properties] Properties to set
         * @returns {dataform.Target} Target instance
         */
        Target.create = function create(properties) {
            return new Target(properties);
        };

        /**
         * Encodes the specified Target message. Does not implicitly {@link dataform.Target.verify|verify} messages.
         * @function encode
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && message.hasOwnProperty("schema"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.schema);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.database != null && message.hasOwnProperty("database"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.database);
            return writer;
        };

        /**
         * Encodes the specified Target message, length delimited. Does not implicitly {@link dataform.Target.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Target message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Target();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.database = reader.string();
                    break;
                case 1:
                    message.schema = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Target message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Target message.
         * @function verify
         * @memberof dataform.Target
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Target.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isString(message.schema))
                    return "schema: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Target message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Target
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Target} Target
         */
        Target.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Target)
                return object;
            let message = new $root.dataform.Target();
            if (object.database != null)
                message.database = String(object.database);
            if (object.schema != null)
                message.schema = String(object.schema);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Target message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Target
         * @static
         * @param {dataform.Target} message Target
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Target.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.schema = "";
                object.name = "";
                object.database = "";
            }
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            return object;
        };

        /**
         * Converts this Target to JSON.
         * @function toJSON
         * @memberof dataform.Target
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Target.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Target;
    })();

    dataform.BigQueryOptions = (function() {

        /**
         * Properties of a BigQueryOptions.
         * @memberof dataform
         * @interface IBigQueryOptions
         * @property {string|null} [partitionBy] BigQueryOptions partitionBy
         * @property {Array.<string>|null} [clusterBy] BigQueryOptions clusterBy
         * @property {string|null} [updatePartitionFilter] BigQueryOptions updatePartitionFilter
         * @property {Object.<string,string>|null} [labels] BigQueryOptions labels
         */

        /**
         * Constructs a new BigQueryOptions.
         * @memberof dataform
         * @classdesc Represents a BigQueryOptions.
         * @implements IBigQueryOptions
         * @constructor
         * @param {dataform.IBigQueryOptions=} [properties] Properties to set
         */
        function BigQueryOptions(properties) {
            this.clusterBy = [];
            this.labels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigQueryOptions partitionBy.
         * @member {string} partitionBy
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.partitionBy = "";

        /**
         * BigQueryOptions clusterBy.
         * @member {Array.<string>} clusterBy
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.clusterBy = $util.emptyArray;

        /**
         * BigQueryOptions updatePartitionFilter.
         * @member {string} updatePartitionFilter
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.updatePartitionFilter = "";

        /**
         * BigQueryOptions labels.
         * @member {Object.<string,string>} labels
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.labels = $util.emptyObject;

        /**
         * Creates a new BigQueryOptions instance using the specified properties.
         * @function create
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions=} [properties] Properties to set
         * @returns {dataform.BigQueryOptions} BigQueryOptions instance
         */
        BigQueryOptions.create = function create(properties) {
            return new BigQueryOptions(properties);
        };

        /**
         * Encodes the specified BigQueryOptions message. Does not implicitly {@link dataform.BigQueryOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions} message BigQueryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQueryOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.partitionBy);
            if (message.clusterBy != null && message.clusterBy.length)
                for (let i = 0; i < message.clusterBy.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterBy[i]);
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.updatePartitionFilter);
            if (message.labels != null && message.hasOwnProperty("labels"))
                for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BigQueryOptions message, length delimited. Does not implicitly {@link dataform.BigQueryOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions} message BigQueryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQueryOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BigQueryOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQueryOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.BigQueryOptions(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.partitionBy = reader.string();
                    break;
                case 2:
                    if (!(message.clusterBy && message.clusterBy.length))
                        message.clusterBy = [];
                    message.clusterBy.push(reader.string());
                    break;
                case 3:
                    message.updatePartitionFilter = reader.string();
                    break;
                case 4:
                    reader.skip().pos++;
                    if (message.labels === $util.emptyObject)
                        message.labels = {};
                    key = reader.string();
                    reader.pos++;
                    message.labels[key] = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BigQueryOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQueryOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BigQueryOptions message.
         * @function verify
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BigQueryOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                if (!$util.isString(message.partitionBy))
                    return "partitionBy: string expected";
            if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                if (!Array.isArray(message.clusterBy))
                    return "clusterBy: array expected";
                for (let i = 0; i < message.clusterBy.length; ++i)
                    if (!$util.isString(message.clusterBy[i]))
                        return "clusterBy: string[] expected";
            }
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                if (!$util.isString(message.updatePartitionFilter))
                    return "updatePartitionFilter: string expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!$util.isObject(message.labels))
                    return "labels: object expected";
                let key = Object.keys(message.labels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.labels[key[i]]))
                        return "labels: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a BigQueryOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         */
        BigQueryOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.BigQueryOptions)
                return object;
            let message = new $root.dataform.BigQueryOptions();
            if (object.partitionBy != null)
                message.partitionBy = String(object.partitionBy);
            if (object.clusterBy) {
                if (!Array.isArray(object.clusterBy))
                    throw TypeError(".dataform.BigQueryOptions.clusterBy: array expected");
                message.clusterBy = [];
                for (let i = 0; i < object.clusterBy.length; ++i)
                    message.clusterBy[i] = String(object.clusterBy[i]);
            }
            if (object.updatePartitionFilter != null)
                message.updatePartitionFilter = String(object.updatePartitionFilter);
            if (object.labels) {
                if (typeof object.labels !== "object")
                    throw TypeError(".dataform.BigQueryOptions.labels: object expected");
                message.labels = {};
                for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                    message.labels[keys[i]] = String(object.labels[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a BigQueryOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.BigQueryOptions} message BigQueryOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BigQueryOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.clusterBy = [];
            if (options.objects || options.defaults)
                object.labels = {};
            if (options.defaults) {
                object.partitionBy = "";
                object.updatePartitionFilter = "";
            }
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                object.partitionBy = message.partitionBy;
            if (message.clusterBy && message.clusterBy.length) {
                object.clusterBy = [];
                for (let j = 0; j < message.clusterBy.length; ++j)
                    object.clusterBy[j] = message.clusterBy[j];
            }
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                object.updatePartitionFilter = message.updatePartitionFilter;
            let keys2;
            if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                object.labels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.labels[keys2[j]] = message.labels[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this BigQueryOptions to JSON.
         * @function toJSON
         * @memberof dataform.BigQueryOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BigQueryOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BigQueryOptions;
    })();

    dataform.RedshiftOptions = (function() {

        /**
         * Properties of a RedshiftOptions.
         * @memberof dataform
         * @interface IRedshiftOptions
         * @property {string|null} [distKey] RedshiftOptions distKey
         * @property {string|null} [distStyle] RedshiftOptions distStyle
         * @property {Array.<string>|null} [sortKeys] RedshiftOptions sortKeys
         * @property {string|null} [sortStyle] RedshiftOptions sortStyle
         * @property {boolean|null} [bind] RedshiftOptions bind
         */

        /**
         * Constructs a new RedshiftOptions.
         * @memberof dataform
         * @classdesc Represents a RedshiftOptions.
         * @implements IRedshiftOptions
         * @constructor
         * @param {dataform.IRedshiftOptions=} [properties] Properties to set
         */
        function RedshiftOptions(properties) {
            this.sortKeys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedshiftOptions distKey.
         * @member {string} distKey
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.distKey = "";

        /**
         * RedshiftOptions distStyle.
         * @member {string} distStyle
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.distStyle = "";

        /**
         * RedshiftOptions sortKeys.
         * @member {Array.<string>} sortKeys
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.sortKeys = $util.emptyArray;

        /**
         * RedshiftOptions sortStyle.
         * @member {string} sortStyle
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.sortStyle = "";

        /**
         * RedshiftOptions bind.
         * @member {boolean} bind
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.bind = false;

        /**
         * Creates a new RedshiftOptions instance using the specified properties.
         * @function create
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions=} [properties] Properties to set
         * @returns {dataform.RedshiftOptions} RedshiftOptions instance
         */
        RedshiftOptions.create = function create(properties) {
            return new RedshiftOptions(properties);
        };

        /**
         * Encodes the specified RedshiftOptions message. Does not implicitly {@link dataform.RedshiftOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions} message RedshiftOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedshiftOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distKey != null && message.hasOwnProperty("distKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.distKey);
            if (message.distStyle != null && message.hasOwnProperty("distStyle"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.distStyle);
            if (message.sortKeys != null && message.sortKeys.length)
                for (let i = 0; i < message.sortKeys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sortKeys[i]);
            if (message.sortStyle != null && message.hasOwnProperty("sortStyle"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sortStyle);
            if (message.bind != null && message.hasOwnProperty("bind"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.bind);
            return writer;
        };

        /**
         * Encodes the specified RedshiftOptions message, length delimited. Does not implicitly {@link dataform.RedshiftOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions} message RedshiftOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedshiftOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedshiftOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedshiftOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RedshiftOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.distKey = reader.string();
                    break;
                case 2:
                    message.distStyle = reader.string();
                    break;
                case 3:
                    if (!(message.sortKeys && message.sortKeys.length))
                        message.sortKeys = [];
                    message.sortKeys.push(reader.string());
                    break;
                case 4:
                    message.sortStyle = reader.string();
                    break;
                case 5:
                    message.bind = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedshiftOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedshiftOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedshiftOptions message.
         * @function verify
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedshiftOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distKey != null && message.hasOwnProperty("distKey"))
                if (!$util.isString(message.distKey))
                    return "distKey: string expected";
            if (message.distStyle != null && message.hasOwnProperty("distStyle"))
                if (!$util.isString(message.distStyle))
                    return "distStyle: string expected";
            if (message.sortKeys != null && message.hasOwnProperty("sortKeys")) {
                if (!Array.isArray(message.sortKeys))
                    return "sortKeys: array expected";
                for (let i = 0; i < message.sortKeys.length; ++i)
                    if (!$util.isString(message.sortKeys[i]))
                        return "sortKeys: string[] expected";
            }
            if (message.sortStyle != null && message.hasOwnProperty("sortStyle"))
                if (!$util.isString(message.sortStyle))
                    return "sortStyle: string expected";
            if (message.bind != null && message.hasOwnProperty("bind"))
                if (typeof message.bind !== "boolean")
                    return "bind: boolean expected";
            return null;
        };

        /**
         * Creates a RedshiftOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         */
        RedshiftOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RedshiftOptions)
                return object;
            let message = new $root.dataform.RedshiftOptions();
            if (object.distKey != null)
                message.distKey = String(object.distKey);
            if (object.distStyle != null)
                message.distStyle = String(object.distStyle);
            if (object.sortKeys) {
                if (!Array.isArray(object.sortKeys))
                    throw TypeError(".dataform.RedshiftOptions.sortKeys: array expected");
                message.sortKeys = [];
                for (let i = 0; i < object.sortKeys.length; ++i)
                    message.sortKeys[i] = String(object.sortKeys[i]);
            }
            if (object.sortStyle != null)
                message.sortStyle = String(object.sortStyle);
            if (object.bind != null)
                message.bind = Boolean(object.bind);
            return message;
        };

        /**
         * Creates a plain object from a RedshiftOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.RedshiftOptions} message RedshiftOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedshiftOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sortKeys = [];
            if (options.defaults) {
                object.distKey = "";
                object.distStyle = "";
                object.sortStyle = "";
                object.bind = false;
            }
            if (message.distKey != null && message.hasOwnProperty("distKey"))
                object.distKey = message.distKey;
            if (message.distStyle != null && message.hasOwnProperty("distStyle"))
                object.distStyle = message.distStyle;
            if (message.sortKeys && message.sortKeys.length) {
                object.sortKeys = [];
                for (let j = 0; j < message.sortKeys.length; ++j)
                    object.sortKeys[j] = message.sortKeys[j];
            }
            if (message.sortStyle != null && message.hasOwnProperty("sortStyle"))
                object.sortStyle = message.sortStyle;
            if (message.bind != null && message.hasOwnProperty("bind"))
                object.bind = message.bind;
            return object;
        };

        /**
         * Converts this RedshiftOptions to JSON.
         * @function toJSON
         * @memberof dataform.RedshiftOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedshiftOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedshiftOptions;
    })();

    dataform.SnowflakeOptions = (function() {

        /**
         * Properties of a SnowflakeOptions.
         * @memberof dataform
         * @interface ISnowflakeOptions
         * @property {boolean|null} [secure] SnowflakeOptions secure
         * @property {boolean|null} [transient] SnowflakeOptions transient
         * @property {Array.<string>|null} [clusterBy] SnowflakeOptions clusterBy
         */

        /**
         * Constructs a new SnowflakeOptions.
         * @memberof dataform
         * @classdesc Represents a SnowflakeOptions.
         * @implements ISnowflakeOptions
         * @constructor
         * @param {dataform.ISnowflakeOptions=} [properties] Properties to set
         */
        function SnowflakeOptions(properties) {
            this.clusterBy = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SnowflakeOptions secure.
         * @member {boolean} secure
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.secure = false;

        /**
         * SnowflakeOptions transient.
         * @member {boolean} transient
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.transient = false;

        /**
         * SnowflakeOptions clusterBy.
         * @member {Array.<string>} clusterBy
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.clusterBy = $util.emptyArray;

        /**
         * Creates a new SnowflakeOptions instance using the specified properties.
         * @function create
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions=} [properties] Properties to set
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions instance
         */
        SnowflakeOptions.create = function create(properties) {
            return new SnowflakeOptions(properties);
        };

        /**
         * Encodes the specified SnowflakeOptions message. Does not implicitly {@link dataform.SnowflakeOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions} message SnowflakeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnowflakeOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.secure != null && message.hasOwnProperty("secure"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.secure);
            if (message.transient != null && message.hasOwnProperty("transient"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.transient);
            if (message.clusterBy != null && message.clusterBy.length)
                for (let i = 0; i < message.clusterBy.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clusterBy[i]);
            return writer;
        };

        /**
         * Encodes the specified SnowflakeOptions message, length delimited. Does not implicitly {@link dataform.SnowflakeOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions} message SnowflakeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnowflakeOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SnowflakeOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnowflakeOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SnowflakeOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.secure = reader.bool();
                    break;
                case 2:
                    message.transient = reader.bool();
                    break;
                case 3:
                    if (!(message.clusterBy && message.clusterBy.length))
                        message.clusterBy = [];
                    message.clusterBy.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SnowflakeOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnowflakeOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SnowflakeOptions message.
         * @function verify
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SnowflakeOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.secure != null && message.hasOwnProperty("secure"))
                if (typeof message.secure !== "boolean")
                    return "secure: boolean expected";
            if (message.transient != null && message.hasOwnProperty("transient"))
                if (typeof message.transient !== "boolean")
                    return "transient: boolean expected";
            if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                if (!Array.isArray(message.clusterBy))
                    return "clusterBy: array expected";
                for (let i = 0; i < message.clusterBy.length; ++i)
                    if (!$util.isString(message.clusterBy[i]))
                        return "clusterBy: string[] expected";
            }
            return null;
        };

        /**
         * Creates a SnowflakeOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         */
        SnowflakeOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SnowflakeOptions)
                return object;
            let message = new $root.dataform.SnowflakeOptions();
            if (object.secure != null)
                message.secure = Boolean(object.secure);
            if (object.transient != null)
                message.transient = Boolean(object.transient);
            if (object.clusterBy) {
                if (!Array.isArray(object.clusterBy))
                    throw TypeError(".dataform.SnowflakeOptions.clusterBy: array expected");
                message.clusterBy = [];
                for (let i = 0; i < object.clusterBy.length; ++i)
                    message.clusterBy[i] = String(object.clusterBy[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a SnowflakeOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.SnowflakeOptions} message SnowflakeOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnowflakeOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.clusterBy = [];
            if (options.defaults) {
                object.secure = false;
                object.transient = false;
            }
            if (message.secure != null && message.hasOwnProperty("secure"))
                object.secure = message.secure;
            if (message.transient != null && message.hasOwnProperty("transient"))
                object.transient = message.transient;
            if (message.clusterBy && message.clusterBy.length) {
                object.clusterBy = [];
                for (let j = 0; j < message.clusterBy.length; ++j)
                    object.clusterBy[j] = message.clusterBy[j];
            }
            return object;
        };

        /**
         * Converts this SnowflakeOptions to JSON.
         * @function toJSON
         * @memberof dataform.SnowflakeOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SnowflakeOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SnowflakeOptions;
    })();

    dataform.SQLDataWarehouseOptions = (function() {

        /**
         * Properties of a SQLDataWarehouseOptions.
         * @memberof dataform
         * @interface ISQLDataWarehouseOptions
         * @property {string|null} [distribution] SQLDataWarehouseOptions distribution
         */

        /**
         * Constructs a new SQLDataWarehouseOptions.
         * @memberof dataform
         * @classdesc Represents a SQLDataWarehouseOptions.
         * @implements ISQLDataWarehouseOptions
         * @constructor
         * @param {dataform.ISQLDataWarehouseOptions=} [properties] Properties to set
         */
        function SQLDataWarehouseOptions(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SQLDataWarehouseOptions distribution.
         * @member {string} distribution
         * @memberof dataform.SQLDataWarehouseOptions
         * @instance
         */
        SQLDataWarehouseOptions.prototype.distribution = "";

        /**
         * Creates a new SQLDataWarehouseOptions instance using the specified properties.
         * @function create
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions=} [properties] Properties to set
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions instance
         */
        SQLDataWarehouseOptions.create = function create(properties) {
            return new SQLDataWarehouseOptions(properties);
        };

        /**
         * Encodes the specified SQLDataWarehouseOptions message. Does not implicitly {@link dataform.SQLDataWarehouseOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions} message SQLDataWarehouseOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouseOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distribution != null && message.hasOwnProperty("distribution"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.distribution);
            return writer;
        };

        /**
         * Encodes the specified SQLDataWarehouseOptions message, length delimited. Does not implicitly {@link dataform.SQLDataWarehouseOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions} message SQLDataWarehouseOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouseOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SQLDataWarehouseOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouseOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SQLDataWarehouseOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.distribution = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SQLDataWarehouseOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouseOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SQLDataWarehouseOptions message.
         * @function verify
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SQLDataWarehouseOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distribution != null && message.hasOwnProperty("distribution"))
                if (!$util.isString(message.distribution))
                    return "distribution: string expected";
            return null;
        };

        /**
         * Creates a SQLDataWarehouseOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         */
        SQLDataWarehouseOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SQLDataWarehouseOptions)
                return object;
            let message = new $root.dataform.SQLDataWarehouseOptions();
            if (object.distribution != null)
                message.distribution = String(object.distribution);
            return message;
        };

        /**
         * Creates a plain object from a SQLDataWarehouseOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.SQLDataWarehouseOptions} message SQLDataWarehouseOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SQLDataWarehouseOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.distribution = "";
            if (message.distribution != null && message.hasOwnProperty("distribution"))
                object.distribution = message.distribution;
            return object;
        };

        /**
         * Converts this SQLDataWarehouseOptions to JSON.
         * @function toJSON
         * @memberof dataform.SQLDataWarehouseOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SQLDataWarehouseOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SQLDataWarehouseOptions;
    })();

    dataform.PrestoOptions = (function() {

        /**
         * Properties of a PrestoOptions.
         * @memberof dataform
         * @interface IPrestoOptions
         * @property {Array.<string>|null} [partitionBy] PrestoOptions partitionBy
         */

        /**
         * Constructs a new PrestoOptions.
         * @memberof dataform
         * @classdesc Represents a PrestoOptions.
         * @implements IPrestoOptions
         * @constructor
         * @param {dataform.IPrestoOptions=} [properties] Properties to set
         */
        function PrestoOptions(properties) {
            this.partitionBy = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrestoOptions partitionBy.
         * @member {Array.<string>} partitionBy
         * @memberof dataform.PrestoOptions
         * @instance
         */
        PrestoOptions.prototype.partitionBy = $util.emptyArray;

        /**
         * Creates a new PrestoOptions instance using the specified properties.
         * @function create
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions=} [properties] Properties to set
         * @returns {dataform.PrestoOptions} PrestoOptions instance
         */
        PrestoOptions.create = function create(properties) {
            return new PrestoOptions(properties);
        };

        /**
         * Encodes the specified PrestoOptions message. Does not implicitly {@link dataform.PrestoOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions} message PrestoOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrestoOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partitionBy != null && message.partitionBy.length)
                for (let i = 0; i < message.partitionBy.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.partitionBy[i]);
            return writer;
        };

        /**
         * Encodes the specified PrestoOptions message, length delimited. Does not implicitly {@link dataform.PrestoOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions} message PrestoOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrestoOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrestoOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.PrestoOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.PrestoOptions} PrestoOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrestoOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.PrestoOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    if (!(message.partitionBy && message.partitionBy.length))
                        message.partitionBy = [];
                    message.partitionBy.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrestoOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.PrestoOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.PrestoOptions} PrestoOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrestoOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrestoOptions message.
         * @function verify
         * @memberof dataform.PrestoOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrestoOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy")) {
                if (!Array.isArray(message.partitionBy))
                    return "partitionBy: array expected";
                for (let i = 0; i < message.partitionBy.length; ++i)
                    if (!$util.isString(message.partitionBy[i]))
                        return "partitionBy: string[] expected";
            }
            return null;
        };

        /**
         * Creates a PrestoOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.PrestoOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.PrestoOptions} PrestoOptions
         */
        PrestoOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.PrestoOptions)
                return object;
            let message = new $root.dataform.PrestoOptions();
            if (object.partitionBy) {
                if (!Array.isArray(object.partitionBy))
                    throw TypeError(".dataform.PrestoOptions.partitionBy: array expected");
                message.partitionBy = [];
                for (let i = 0; i < object.partitionBy.length; ++i)
                    message.partitionBy[i] = String(object.partitionBy[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a PrestoOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.PrestoOptions} message PrestoOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrestoOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.partitionBy = [];
            if (message.partitionBy && message.partitionBy.length) {
                object.partitionBy = [];
                for (let j = 0; j < message.partitionBy.length; ++j)
                    object.partitionBy[j] = message.partitionBy[j];
            }
            return object;
        };

        /**
         * Converts this PrestoOptions to JSON.
         * @function toJSON
         * @memberof dataform.PrestoOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrestoOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrestoOptions;
    })();

    dataform.GraphErrors = (function() {

        /**
         * Properties of a GraphErrors.
         * @memberof dataform
         * @interface IGraphErrors
         * @property {Array.<dataform.ICompilationError>|null} [compilationErrors] GraphErrors compilationErrors
         * @property {Array.<dataform.IValidationError>|null} [validationErrors] GraphErrors validationErrors
         */

        /**
         * Constructs a new GraphErrors.
         * @memberof dataform
         * @classdesc Represents a GraphErrors.
         * @implements IGraphErrors
         * @constructor
         * @param {dataform.IGraphErrors=} [properties] Properties to set
         */
        function GraphErrors(properties) {
            this.compilationErrors = [];
            this.validationErrors = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphErrors compilationErrors.
         * @member {Array.<dataform.ICompilationError>} compilationErrors
         * @memberof dataform.GraphErrors
         * @instance
         */
        GraphErrors.prototype.compilationErrors = $util.emptyArray;

        /**
         * GraphErrors validationErrors.
         * @member {Array.<dataform.IValidationError>} validationErrors
         * @memberof dataform.GraphErrors
         * @instance
         */
        GraphErrors.prototype.validationErrors = $util.emptyArray;

        /**
         * Creates a new GraphErrors instance using the specified properties.
         * @function create
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors=} [properties] Properties to set
         * @returns {dataform.GraphErrors} GraphErrors instance
         */
        GraphErrors.create = function create(properties) {
            return new GraphErrors(properties);
        };

        /**
         * Encodes the specified GraphErrors message. Does not implicitly {@link dataform.GraphErrors.verify|verify} messages.
         * @function encode
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors} message GraphErrors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphErrors.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compilationErrors != null && message.compilationErrors.length)
                for (let i = 0; i < message.compilationErrors.length; ++i)
                    $root.dataform.CompilationError.encode(message.compilationErrors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.validationErrors != null && message.validationErrors.length)
                for (let i = 0; i < message.validationErrors.length; ++i)
                    $root.dataform.ValidationError.encode(message.validationErrors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphErrors message, length delimited. Does not implicitly {@link dataform.GraphErrors.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors} message GraphErrors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphErrors.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphErrors message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.GraphErrors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.GraphErrors} GraphErrors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphErrors.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.GraphErrors();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.compilationErrors && message.compilationErrors.length))
                        message.compilationErrors = [];
                    message.compilationErrors.push($root.dataform.CompilationError.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.validationErrors && message.validationErrors.length))
                        message.validationErrors = [];
                    message.validationErrors.push($root.dataform.ValidationError.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphErrors message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.GraphErrors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.GraphErrors} GraphErrors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphErrors.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphErrors message.
         * @function verify
         * @memberof dataform.GraphErrors
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphErrors.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compilationErrors != null && message.hasOwnProperty("compilationErrors")) {
                if (!Array.isArray(message.compilationErrors))
                    return "compilationErrors: array expected";
                for (let i = 0; i < message.compilationErrors.length; ++i) {
                    let error = $root.dataform.CompilationError.verify(message.compilationErrors[i]);
                    if (error)
                        return "compilationErrors." + error;
                }
            }
            if (message.validationErrors != null && message.hasOwnProperty("validationErrors")) {
                if (!Array.isArray(message.validationErrors))
                    return "validationErrors: array expected";
                for (let i = 0; i < message.validationErrors.length; ++i) {
                    let error = $root.dataform.ValidationError.verify(message.validationErrors[i]);
                    if (error)
                        return "validationErrors." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphErrors message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.GraphErrors
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.GraphErrors} GraphErrors
         */
        GraphErrors.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.GraphErrors)
                return object;
            let message = new $root.dataform.GraphErrors();
            if (object.compilationErrors) {
                if (!Array.isArray(object.compilationErrors))
                    throw TypeError(".dataform.GraphErrors.compilationErrors: array expected");
                message.compilationErrors = [];
                for (let i = 0; i < object.compilationErrors.length; ++i) {
                    if (typeof object.compilationErrors[i] !== "object")
                        throw TypeError(".dataform.GraphErrors.compilationErrors: object expected");
                    message.compilationErrors[i] = $root.dataform.CompilationError.fromObject(object.compilationErrors[i]);
                }
            }
            if (object.validationErrors) {
                if (!Array.isArray(object.validationErrors))
                    throw TypeError(".dataform.GraphErrors.validationErrors: array expected");
                message.validationErrors = [];
                for (let i = 0; i < object.validationErrors.length; ++i) {
                    if (typeof object.validationErrors[i] !== "object")
                        throw TypeError(".dataform.GraphErrors.validationErrors: object expected");
                    message.validationErrors[i] = $root.dataform.ValidationError.fromObject(object.validationErrors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphErrors message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.GraphErrors} message GraphErrors
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphErrors.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.compilationErrors = [];
                object.validationErrors = [];
            }
            if (message.compilationErrors && message.compilationErrors.length) {
                object.compilationErrors = [];
                for (let j = 0; j < message.compilationErrors.length; ++j)
                    object.compilationErrors[j] = $root.dataform.CompilationError.toObject(message.compilationErrors[j], options);
            }
            if (message.validationErrors && message.validationErrors.length) {
                object.validationErrors = [];
                for (let j = 0; j < message.validationErrors.length; ++j)
                    object.validationErrors[j] = $root.dataform.ValidationError.toObject(message.validationErrors[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphErrors to JSON.
         * @function toJSON
         * @memberof dataform.GraphErrors
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphErrors.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphErrors;
    })();

    dataform.ValidationError = (function() {

        /**
         * Properties of a ValidationError.
         * @memberof dataform
         * @interface IValidationError
         * @property {string|null} [actionName] ValidationError actionName
         * @property {string|null} [message] ValidationError message
         */

        /**
         * Constructs a new ValidationError.
         * @memberof dataform
         * @classdesc Represents a ValidationError.
         * @implements IValidationError
         * @constructor
         * @param {dataform.IValidationError=} [properties] Properties to set
         */
        function ValidationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidationError actionName.
         * @member {string} actionName
         * @memberof dataform.ValidationError
         * @instance
         */
        ValidationError.prototype.actionName = "";

        /**
         * ValidationError message.
         * @member {string} message
         * @memberof dataform.ValidationError
         * @instance
         */
        ValidationError.prototype.message = "";

        /**
         * Creates a new ValidationError instance using the specified properties.
         * @function create
         * @memberof dataform.ValidationError
         * @static
         * @param {dataform.IValidationError=} [properties] Properties to set
         * @returns {dataform.ValidationError} ValidationError instance
         */
        ValidationError.create = function create(properties) {
            return new ValidationError(properties);
        };

        /**
         * Encodes the specified ValidationError message. Does not implicitly {@link dataform.ValidationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.ValidationError
         * @static
         * @param {dataform.IValidationError} message ValidationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionName);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified ValidationError message, length delimited. Does not implicitly {@link dataform.ValidationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ValidationError
         * @static
         * @param {dataform.IValidationError} message ValidationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ValidationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ValidationError} ValidationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ValidationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actionName = reader.string();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ValidationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ValidationError} ValidationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidationError message.
         * @function verify
         * @memberof dataform.ValidationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                if (!$util.isString(message.actionName))
                    return "actionName: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a ValidationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ValidationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ValidationError} ValidationError
         */
        ValidationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ValidationError)
                return object;
            let message = new $root.dataform.ValidationError();
            if (object.actionName != null)
                message.actionName = String(object.actionName);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a ValidationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ValidationError
         * @static
         * @param {dataform.ValidationError} message ValidationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.actionName = "";
                object.message = "";
            }
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                object.actionName = message.actionName;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this ValidationError to JSON.
         * @function toJSON
         * @memberof dataform.ValidationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidationError;
    })();

    dataform.CompilationError = (function() {

        /**
         * Properties of a CompilationError.
         * @memberof dataform
         * @interface ICompilationError
         * @property {string|null} [fileName] CompilationError fileName
         * @property {string|null} [actionName] CompilationError actionName
         * @property {string|null} [message] CompilationError message
         * @property {string|null} [stack] CompilationError stack
         */

        /**
         * Constructs a new CompilationError.
         * @memberof dataform
         * @classdesc Represents a CompilationError.
         * @implements ICompilationError
         * @constructor
         * @param {dataform.ICompilationError=} [properties] Properties to set
         */
        function CompilationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompilationError fileName.
         * @member {string} fileName
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.fileName = "";

        /**
         * CompilationError actionName.
         * @member {string} actionName
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.actionName = "";

        /**
         * CompilationError message.
         * @member {string} message
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.message = "";

        /**
         * CompilationError stack.
         * @member {string} stack
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.stack = "";

        /**
         * Creates a new CompilationError instance using the specified properties.
         * @function create
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError=} [properties] Properties to set
         * @returns {dataform.CompilationError} CompilationError instance
         */
        CompilationError.create = function create(properties) {
            return new CompilationError(properties);
        };

        /**
         * Encodes the specified CompilationError message. Does not implicitly {@link dataform.CompilationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError} message CompilationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompilationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.stack != null && message.hasOwnProperty("stack"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stack);
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.actionName);
            return writer;
        };

        /**
         * Encodes the specified CompilationError message, length delimited. Does not implicitly {@link dataform.CompilationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError} message CompilationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompilationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompilationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompilationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompilationError} CompilationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompilationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompilationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fileName = reader.string();
                    break;
                case 4:
                    message.actionName = reader.string();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.stack = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompilationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompilationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompilationError} CompilationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompilationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompilationError message.
         * @function verify
         * @memberof dataform.CompilationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompilationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                if (!$util.isString(message.actionName))
                    return "actionName: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.stack != null && message.hasOwnProperty("stack"))
                if (!$util.isString(message.stack))
                    return "stack: string expected";
            return null;
        };

        /**
         * Creates a CompilationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompilationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompilationError} CompilationError
         */
        CompilationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompilationError)
                return object;
            let message = new $root.dataform.CompilationError();
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.actionName != null)
                message.actionName = String(object.actionName);
            if (object.message != null)
                message.message = String(object.message);
            if (object.stack != null)
                message.stack = String(object.stack);
            return message;
        };

        /**
         * Creates a plain object from a CompilationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.CompilationError} message CompilationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompilationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.fileName = "";
                object.message = "";
                object.stack = "";
                object.actionName = "";
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.stack != null && message.hasOwnProperty("stack"))
                object.stack = message.stack;
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                object.actionName = message.actionName;
            return object;
        };

        /**
         * Converts this CompilationError to JSON.
         * @function toJSON
         * @memberof dataform.CompilationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompilationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CompilationError;
    })();

    dataform.QueryEvaluationError = (function() {

        /**
         * Properties of a QueryEvaluationError.
         * @memberof dataform
         * @interface IQueryEvaluationError
         * @property {string|null} [message] QueryEvaluationError message
         * @property {dataform.QueryEvaluationError.IErrorLocation|null} [errorLocation] QueryEvaluationError errorLocation
         */

        /**
         * Constructs a new QueryEvaluationError.
         * @memberof dataform
         * @classdesc Represents a QueryEvaluationError.
         * @implements IQueryEvaluationError
         * @constructor
         * @param {dataform.IQueryEvaluationError=} [properties] Properties to set
         */
        function QueryEvaluationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryEvaluationError message.
         * @member {string} message
         * @memberof dataform.QueryEvaluationError
         * @instance
         */
        QueryEvaluationError.prototype.message = "";

        /**
         * QueryEvaluationError errorLocation.
         * @member {dataform.QueryEvaluationError.IErrorLocation|null|undefined} errorLocation
         * @memberof dataform.QueryEvaluationError
         * @instance
         */
        QueryEvaluationError.prototype.errorLocation = null;

        /**
         * Creates a new QueryEvaluationError instance using the specified properties.
         * @function create
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError=} [properties] Properties to set
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError instance
         */
        QueryEvaluationError.create = function create(properties) {
            return new QueryEvaluationError(properties);
        };

        /**
         * Encodes the specified QueryEvaluationError message. Does not implicitly {@link dataform.QueryEvaluationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError} message QueryEvaluationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation"))
                $root.dataform.QueryEvaluationError.ErrorLocation.encode(message.errorLocation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryEvaluationError message, length delimited. Does not implicitly {@link dataform.QueryEvaluationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError} message QueryEvaluationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryEvaluationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                case 2:
                    message.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryEvaluationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryEvaluationError message.
         * @function verify
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryEvaluationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation")) {
                let error = $root.dataform.QueryEvaluationError.ErrorLocation.verify(message.errorLocation);
                if (error)
                    return "errorLocation." + error;
            }
            return null;
        };

        /**
         * Creates a QueryEvaluationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         */
        QueryEvaluationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.QueryEvaluationError)
                return object;
            let message = new $root.dataform.QueryEvaluationError();
            if (object.message != null)
                message.message = String(object.message);
            if (object.errorLocation != null) {
                if (typeof object.errorLocation !== "object")
                    throw TypeError(".dataform.QueryEvaluationError.errorLocation: object expected");
                message.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.fromObject(object.errorLocation);
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryEvaluationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.QueryEvaluationError} message QueryEvaluationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryEvaluationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.message = "";
                object.errorLocation = null;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation"))
                object.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.toObject(message.errorLocation, options);
            return object;
        };

        /**
         * Converts this QueryEvaluationError to JSON.
         * @function toJSON
         * @memberof dataform.QueryEvaluationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryEvaluationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        QueryEvaluationError.ErrorLocation = (function() {

            /**
             * Properties of an ErrorLocation.
             * @memberof dataform.QueryEvaluationError
             * @interface IErrorLocation
             * @property {number|null} [line] ErrorLocation line
             * @property {number|null} [column] ErrorLocation column
             */

            /**
             * Constructs a new ErrorLocation.
             * @memberof dataform.QueryEvaluationError
             * @classdesc Represents an ErrorLocation.
             * @implements IErrorLocation
             * @constructor
             * @param {dataform.QueryEvaluationError.IErrorLocation=} [properties] Properties to set
             */
            function ErrorLocation(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorLocation line.
             * @member {number} line
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             */
            ErrorLocation.prototype.line = 0;

            /**
             * ErrorLocation column.
             * @member {number} column
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             */
            ErrorLocation.prototype.column = 0;

            /**
             * Creates a new ErrorLocation instance using the specified properties.
             * @function create
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation=} [properties] Properties to set
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation instance
             */
            ErrorLocation.create = function create(properties) {
                return new ErrorLocation(properties);
            };

            /**
             * Encodes the specified ErrorLocation message. Does not implicitly {@link dataform.QueryEvaluationError.ErrorLocation.verify|verify} messages.
             * @function encode
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation} message ErrorLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorLocation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.line != null && message.hasOwnProperty("line"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.line);
                if (message.column != null && message.hasOwnProperty("column"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.column);
                return writer;
            };

            /**
             * Encodes the specified ErrorLocation message, length delimited. Does not implicitly {@link dataform.QueryEvaluationError.ErrorLocation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation} message ErrorLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorLocation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorLocation message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorLocation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluationError.ErrorLocation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.line = reader.int32();
                        break;
                    case 2:
                        message.column = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorLocation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorLocation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorLocation message.
             * @function verify
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorLocation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line))
                        return "line: integer expected";
                if (message.column != null && message.hasOwnProperty("column"))
                    if (!$util.isInteger(message.column))
                        return "column: integer expected";
                return null;
            };

            /**
             * Creates an ErrorLocation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             */
            ErrorLocation.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.QueryEvaluationError.ErrorLocation)
                    return object;
                let message = new $root.dataform.QueryEvaluationError.ErrorLocation();
                if (object.line != null)
                    message.line = object.line | 0;
                if (object.column != null)
                    message.column = object.column | 0;
                return message;
            };

            /**
             * Creates a plain object from an ErrorLocation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.ErrorLocation} message ErrorLocation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorLocation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.line = 0;
                    object.column = 0;
                }
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                if (message.column != null && message.hasOwnProperty("column"))
                    object.column = message.column;
                return object;
            };

            /**
             * Converts this ErrorLocation to JSON.
             * @function toJSON
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorLocation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ErrorLocation;
        })();

        return QueryEvaluationError;
    })();

    dataform.QueryEvaluation = (function() {

        /**
         * Properties of a QueryEvaluation.
         * @memberof dataform
         * @interface IQueryEvaluation
         * @property {dataform.QueryEvaluation.QueryEvaluationStatus|null} [status] QueryEvaluation status
         * @property {dataform.IQueryEvaluationError|null} [error] QueryEvaluation error
         * @property {boolean|null} [incremental] QueryEvaluation incremental
         * @property {string|null} [query] QueryEvaluation query
         */

        /**
         * Constructs a new QueryEvaluation.
         * @memberof dataform
         * @classdesc Represents a QueryEvaluation.
         * @implements IQueryEvaluation
         * @constructor
         * @param {dataform.IQueryEvaluation=} [properties] Properties to set
         */
        function QueryEvaluation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryEvaluation status.
         * @member {dataform.QueryEvaluation.QueryEvaluationStatus} status
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.status = 0;

        /**
         * QueryEvaluation error.
         * @member {dataform.IQueryEvaluationError|null|undefined} error
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.error = null;

        /**
         * QueryEvaluation incremental.
         * @member {boolean} incremental
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.incremental = false;

        /**
         * QueryEvaluation query.
         * @member {string} query
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.query = "";

        /**
         * Creates a new QueryEvaluation instance using the specified properties.
         * @function create
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation=} [properties] Properties to set
         * @returns {dataform.QueryEvaluation} QueryEvaluation instance
         */
        QueryEvaluation.create = function create(properties) {
            return new QueryEvaluation(properties);
        };

        /**
         * Encodes the specified QueryEvaluation message. Does not implicitly {@link dataform.QueryEvaluation.verify|verify} messages.
         * @function encode
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation} message QueryEvaluation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.error != null && message.hasOwnProperty("error"))
                $root.dataform.QueryEvaluationError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.incremental);
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.query);
            return writer;
        };

        /**
         * Encodes the specified QueryEvaluation message, length delimited. Does not implicitly {@link dataform.QueryEvaluation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation} message QueryEvaluation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryEvaluation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.error = $root.dataform.QueryEvaluationError.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.incremental = reader.bool();
                    break;
                case 4:
                    message.query = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryEvaluation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryEvaluation message.
         * @function verify
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryEvaluation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.error != null && message.hasOwnProperty("error")) {
                let error = $root.dataform.QueryEvaluationError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                if (typeof message.incremental !== "boolean")
                    return "incremental: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            return null;
        };

        /**
         * Creates a QueryEvaluation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         */
        QueryEvaluation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.QueryEvaluation)
                return object;
            let message = new $root.dataform.QueryEvaluation();
            switch (object.status) {
            case "SUCCESS":
            case 0:
                message.status = 0;
                break;
            case "FAILURE":
            case 1:
                message.status = 1;
                break;
            }
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".dataform.QueryEvaluation.error: object expected");
                message.error = $root.dataform.QueryEvaluationError.fromObject(object.error);
            }
            if (object.incremental != null)
                message.incremental = Boolean(object.incremental);
            if (object.query != null)
                message.query = String(object.query);
            return message;
        };

        /**
         * Creates a plain object from a QueryEvaluation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.QueryEvaluation} message QueryEvaluation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryEvaluation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "SUCCESS" : 0;
                object.error = null;
                object.incremental = false;
                object.query = "";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.QueryEvaluation.QueryEvaluationStatus[message.status] : message.status;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.dataform.QueryEvaluationError.toObject(message.error, options);
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                object.incremental = message.incremental;
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            return object;
        };

        /**
         * Converts this QueryEvaluation to JSON.
         * @function toJSON
         * @memberof dataform.QueryEvaluation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryEvaluation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * QueryEvaluationStatus enum.
         * @name dataform.QueryEvaluation.QueryEvaluationStatus
         * @enum {string}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} FAILURE=1 FAILURE value
         */
        QueryEvaluation.QueryEvaluationStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "FAILURE"] = 1;
            return values;
        })();

        return QueryEvaluation;
    })();

    dataform.ValidationQuery = (function() {

        /**
         * Properties of a ValidationQuery.
         * @memberof dataform
         * @interface IValidationQuery
         * @property {string|null} [query] ValidationQuery query
         * @property {boolean|null} [incremental] ValidationQuery incremental
         */

        /**
         * Constructs a new ValidationQuery.
         * @memberof dataform
         * @classdesc Represents a ValidationQuery.
         * @implements IValidationQuery
         * @constructor
         * @param {dataform.IValidationQuery=} [properties] Properties to set
         */
        function ValidationQuery(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidationQuery query.
         * @member {string} query
         * @memberof dataform.ValidationQuery
         * @instance
         */
        ValidationQuery.prototype.query = "";

        /**
         * ValidationQuery incremental.
         * @member {boolean} incremental
         * @memberof dataform.ValidationQuery
         * @instance
         */
        ValidationQuery.prototype.incremental = false;

        /**
         * Creates a new ValidationQuery instance using the specified properties.
         * @function create
         * @memberof dataform.ValidationQuery
         * @static
         * @param {dataform.IValidationQuery=} [properties] Properties to set
         * @returns {dataform.ValidationQuery} ValidationQuery instance
         */
        ValidationQuery.create = function create(properties) {
            return new ValidationQuery(properties);
        };

        /**
         * Encodes the specified ValidationQuery message. Does not implicitly {@link dataform.ValidationQuery.verify|verify} messages.
         * @function encode
         * @memberof dataform.ValidationQuery
         * @static
         * @param {dataform.IValidationQuery} message ValidationQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.incremental);
            return writer;
        };

        /**
         * Encodes the specified ValidationQuery message, length delimited. Does not implicitly {@link dataform.ValidationQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ValidationQuery
         * @static
         * @param {dataform.IValidationQuery} message ValidationQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidationQuery message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ValidationQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ValidationQuery} ValidationQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ValidationQuery();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.query = reader.string();
                    break;
                case 2:
                    message.incremental = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidationQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ValidationQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ValidationQuery} ValidationQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidationQuery message.
         * @function verify
         * @memberof dataform.ValidationQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidationQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                if (typeof message.incremental !== "boolean")
                    return "incremental: boolean expected";
            return null;
        };

        /**
         * Creates a ValidationQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ValidationQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ValidationQuery} ValidationQuery
         */
        ValidationQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ValidationQuery)
                return object;
            let message = new $root.dataform.ValidationQuery();
            if (object.query != null)
                message.query = String(object.query);
            if (object.incremental != null)
                message.incremental = Boolean(object.incremental);
            return message;
        };

        /**
         * Creates a plain object from a ValidationQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ValidationQuery
         * @static
         * @param {dataform.ValidationQuery} message ValidationQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidationQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.query = "";
                object.incremental = false;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                object.incremental = message.incremental;
            return object;
        };

        /**
         * Converts this ValidationQuery to JSON.
         * @function toJSON
         * @memberof dataform.ValidationQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidationQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidationQuery;
    })();

    dataform.ActionDescriptor = (function() {

        /**
         * Properties of an ActionDescriptor.
         * @memberof dataform
         * @interface IActionDescriptor
         * @property {string|null} [description] ActionDescriptor description
         * @property {Array.<dataform.IColumnDescriptor>|null} [columns] ActionDescriptor columns
         * @property {Object.<string,string>|null} [bigqueryLabels] ActionDescriptor bigqueryLabels
         */

        /**
         * Constructs a new ActionDescriptor.
         * @memberof dataform
         * @classdesc Represents an ActionDescriptor.
         * @implements IActionDescriptor
         * @constructor
         * @param {dataform.IActionDescriptor=} [properties] Properties to set
         */
        function ActionDescriptor(properties) {
            this.columns = [];
            this.bigqueryLabels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionDescriptor description.
         * @member {string} description
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.description = "";

        /**
         * ActionDescriptor columns.
         * @member {Array.<dataform.IColumnDescriptor>} columns
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.columns = $util.emptyArray;

        /**
         * ActionDescriptor bigqueryLabels.
         * @member {Object.<string,string>} bigqueryLabels
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.bigqueryLabels = $util.emptyObject;

        /**
         * Creates a new ActionDescriptor instance using the specified properties.
         * @function create
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor=} [properties] Properties to set
         * @returns {dataform.ActionDescriptor} ActionDescriptor instance
         */
        ActionDescriptor.create = function create(properties) {
            return new ActionDescriptor(properties);
        };

        /**
         * Encodes the specified ActionDescriptor message. Does not implicitly {@link dataform.ActionDescriptor.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor} message ActionDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.columns != null && message.columns.length)
                for (let i = 0; i < message.columns.length; ++i)
                    $root.dataform.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.bigqueryLabels != null && message.hasOwnProperty("bigqueryLabels"))
                for (let keys = Object.keys(message.bigqueryLabels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.bigqueryLabels[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionDescriptor message, length delimited. Does not implicitly {@link dataform.ActionDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor} message ActionDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionDescriptor(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push($root.dataform.ColumnDescriptor.decode(reader, reader.uint32()));
                    break;
                case 3:
                    reader.skip().pos++;
                    if (message.bigqueryLabels === $util.emptyObject)
                        message.bigqueryLabels = {};
                    key = reader.string();
                    reader.pos++;
                    message.bigqueryLabels[key] = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionDescriptor message.
         * @function verify
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (let i = 0; i < message.columns.length; ++i) {
                    let error = $root.dataform.ColumnDescriptor.verify(message.columns[i]);
                    if (error)
                        return "columns." + error;
                }
            }
            if (message.bigqueryLabels != null && message.hasOwnProperty("bigqueryLabels")) {
                if (!$util.isObject(message.bigqueryLabels))
                    return "bigqueryLabels: object expected";
                let key = Object.keys(message.bigqueryLabels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.bigqueryLabels[key[i]]))
                        return "bigqueryLabels: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates an ActionDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         */
        ActionDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionDescriptor)
                return object;
            let message = new $root.dataform.ActionDescriptor();
            if (object.description != null)
                message.description = String(object.description);
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".dataform.ActionDescriptor.columns: array expected");
                message.columns = [];
                for (let i = 0; i < object.columns.length; ++i) {
                    if (typeof object.columns[i] !== "object")
                        throw TypeError(".dataform.ActionDescriptor.columns: object expected");
                    message.columns[i] = $root.dataform.ColumnDescriptor.fromObject(object.columns[i]);
                }
            }
            if (object.bigqueryLabels) {
                if (typeof object.bigqueryLabels !== "object")
                    throw TypeError(".dataform.ActionDescriptor.bigqueryLabels: object expected");
                message.bigqueryLabels = {};
                for (let keys = Object.keys(object.bigqueryLabels), i = 0; i < keys.length; ++i)
                    message.bigqueryLabels[keys[i]] = String(object.bigqueryLabels[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.ActionDescriptor} message ActionDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.columns = [];
            if (options.objects || options.defaults)
                object.bigqueryLabels = {};
            if (options.defaults)
                object.description = "";
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (let j = 0; j < message.columns.length; ++j)
                    object.columns[j] = $root.dataform.ColumnDescriptor.toObject(message.columns[j], options);
            }
            let keys2;
            if (message.bigqueryLabels && (keys2 = Object.keys(message.bigqueryLabels)).length) {
                object.bigqueryLabels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.bigqueryLabels[keys2[j]] = message.bigqueryLabels[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this ActionDescriptor to JSON.
         * @function toJSON
         * @memberof dataform.ActionDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActionDescriptor;
    })();

    dataform.ColumnDescriptor = (function() {

        /**
         * Properties of a ColumnDescriptor.
         * @memberof dataform
         * @interface IColumnDescriptor
         * @property {string|null} [description] ColumnDescriptor description
         * @property {Array.<string>|null} [path] ColumnDescriptor path
         * @property {string|null} [displayName] ColumnDescriptor displayName
         * @property {dataform.ColumnDescriptor.DimensionType|null} [dimensionType] ColumnDescriptor dimensionType
         * @property {dataform.ColumnDescriptor.Aggregation|null} [aggregation] ColumnDescriptor aggregation
         * @property {string|null} [expression] ColumnDescriptor expression
         * @property {Array.<string>|null} [tags] ColumnDescriptor tags
         * @property {Array.<string>|null} [bigqueryPolicyTags] ColumnDescriptor bigqueryPolicyTags
         */

        /**
         * Constructs a new ColumnDescriptor.
         * @memberof dataform
         * @classdesc Represents a ColumnDescriptor.
         * @implements IColumnDescriptor
         * @constructor
         * @param {dataform.IColumnDescriptor=} [properties] Properties to set
         */
        function ColumnDescriptor(properties) {
            this.path = [];
            this.tags = [];
            this.bigqueryPolicyTags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColumnDescriptor description.
         * @member {string} description
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.description = "";

        /**
         * ColumnDescriptor path.
         * @member {Array.<string>} path
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.path = $util.emptyArray;

        /**
         * ColumnDescriptor displayName.
         * @member {string} displayName
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.displayName = "";

        /**
         * ColumnDescriptor dimensionType.
         * @member {dataform.ColumnDescriptor.DimensionType} dimensionType
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.dimensionType = 0;

        /**
         * ColumnDescriptor aggregation.
         * @member {dataform.ColumnDescriptor.Aggregation} aggregation
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.aggregation = 0;

        /**
         * ColumnDescriptor expression.
         * @member {string} expression
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.expression = "";

        /**
         * ColumnDescriptor tags.
         * @member {Array.<string>} tags
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.tags = $util.emptyArray;

        /**
         * ColumnDescriptor bigqueryPolicyTags.
         * @member {Array.<string>} bigqueryPolicyTags
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.bigqueryPolicyTags = $util.emptyArray;

        /**
         * Creates a new ColumnDescriptor instance using the specified properties.
         * @function create
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor=} [properties] Properties to set
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor instance
         */
        ColumnDescriptor.create = function create(properties) {
            return new ColumnDescriptor(properties);
        };

        /**
         * Encodes the specified ColumnDescriptor message. Does not implicitly {@link dataform.ColumnDescriptor.verify|verify} messages.
         * @function encode
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.path != null && message.path.length)
                for (let i = 0; i < message.path.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path[i]);
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.displayName);
            if (message.dimensionType != null && message.hasOwnProperty("dimensionType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.dimensionType);
            if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.aggregation);
            if (message.expression != null && message.hasOwnProperty("expression"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.expression);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.tags[i]);
            if (message.bigqueryPolicyTags != null && message.bigqueryPolicyTags.length)
                for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.bigqueryPolicyTags[i]);
            return writer;
        };

        /**
         * Encodes the specified ColumnDescriptor message, length delimited. Does not implicitly {@link dataform.ColumnDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColumnDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ColumnDescriptor();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    if (!(message.path && message.path.length))
                        message.path = [];
                    message.path.push(reader.string());
                    break;
                case 3:
                    message.displayName = reader.string();
                    break;
                case 4:
                    message.dimensionType = reader.int32();
                    break;
                case 5:
                    message.aggregation = reader.int32();
                    break;
                case 6:
                    message.expression = reader.string();
                    break;
                case 7:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 8:
                    if (!(message.bigqueryPolicyTags && message.bigqueryPolicyTags.length))
                        message.bigqueryPolicyTags = [];
                    message.bigqueryPolicyTags.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColumnDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColumnDescriptor message.
         * @function verify
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColumnDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (let i = 0; i < message.path.length; ++i)
                    if (!$util.isString(message.path[i]))
                        return "path: string[] expected";
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                if (!$util.isString(message.displayName))
                    return "displayName: string expected";
            if (message.dimensionType != null && message.hasOwnProperty("dimensionType"))
                switch (message.dimensionType) {
                default:
                    return "dimensionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                switch (message.aggregation) {
                default:
                    return "aggregation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.expression != null && message.hasOwnProperty("expression"))
                if (!$util.isString(message.expression))
                    return "expression: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.bigqueryPolicyTags != null && message.hasOwnProperty("bigqueryPolicyTags")) {
                if (!Array.isArray(message.bigqueryPolicyTags))
                    return "bigqueryPolicyTags: array expected";
                for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                    if (!$util.isString(message.bigqueryPolicyTags[i]))
                        return "bigqueryPolicyTags: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ColumnDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         */
        ColumnDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ColumnDescriptor)
                return object;
            let message = new $root.dataform.ColumnDescriptor();
            if (object.description != null)
                message.description = String(object.description);
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".dataform.ColumnDescriptor.path: array expected");
                message.path = [];
                for (let i = 0; i < object.path.length; ++i)
                    message.path[i] = String(object.path[i]);
            }
            if (object.displayName != null)
                message.displayName = String(object.displayName);
            switch (object.dimensionType) {
            case "UNKNOWN_DIMENSION":
            case 0:
                message.dimensionType = 0;
                break;
            case "CATEGORY":
            case 1:
                message.dimensionType = 1;
                break;
            case "TIMESTAMP":
            case 2:
                message.dimensionType = 2;
                break;
            case "NUMBER":
            case 3:
                message.dimensionType = 3;
                break;
            }
            switch (object.aggregation) {
            case "UNKNOWN_AGGREGATION":
            case 0:
                message.aggregation = 0;
                break;
            case "SUM":
            case 1:
                message.aggregation = 1;
                break;
            case "DISTINCT":
            case 2:
                message.aggregation = 2;
                break;
            case "DERIVED":
            case 3:
                message.aggregation = 3;
                break;
            }
            if (object.expression != null)
                message.expression = String(object.expression);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.ColumnDescriptor.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.bigqueryPolicyTags) {
                if (!Array.isArray(object.bigqueryPolicyTags))
                    throw TypeError(".dataform.ColumnDescriptor.bigqueryPolicyTags: array expected");
                message.bigqueryPolicyTags = [];
                for (let i = 0; i < object.bigqueryPolicyTags.length; ++i)
                    message.bigqueryPolicyTags[i] = String(object.bigqueryPolicyTags[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ColumnDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.ColumnDescriptor} message ColumnDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColumnDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.path = [];
                object.tags = [];
                object.bigqueryPolicyTags = [];
            }
            if (options.defaults) {
                object.description = "";
                object.displayName = "";
                object.dimensionType = options.enums === String ? "UNKNOWN_DIMENSION" : 0;
                object.aggregation = options.enums === String ? "UNKNOWN_AGGREGATION" : 0;
                object.expression = "";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.path && message.path.length) {
                object.path = [];
                for (let j = 0; j < message.path.length; ++j)
                    object.path[j] = message.path[j];
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                object.displayName = message.displayName;
            if (message.dimensionType != null && message.hasOwnProperty("dimensionType"))
                object.dimensionType = options.enums === String ? $root.dataform.ColumnDescriptor.DimensionType[message.dimensionType] : message.dimensionType;
            if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                object.aggregation = options.enums === String ? $root.dataform.ColumnDescriptor.Aggregation[message.aggregation] : message.aggregation;
            if (message.expression != null && message.hasOwnProperty("expression"))
                object.expression = message.expression;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.bigqueryPolicyTags && message.bigqueryPolicyTags.length) {
                object.bigqueryPolicyTags = [];
                for (let j = 0; j < message.bigqueryPolicyTags.length; ++j)
                    object.bigqueryPolicyTags[j] = message.bigqueryPolicyTags[j];
            }
            return object;
        };

        /**
         * Converts this ColumnDescriptor to JSON.
         * @function toJSON
         * @memberof dataform.ColumnDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColumnDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * DimensionType enum.
         * @name dataform.ColumnDescriptor.DimensionType
         * @enum {string}
         * @property {number} UNKNOWN_DIMENSION=0 UNKNOWN_DIMENSION value
         * @property {number} CATEGORY=1 CATEGORY value
         * @property {number} TIMESTAMP=2 TIMESTAMP value
         * @property {number} NUMBER=3 NUMBER value
         */
        ColumnDescriptor.DimensionType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_DIMENSION"] = 0;
            values[valuesById[1] = "CATEGORY"] = 1;
            values[valuesById[2] = "TIMESTAMP"] = 2;
            values[valuesById[3] = "NUMBER"] = 3;
            return values;
        })();

        /**
         * Aggregation enum.
         * @name dataform.ColumnDescriptor.Aggregation
         * @enum {string}
         * @property {number} UNKNOWN_AGGREGATION=0 UNKNOWN_AGGREGATION value
         * @property {number} SUM=1 SUM value
         * @property {number} DISTINCT=2 DISTINCT value
         * @property {number} DERIVED=3 DERIVED value
         */
        ColumnDescriptor.Aggregation = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_AGGREGATION"] = 0;
            values[valuesById[1] = "SUM"] = 1;
            values[valuesById[2] = "DISTINCT"] = 2;
            values[valuesById[3] = "DERIVED"] = 3;
            return values;
        })();

        return ColumnDescriptor;
    })();

    dataform.Table = (function() {

        /**
         * Properties of a Table.
         * @memberof dataform
         * @interface ITable
         * @property {dataform.ITarget|null} [target] Table target
         * @property {dataform.ITarget|null} [canonicalTarget] Table canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Table dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Table hermeticity
         * @property {boolean|null} [disabled] Table disabled
         * @property {string|null} [type] Table type
         * @property {string|null} [query] Table query
         * @property {boolean|null} ["protected"] Table protected
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Table actionDescriptor
         * @property {Array.<string>|null} [tags] Table tags
         * @property {string|null} [where] Table where
         * @property {string|null} [incrementalQuery] Table incrementalQuery
         * @property {Array.<string>|null} [uniqueKey] Table uniqueKey
         * @property {Array.<string>|null} [preOps] Table preOps
         * @property {Array.<string>|null} [postOps] Table postOps
         * @property {Array.<string>|null} [incrementalPreOps] Table incrementalPreOps
         * @property {Array.<string>|null} [incrementalPostOps] Table incrementalPostOps
         * @property {dataform.IRedshiftOptions|null} [redshift] Table redshift
         * @property {dataform.IBigQueryOptions|null} [bigquery] Table bigquery
         * @property {dataform.ISnowflakeOptions|null} [snowflake] Table snowflake
         * @property {dataform.ISQLDataWarehouseOptions|null} [sqlDataWarehouse] Table sqlDataWarehouse
         * @property {dataform.IPrestoOptions|null} [presto] Table presto
         * @property {string|null} [fileName] Table fileName
         * @property {Array.<string>|null} [deprecatedParsedColumns] Table deprecatedParsedColumns
         * @property {Array.<dataform.IValidationError>|null} [deprecatedValidationErrors] Table deprecatedValidationErrors
         * @property {string|null} [name] Table name
         * @property {Array.<string>|null} [dependencies] Table dependencies
         */

        /**
         * Constructs a new Table.
         * @memberof dataform
         * @classdesc Represents a Table.
         * @implements ITable
         * @constructor
         * @param {dataform.ITable=} [properties] Properties to set
         */
        function Table(properties) {
            this.dependencyTargets = [];
            this.tags = [];
            this.uniqueKey = [];
            this.preOps = [];
            this.postOps = [];
            this.incrementalPreOps = [];
            this.incrementalPostOps = [];
            this.deprecatedParsedColumns = [];
            this.deprecatedValidationErrors = [];
            this.dependencies = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Table target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.target = null;

        /**
         * Table canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.canonicalTarget = null;

        /**
         * Table dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Table hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.hermeticity = 0;

        /**
         * Table disabled.
         * @member {boolean} disabled
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.disabled = false;

        /**
         * Table type.
         * @member {string} type
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.type = "";

        /**
         * Table query.
         * @member {string} query
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.query = "";

        /**
         * Table protected.
         * @member {boolean} protected
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype["protected"] = false;

        /**
         * Table actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.actionDescriptor = null;

        /**
         * Table tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.tags = $util.emptyArray;

        /**
         * Table where.
         * @member {string} where
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.where = "";

        /**
         * Table incrementalQuery.
         * @member {string} incrementalQuery
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalQuery = "";

        /**
         * Table uniqueKey.
         * @member {Array.<string>} uniqueKey
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.uniqueKey = $util.emptyArray;

        /**
         * Table preOps.
         * @member {Array.<string>} preOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.preOps = $util.emptyArray;

        /**
         * Table postOps.
         * @member {Array.<string>} postOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.postOps = $util.emptyArray;

        /**
         * Table incrementalPreOps.
         * @member {Array.<string>} incrementalPreOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalPreOps = $util.emptyArray;

        /**
         * Table incrementalPostOps.
         * @member {Array.<string>} incrementalPostOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalPostOps = $util.emptyArray;

        /**
         * Table redshift.
         * @member {dataform.IRedshiftOptions|null|undefined} redshift
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.redshift = null;

        /**
         * Table bigquery.
         * @member {dataform.IBigQueryOptions|null|undefined} bigquery
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.bigquery = null;

        /**
         * Table snowflake.
         * @member {dataform.ISnowflakeOptions|null|undefined} snowflake
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.snowflake = null;

        /**
         * Table sqlDataWarehouse.
         * @member {dataform.ISQLDataWarehouseOptions|null|undefined} sqlDataWarehouse
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.sqlDataWarehouse = null;

        /**
         * Table presto.
         * @member {dataform.IPrestoOptions|null|undefined} presto
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.presto = null;

        /**
         * Table fileName.
         * @member {string} fileName
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.fileName = "";

        /**
         * Table deprecatedParsedColumns.
         * @member {Array.<string>} deprecatedParsedColumns
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.deprecatedParsedColumns = $util.emptyArray;

        /**
         * Table deprecatedValidationErrors.
         * @member {Array.<dataform.IValidationError>} deprecatedValidationErrors
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.deprecatedValidationErrors = $util.emptyArray;

        /**
         * Table name.
         * @member {string} name
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.name = "";

        /**
         * Table dependencies.
         * @member {Array.<string>} dependencies
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.dependencies = $util.emptyArray;

        /**
         * Creates a new Table instance using the specified properties.
         * @function create
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable=} [properties] Properties to set
         * @returns {dataform.Table} Table instance
         */
        Table.create = function create(properties) {
            return new Table(properties);
        };

        /**
         * Encodes the specified Table message. Does not implicitly {@link dataform.Table.verify|verify} messages.
         * @function encode
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.dependencies != null && message.dependencies.length)
                for (let i = 0; i < message.dependencies.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dependencies[i]);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.query);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disabled);
            if (message.deprecatedValidationErrors != null && message.deprecatedValidationErrors.length)
                for (let i = 0; i < message.deprecatedValidationErrors.length; ++i)
                    $root.dataform.ValidationError.encode(message.deprecatedValidationErrors[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.where != null && message.hasOwnProperty("where"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.where);
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message["protected"]);
            if (message.deprecatedParsedColumns != null && message.deprecatedParsedColumns.length)
                for (let i = 0; i < message.deprecatedParsedColumns.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.deprecatedParsedColumns[i]);
            if (message.preOps != null && message.preOps.length)
                for (let i = 0; i < message.preOps.length; ++i)
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.preOps[i]);
            if (message.postOps != null && message.postOps.length)
                for (let i = 0; i < message.postOps.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.postOps[i]);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.fileName);
            if (message.redshift != null && message.hasOwnProperty("redshift"))
                $root.dataform.RedshiftOptions.encode(message.redshift, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                $root.dataform.BigQueryOptions.encode(message.bigquery, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 23, wireType 2 =*/186).string(message.tags[i]);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.sqlDataWarehouse != null && message.hasOwnProperty("sqlDataWarehouse"))
                $root.dataform.SQLDataWarehouseOptions.encode(message.sqlDataWarehouse, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.incrementalQuery);
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.incrementalPreOps != null && message.incrementalPreOps.length)
                for (let i = 0; i < message.incrementalPreOps.length; ++i)
                    writer.uint32(/* id 28, wireType 2 =*/226).string(message.incrementalPreOps[i]);
            if (message.incrementalPostOps != null && message.incrementalPostOps.length)
                for (let i = 0; i < message.incrementalPostOps.length; ++i)
                    writer.uint32(/* id 29, wireType 2 =*/234).string(message.incrementalPostOps[i]);
            if (message.uniqueKey != null && message.uniqueKey.length)
                for (let i = 0; i < message.uniqueKey.length; ++i)
                    writer.uint32(/* id 30, wireType 2 =*/242).string(message.uniqueKey[i]);
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.hermeticity);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.snowflake != null && message.hasOwnProperty("snowflake"))
                $root.dataform.SnowflakeOptions.encode(message.snowflake, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.presto != null && message.hasOwnProperty("presto"))
                $root.dataform.PrestoOptions.encode(message.presto, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Table message, length delimited. Does not implicitly {@link dataform.Table.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Table message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Table();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 27:
                    if (!(message.dependencyTargets && message.dependencyTargets.length))
                        message.dependencyTargets = [];
                    message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 31:
                    message.hermeticity = reader.int32();
                    break;
                case 6:
                    message.disabled = reader.bool();
                    break;
                case 3:
                    message.type = reader.string();
                    break;
                case 5:
                    message.query = reader.string();
                    break;
                case 9:
                    message["protected"] = reader.bool();
                    break;
                case 24:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                case 23:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 8:
                    message.where = reader.string();
                    break;
                case 26:
                    message.incrementalQuery = reader.string();
                    break;
                case 30:
                    if (!(message.uniqueKey && message.uniqueKey.length))
                        message.uniqueKey = [];
                    message.uniqueKey.push(reader.string());
                    break;
                case 13:
                    if (!(message.preOps && message.preOps.length))
                        message.preOps = [];
                    message.preOps.push(reader.string());
                    break;
                case 14:
                    if (!(message.postOps && message.postOps.length))
                        message.postOps = [];
                    message.postOps.push(reader.string());
                    break;
                case 28:
                    if (!(message.incrementalPreOps && message.incrementalPreOps.length))
                        message.incrementalPreOps = [];
                    message.incrementalPreOps.push(reader.string());
                    break;
                case 29:
                    if (!(message.incrementalPostOps && message.incrementalPostOps.length))
                        message.incrementalPostOps = [];
                    message.incrementalPostOps.push(reader.string());
                    break;
                case 21:
                    message.redshift = $root.dataform.RedshiftOptions.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.bigquery = $root.dataform.BigQueryOptions.decode(reader, reader.uint32());
                    break;
                case 33:
                    message.snowflake = $root.dataform.SnowflakeOptions.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.decode(reader, reader.uint32());
                    break;
                case 34:
                    message.presto = $root.dataform.PrestoOptions.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.fileName = reader.string();
                    break;
                case 12:
                    if (!(message.deprecatedParsedColumns && message.deprecatedParsedColumns.length))
                        message.deprecatedParsedColumns = [];
                    message.deprecatedParsedColumns.push(reader.string());
                    break;
                case 7:
                    if (!(message.deprecatedValidationErrors && message.deprecatedValidationErrors.length))
                        message.deprecatedValidationErrors = [];
                    message.deprecatedValidationErrors.push($root.dataform.ValidationError.decode(reader, reader.uint32()));
                    break;
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.dependencies && message.dependencies.length))
                        message.dependencies = [];
                    message.dependencies.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Table message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Table message.
         * @function verify
         * @memberof dataform.Table
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Table.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                if (typeof message["protected"] !== "boolean")
                    return "protected: boolean expected";
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.where != null && message.hasOwnProperty("where"))
                if (!$util.isString(message.where))
                    return "where: string expected";
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                if (!$util.isString(message.incrementalQuery))
                    return "incrementalQuery: string expected";
            if (message.uniqueKey != null && message.hasOwnProperty("uniqueKey")) {
                if (!Array.isArray(message.uniqueKey))
                    return "uniqueKey: array expected";
                for (let i = 0; i < message.uniqueKey.length; ++i)
                    if (!$util.isString(message.uniqueKey[i]))
                        return "uniqueKey: string[] expected";
            }
            if (message.preOps != null && message.hasOwnProperty("preOps")) {
                if (!Array.isArray(message.preOps))
                    return "preOps: array expected";
                for (let i = 0; i < message.preOps.length; ++i)
                    if (!$util.isString(message.preOps[i]))
                        return "preOps: string[] expected";
            }
            if (message.postOps != null && message.hasOwnProperty("postOps")) {
                if (!Array.isArray(message.postOps))
                    return "postOps: array expected";
                for (let i = 0; i < message.postOps.length; ++i)
                    if (!$util.isString(message.postOps[i]))
                        return "postOps: string[] expected";
            }
            if (message.incrementalPreOps != null && message.hasOwnProperty("incrementalPreOps")) {
                if (!Array.isArray(message.incrementalPreOps))
                    return "incrementalPreOps: array expected";
                for (let i = 0; i < message.incrementalPreOps.length; ++i)
                    if (!$util.isString(message.incrementalPreOps[i]))
                        return "incrementalPreOps: string[] expected";
            }
            if (message.incrementalPostOps != null && message.hasOwnProperty("incrementalPostOps")) {
                if (!Array.isArray(message.incrementalPostOps))
                    return "incrementalPostOps: array expected";
                for (let i = 0; i < message.incrementalPostOps.length; ++i)
                    if (!$util.isString(message.incrementalPostOps[i]))
                        return "incrementalPostOps: string[] expected";
            }
            if (message.redshift != null && message.hasOwnProperty("redshift")) {
                let error = $root.dataform.RedshiftOptions.verify(message.redshift);
                if (error)
                    return "redshift." + error;
            }
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.BigQueryOptions.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            if (message.snowflake != null && message.hasOwnProperty("snowflake")) {
                let error = $root.dataform.SnowflakeOptions.verify(message.snowflake);
                if (error)
                    return "snowflake." + error;
            }
            if (message.sqlDataWarehouse != null && message.hasOwnProperty("sqlDataWarehouse")) {
                let error = $root.dataform.SQLDataWarehouseOptions.verify(message.sqlDataWarehouse);
                if (error)
                    return "sqlDataWarehouse." + error;
            }
            if (message.presto != null && message.hasOwnProperty("presto")) {
                let error = $root.dataform.PrestoOptions.verify(message.presto);
                if (error)
                    return "presto." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.deprecatedParsedColumns != null && message.hasOwnProperty("deprecatedParsedColumns")) {
                if (!Array.isArray(message.deprecatedParsedColumns))
                    return "deprecatedParsedColumns: array expected";
                for (let i = 0; i < message.deprecatedParsedColumns.length; ++i)
                    if (!$util.isString(message.deprecatedParsedColumns[i]))
                        return "deprecatedParsedColumns: string[] expected";
            }
            if (message.deprecatedValidationErrors != null && message.hasOwnProperty("deprecatedValidationErrors")) {
                if (!Array.isArray(message.deprecatedValidationErrors))
                    return "deprecatedValidationErrors: array expected";
                for (let i = 0; i < message.deprecatedValidationErrors.length; ++i) {
                    let error = $root.dataform.ValidationError.verify(message.deprecatedValidationErrors[i]);
                    if (error)
                        return "deprecatedValidationErrors." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                if (!Array.isArray(message.dependencies))
                    return "dependencies: array expected";
                for (let i = 0; i < message.dependencies.length; ++i)
                    if (!$util.isString(message.dependencies[i]))
                        return "dependencies: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Table message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Table
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Table} Table
         */
        Table.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Table)
                return object;
            let message = new $root.dataform.Table();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Table.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Table.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Table.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Table.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.type != null)
                message.type = String(object.type);
            if (object.query != null)
                message.query = String(object.query);
            if (object["protected"] != null)
                message["protected"] = Boolean(object["protected"]);
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Table.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Table.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.where != null)
                message.where = String(object.where);
            if (object.incrementalQuery != null)
                message.incrementalQuery = String(object.incrementalQuery);
            if (object.uniqueKey) {
                if (!Array.isArray(object.uniqueKey))
                    throw TypeError(".dataform.Table.uniqueKey: array expected");
                message.uniqueKey = [];
                for (let i = 0; i < object.uniqueKey.length; ++i)
                    message.uniqueKey[i] = String(object.uniqueKey[i]);
            }
            if (object.preOps) {
                if (!Array.isArray(object.preOps))
                    throw TypeError(".dataform.Table.preOps: array expected");
                message.preOps = [];
                for (let i = 0; i < object.preOps.length; ++i)
                    message.preOps[i] = String(object.preOps[i]);
            }
            if (object.postOps) {
                if (!Array.isArray(object.postOps))
                    throw TypeError(".dataform.Table.postOps: array expected");
                message.postOps = [];
                for (let i = 0; i < object.postOps.length; ++i)
                    message.postOps[i] = String(object.postOps[i]);
            }
            if (object.incrementalPreOps) {
                if (!Array.isArray(object.incrementalPreOps))
                    throw TypeError(".dataform.Table.incrementalPreOps: array expected");
                message.incrementalPreOps = [];
                for (let i = 0; i < object.incrementalPreOps.length; ++i)
                    message.incrementalPreOps[i] = String(object.incrementalPreOps[i]);
            }
            if (object.incrementalPostOps) {
                if (!Array.isArray(object.incrementalPostOps))
                    throw TypeError(".dataform.Table.incrementalPostOps: array expected");
                message.incrementalPostOps = [];
                for (let i = 0; i < object.incrementalPostOps.length; ++i)
                    message.incrementalPostOps[i] = String(object.incrementalPostOps[i]);
            }
            if (object.redshift != null) {
                if (typeof object.redshift !== "object")
                    throw TypeError(".dataform.Table.redshift: object expected");
                message.redshift = $root.dataform.RedshiftOptions.fromObject(object.redshift);
            }
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.Table.bigquery: object expected");
                message.bigquery = $root.dataform.BigQueryOptions.fromObject(object.bigquery);
            }
            if (object.snowflake != null) {
                if (typeof object.snowflake !== "object")
                    throw TypeError(".dataform.Table.snowflake: object expected");
                message.snowflake = $root.dataform.SnowflakeOptions.fromObject(object.snowflake);
            }
            if (object.sqlDataWarehouse != null) {
                if (typeof object.sqlDataWarehouse !== "object")
                    throw TypeError(".dataform.Table.sqlDataWarehouse: object expected");
                message.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.fromObject(object.sqlDataWarehouse);
            }
            if (object.presto != null) {
                if (typeof object.presto !== "object")
                    throw TypeError(".dataform.Table.presto: object expected");
                message.presto = $root.dataform.PrestoOptions.fromObject(object.presto);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.deprecatedParsedColumns) {
                if (!Array.isArray(object.deprecatedParsedColumns))
                    throw TypeError(".dataform.Table.deprecatedParsedColumns: array expected");
                message.deprecatedParsedColumns = [];
                for (let i = 0; i < object.deprecatedParsedColumns.length; ++i)
                    message.deprecatedParsedColumns[i] = String(object.deprecatedParsedColumns[i]);
            }
            if (object.deprecatedValidationErrors) {
                if (!Array.isArray(object.deprecatedValidationErrors))
                    throw TypeError(".dataform.Table.deprecatedValidationErrors: array expected");
                message.deprecatedValidationErrors = [];
                for (let i = 0; i < object.deprecatedValidationErrors.length; ++i) {
                    if (typeof object.deprecatedValidationErrors[i] !== "object")
                        throw TypeError(".dataform.Table.deprecatedValidationErrors: object expected");
                    message.deprecatedValidationErrors[i] = $root.dataform.ValidationError.fromObject(object.deprecatedValidationErrors[i]);
                }
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.dependencies) {
                if (!Array.isArray(object.dependencies))
                    throw TypeError(".dataform.Table.dependencies: array expected");
                message.dependencies = [];
                for (let i = 0; i < object.dependencies.length; ++i)
                    message.dependencies[i] = String(object.dependencies[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Table message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Table
         * @static
         * @param {dataform.Table} message Table
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Table.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.dependencies = [];
                object.deprecatedValidationErrors = [];
                object.deprecatedParsedColumns = [];
                object.preOps = [];
                object.postOps = [];
                object.tags = [];
                object.dependencyTargets = [];
                object.incrementalPreOps = [];
                object.incrementalPostOps = [];
                object.uniqueKey = [];
            }
            if (options.defaults) {
                object.name = "";
                object.type = "";
                object.target = null;
                object.query = "";
                object.disabled = false;
                object.where = "";
                object["protected"] = false;
                object.fileName = "";
                object.redshift = null;
                object.bigquery = null;
                object.actionDescriptor = null;
                object.sqlDataWarehouse = null;
                object.incrementalQuery = "";
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.snowflake = null;
                object.presto = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.dependencies && message.dependencies.length) {
                object.dependencies = [];
                for (let j = 0; j < message.dependencies.length; ++j)
                    object.dependencies[j] = message.dependencies[j];
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.deprecatedValidationErrors && message.deprecatedValidationErrors.length) {
                object.deprecatedValidationErrors = [];
                for (let j = 0; j < message.deprecatedValidationErrors.length; ++j)
                    object.deprecatedValidationErrors[j] = $root.dataform.ValidationError.toObject(message.deprecatedValidationErrors[j], options);
            }
            if (message.where != null && message.hasOwnProperty("where"))
                object.where = message.where;
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                object["protected"] = message["protected"];
            if (message.deprecatedParsedColumns && message.deprecatedParsedColumns.length) {
                object.deprecatedParsedColumns = [];
                for (let j = 0; j < message.deprecatedParsedColumns.length; ++j)
                    object.deprecatedParsedColumns[j] = message.deprecatedParsedColumns[j];
            }
            if (message.preOps && message.preOps.length) {
                object.preOps = [];
                for (let j = 0; j < message.preOps.length; ++j)
                    object.preOps[j] = message.preOps[j];
            }
            if (message.postOps && message.postOps.length) {
                object.postOps = [];
                for (let j = 0; j < message.postOps.length; ++j)
                    object.postOps[j] = message.postOps[j];
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.redshift != null && message.hasOwnProperty("redshift"))
                object.redshift = $root.dataform.RedshiftOptions.toObject(message.redshift, options);
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.BigQueryOptions.toObject(message.bigquery, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.sqlDataWarehouse != null && message.hasOwnProperty("sqlDataWarehouse"))
                object.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.toObject(message.sqlDataWarehouse, options);
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                object.incrementalQuery = message.incrementalQuery;
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.incrementalPreOps && message.incrementalPreOps.length) {
                object.incrementalPreOps = [];
                for (let j = 0; j < message.incrementalPreOps.length; ++j)
                    object.incrementalPreOps[j] = message.incrementalPreOps[j];
            }
            if (message.incrementalPostOps && message.incrementalPostOps.length) {
                object.incrementalPostOps = [];
                for (let j = 0; j < message.incrementalPostOps.length; ++j)
                    object.incrementalPostOps[j] = message.incrementalPostOps[j];
            }
            if (message.uniqueKey && message.uniqueKey.length) {
                object.uniqueKey = [];
                for (let j = 0; j < message.uniqueKey.length; ++j)
                    object.uniqueKey[j] = message.uniqueKey[j];
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.snowflake != null && message.hasOwnProperty("snowflake"))
                object.snowflake = $root.dataform.SnowflakeOptions.toObject(message.snowflake, options);
            if (message.presto != null && message.hasOwnProperty("presto"))
                object.presto = $root.dataform.PrestoOptions.toObject(message.presto, options);
            return object;
        };

        /**
         * Converts this Table to JSON.
         * @function toJSON
         * @memberof dataform.Table
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Table.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Table;
    })();

    dataform.Operation = (function() {

        /**
         * Properties of an Operation.
         * @memberof dataform
         * @interface IOperation
         * @property {dataform.ITarget|null} [target] Operation target
         * @property {dataform.ITarget|null} [canonicalTarget] Operation canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Operation dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Operation hermeticity
         * @property {boolean|null} [disabled] Operation disabled
         * @property {Array.<string>|null} [queries] Operation queries
         * @property {boolean|null} [hasOutput] Operation hasOutput
         * @property {Array.<string>|null} [tags] Operation tags
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Operation actionDescriptor
         * @property {string|null} [fileName] Operation fileName
         * @property {string|null} [name] Operation name
         * @property {Array.<string>|null} [dependencies] Operation dependencies
         */

        /**
         * Constructs a new Operation.
         * @memberof dataform
         * @classdesc Represents an Operation.
         * @implements IOperation
         * @constructor
         * @param {dataform.IOperation=} [properties] Properties to set
         */
        function Operation(properties) {
            this.dependencyTargets = [];
            this.queries = [];
            this.tags = [];
            this.dependencies = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Operation target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.target = null;

        /**
         * Operation canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.canonicalTarget = null;

        /**
         * Operation dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Operation hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.hermeticity = 0;

        /**
         * Operation disabled.
         * @member {boolean} disabled
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.disabled = false;

        /**
         * Operation queries.
         * @member {Array.<string>} queries
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.queries = $util.emptyArray;

        /**
         * Operation hasOutput.
         * @member {boolean} hasOutput
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.hasOutput = false;

        /**
         * Operation tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.tags = $util.emptyArray;

        /**
         * Operation actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.actionDescriptor = null;

        /**
         * Operation fileName.
         * @member {string} fileName
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.fileName = "";

        /**
         * Operation name.
         * @member {string} name
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.name = "";

        /**
         * Operation dependencies.
         * @member {Array.<string>} dependencies
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.dependencies = $util.emptyArray;

        /**
         * Creates a new Operation instance using the specified properties.
         * @function create
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation=} [properties] Properties to set
         * @returns {dataform.Operation} Operation instance
         */
        Operation.create = function create(properties) {
            return new Operation(properties);
        };

        /**
         * Encodes the specified Operation message. Does not implicitly {@link dataform.Operation.verify|verify} messages.
         * @function encode
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation} message Operation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Operation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.dependencies != null && message.dependencies.length)
                for (let i = 0; i < message.dependencies.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dependencies[i]);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.queries != null && message.queries.length)
                for (let i = 0; i < message.queries.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.queries[i]);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasOutput);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags[i]);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.hermeticity);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.disabled);
            return writer;
        };

        /**
         * Encodes the specified Operation message, length delimited. Does not implicitly {@link dataform.Operation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation} message Operation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Operation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Operation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Operation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Operation} Operation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Operation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Operation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.dependencyTargets && message.dependencyTargets.length))
                        message.dependencyTargets = [];
                    message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.hermeticity = reader.int32();
                    break;
                case 14:
                    message.disabled = reader.bool();
                    break;
                case 6:
                    if (!(message.queries && message.queries.length))
                        message.queries = [];
                    message.queries.push(reader.string());
                    break;
                case 8:
                    message.hasOutput = reader.bool();
                    break;
                case 9:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 10:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.fileName = reader.string();
                    break;
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.dependencies && message.dependencies.length))
                        message.dependencies = [];
                    message.dependencies.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Operation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Operation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Operation} Operation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Operation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Operation message.
         * @function verify
         * @memberof dataform.Operation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Operation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.queries != null && message.hasOwnProperty("queries")) {
                if (!Array.isArray(message.queries))
                    return "queries: array expected";
                for (let i = 0; i < message.queries.length; ++i)
                    if (!$util.isString(message.queries[i]))
                        return "queries: string[] expected";
            }
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                if (typeof message.hasOutput !== "boolean")
                    return "hasOutput: boolean expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                if (!Array.isArray(message.dependencies))
                    return "dependencies: array expected";
                for (let i = 0; i < message.dependencies.length; ++i)
                    if (!$util.isString(message.dependencies[i]))
                        return "dependencies: string[] expected";
            }
            return null;
        };

        /**
         * Creates an Operation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Operation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Operation} Operation
         */
        Operation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Operation)
                return object;
            let message = new $root.dataform.Operation();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Operation.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Operation.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Operation.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Operation.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.queries) {
                if (!Array.isArray(object.queries))
                    throw TypeError(".dataform.Operation.queries: array expected");
                message.queries = [];
                for (let i = 0; i < object.queries.length; ++i)
                    message.queries[i] = String(object.queries[i]);
            }
            if (object.hasOutput != null)
                message.hasOutput = Boolean(object.hasOutput);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Operation.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Operation.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.name != null)
                message.name = String(object.name);
            if (object.dependencies) {
                if (!Array.isArray(object.dependencies))
                    throw TypeError(".dataform.Operation.dependencies: array expected");
                message.dependencies = [];
                for (let i = 0; i < object.dependencies.length; ++i)
                    message.dependencies[i] = String(object.dependencies[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an Operation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Operation
         * @static
         * @param {dataform.Operation} message Operation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Operation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.dependencies = [];
                object.queries = [];
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.name = "";
                object.target = null;
                object.fileName = "";
                object.hasOutput = false;
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.disabled = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.dependencies && message.dependencies.length) {
                object.dependencies = [];
                for (let j = 0; j < message.dependencies.length; ++j)
                    object.dependencies[j] = message.dependencies[j];
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.queries && message.queries.length) {
                object.queries = [];
                for (let j = 0; j < message.queries.length; ++j)
                    object.queries[j] = message.queries[j];
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                object.hasOutput = message.hasOutput;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            return object;
        };

        /**
         * Converts this Operation to JSON.
         * @function toJSON
         * @memberof dataform.Operation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Operation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Operation;
    })();

    dataform.Assertion = (function() {

        /**
         * Properties of an Assertion.
         * @memberof dataform
         * @interface IAssertion
         * @property {dataform.ITarget|null} [target] Assertion target
         * @property {dataform.ITarget|null} [canonicalTarget] Assertion canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Assertion dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Assertion hermeticity
         * @property {boolean|null} [disabled] Assertion disabled
         * @property {string|null} [query] Assertion query
         * @property {Array.<string>|null} [tags] Assertion tags
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Assertion actionDescriptor
         * @property {dataform.ITarget|null} [parentAction] Assertion parentAction
         * @property {string|null} [fileName] Assertion fileName
         * @property {string|null} [name] Assertion name
         * @property {Array.<string>|null} [dependencies] Assertion dependencies
         */

        /**
         * Constructs a new Assertion.
         * @memberof dataform
         * @classdesc Represents an Assertion.
         * @implements IAssertion
         * @constructor
         * @param {dataform.IAssertion=} [properties] Properties to set
         */
        function Assertion(properties) {
            this.dependencyTargets = [];
            this.tags = [];
            this.dependencies = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Assertion target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.target = null;

        /**
         * Assertion canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.canonicalTarget = null;

        /**
         * Assertion dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Assertion hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.hermeticity = 0;

        /**
         * Assertion disabled.
         * @member {boolean} disabled
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.disabled = false;

        /**
         * Assertion query.
         * @member {string} query
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.query = "";

        /**
         * Assertion tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.tags = $util.emptyArray;

        /**
         * Assertion actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.actionDescriptor = null;

        /**
         * Assertion parentAction.
         * @member {dataform.ITarget|null|undefined} parentAction
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.parentAction = null;

        /**
         * Assertion fileName.
         * @member {string} fileName
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.fileName = "";

        /**
         * Assertion name.
         * @member {string} name
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.name = "";

        /**
         * Assertion dependencies.
         * @member {Array.<string>} dependencies
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.dependencies = $util.emptyArray;

        /**
         * Creates a new Assertion instance using the specified properties.
         * @function create
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion=} [properties] Properties to set
         * @returns {dataform.Assertion} Assertion instance
         */
        Assertion.create = function create(properties) {
            return new Assertion(properties);
        };

        /**
         * Encodes the specified Assertion message. Does not implicitly {@link dataform.Assertion.verify|verify} messages.
         * @function encode
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion} message Assertion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Assertion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.dependencies != null && message.dependencies.length)
                for (let i = 0; i < message.dependencies.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dependencies[i]);
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.query);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags[i]);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.hermeticity);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.disabled);
            if (message.parentAction != null && message.hasOwnProperty("parentAction"))
                $root.dataform.Target.encode(message.parentAction, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Assertion message, length delimited. Does not implicitly {@link dataform.Assertion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion} message Assertion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Assertion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Assertion message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Assertion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Assertion} Assertion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Assertion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Assertion();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 8:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.dependencyTargets && message.dependencyTargets.length))
                        message.dependencyTargets = [];
                    message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.hermeticity = reader.int32();
                    break;
                case 14:
                    message.disabled = reader.bool();
                    break;
                case 3:
                    message.query = reader.string();
                    break;
                case 9:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 10:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.parentAction = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.fileName = reader.string();
                    break;
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.dependencies && message.dependencies.length))
                        message.dependencies = [];
                    message.dependencies.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Assertion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Assertion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Assertion} Assertion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Assertion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Assertion message.
         * @function verify
         * @memberof dataform.Assertion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Assertion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.parentAction != null && message.hasOwnProperty("parentAction")) {
                let error = $root.dataform.Target.verify(message.parentAction);
                if (error)
                    return "parentAction." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                if (!Array.isArray(message.dependencies))
                    return "dependencies: array expected";
                for (let i = 0; i < message.dependencies.length; ++i)
                    if (!$util.isString(message.dependencies[i]))
                        return "dependencies: string[] expected";
            }
            return null;
        };

        /**
         * Creates an Assertion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Assertion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Assertion} Assertion
         */
        Assertion.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Assertion)
                return object;
            let message = new $root.dataform.Assertion();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Assertion.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Assertion.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Assertion.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Assertion.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.query != null)
                message.query = String(object.query);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Assertion.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Assertion.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.parentAction != null) {
                if (typeof object.parentAction !== "object")
                    throw TypeError(".dataform.Assertion.parentAction: object expected");
                message.parentAction = $root.dataform.Target.fromObject(object.parentAction);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.name != null)
                message.name = String(object.name);
            if (object.dependencies) {
                if (!Array.isArray(object.dependencies))
                    throw TypeError(".dataform.Assertion.dependencies: array expected");
                message.dependencies = [];
                for (let i = 0; i < object.dependencies.length; ++i)
                    message.dependencies[i] = String(object.dependencies[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an Assertion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.Assertion} message Assertion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Assertion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.dependencies = [];
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.name = "";
                object.query = "";
                object.fileName = "";
                object.target = null;
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.disabled = false;
                object.parentAction = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.dependencies && message.dependencies.length) {
                object.dependencies = [];
                for (let j = 0; j < message.dependencies.length; ++j)
                    object.dependencies[j] = message.dependencies[j];
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.parentAction != null && message.hasOwnProperty("parentAction"))
                object.parentAction = $root.dataform.Target.toObject(message.parentAction, options);
            return object;
        };

        /**
         * Converts this Assertion to JSON.
         * @function toJSON
         * @memberof dataform.Assertion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Assertion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Assertion;
    })();

    /**
     * ActionHermeticity enum.
     * @name dataform.ActionHermeticity
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} HERMETIC=1 HERMETIC value
     * @property {number} NON_HERMETIC=2 NON_HERMETIC value
     */
    dataform.ActionHermeticity = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "HERMETIC"] = 1;
        values[valuesById[2] = "NON_HERMETIC"] = 2;
        return values;
    })();

    dataform.Declaration = (function() {

        /**
         * Properties of a Declaration.
         * @memberof dataform
         * @interface IDeclaration
         * @property {string|null} [name] Declaration name
         * @property {dataform.ITarget|null} [target] Declaration target
         * @property {dataform.ITarget|null} [canonicalTarget] Declaration canonicalTarget
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Declaration actionDescriptor
         * @property {string|null} [fileName] Declaration fileName
         */

        /**
         * Constructs a new Declaration.
         * @memberof dataform
         * @classdesc Represents a Declaration.
         * @implements IDeclaration
         * @constructor
         * @param {dataform.IDeclaration=} [properties] Properties to set
         */
        function Declaration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Declaration name.
         * @member {string} name
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.name = "";

        /**
         * Declaration target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.target = null;

        /**
         * Declaration canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.canonicalTarget = null;

        /**
         * Declaration actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.actionDescriptor = null;

        /**
         * Declaration fileName.
         * @member {string} fileName
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.fileName = "";

        /**
         * Creates a new Declaration instance using the specified properties.
         * @function create
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration=} [properties] Properties to set
         * @returns {dataform.Declaration} Declaration instance
         */
        Declaration.create = function create(properties) {
            return new Declaration(properties);
        };

        /**
         * Encodes the specified Declaration message. Does not implicitly {@link dataform.Declaration.verify|verify} messages.
         * @function encode
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration} message Declaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Declaration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Declaration message, length delimited. Does not implicitly {@link dataform.Declaration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration} message Declaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Declaration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Declaration message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Declaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Declaration} Declaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Declaration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Declaration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.fileName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Declaration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Declaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Declaration} Declaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Declaration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Declaration message.
         * @function verify
         * @memberof dataform.Declaration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Declaration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Declaration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Declaration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Declaration} Declaration
         */
        Declaration.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Declaration)
                return object;
            let message = new $root.dataform.Declaration();
            if (object.name != null)
                message.name = String(object.name);
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Declaration.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Declaration.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Declaration.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Declaration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.Declaration} message Declaration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Declaration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.target = null;
                object.actionDescriptor = null;
                object.fileName = "";
                object.canonicalTarget = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            return object;
        };

        /**
         * Converts this Declaration to JSON.
         * @function toJSON
         * @memberof dataform.Declaration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Declaration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Declaration;
    })();

    dataform.Test = (function() {

        /**
         * Properties of a Test.
         * @memberof dataform
         * @interface ITest
         * @property {string|null} [name] Test name
         * @property {string|null} [testQuery] Test testQuery
         * @property {string|null} [expectedOutputQuery] Test expectedOutputQuery
         * @property {string|null} [fileName] Test fileName
         */

        /**
         * Constructs a new Test.
         * @memberof dataform
         * @classdesc Represents a Test.
         * @implements ITest
         * @constructor
         * @param {dataform.ITest=} [properties] Properties to set
         */
        function Test(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Test name.
         * @member {string} name
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.name = "";

        /**
         * Test testQuery.
         * @member {string} testQuery
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.testQuery = "";

        /**
         * Test expectedOutputQuery.
         * @member {string} expectedOutputQuery
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.expectedOutputQuery = "";

        /**
         * Test fileName.
         * @member {string} fileName
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.fileName = "";

        /**
         * Creates a new Test instance using the specified properties.
         * @function create
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest=} [properties] Properties to set
         * @returns {dataform.Test} Test instance
         */
        Test.create = function create(properties) {
            return new Test(properties);
        };

        /**
         * Encodes the specified Test message. Does not implicitly {@link dataform.Test.verify|verify} messages.
         * @function encode
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest} message Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testQuery);
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.expectedOutputQuery);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            return writer;
        };

        /**
         * Encodes the specified Test message, length delimited. Does not implicitly {@link dataform.Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest} message Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Test message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Test();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.testQuery = reader.string();
                    break;
                case 3:
                    message.expectedOutputQuery = reader.string();
                    break;
                case 4:
                    message.fileName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Test message.
         * @function verify
         * @memberof dataform.Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                if (!$util.isString(message.testQuery))
                    return "testQuery: string expected";
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                if (!$util.isString(message.expectedOutputQuery))
                    return "expectedOutputQuery: string expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Test} Test
         */
        Test.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Test)
                return object;
            let message = new $root.dataform.Test();
            if (object.name != null)
                message.name = String(object.name);
            if (object.testQuery != null)
                message.testQuery = String(object.testQuery);
            if (object.expectedOutputQuery != null)
                message.expectedOutputQuery = String(object.expectedOutputQuery);
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Test
         * @static
         * @param {dataform.Test} message Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.testQuery = "";
                object.expectedOutputQuery = "";
                object.fileName = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                object.testQuery = message.testQuery;
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                object.expectedOutputQuery = message.expectedOutputQuery;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            return object;
        };

        /**
         * Converts this Test to JSON.
         * @function toJSON
         * @memberof dataform.Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Test;
    })();

    dataform.CompiledGraph = (function() {

        /**
         * Properties of a CompiledGraph.
         * @memberof dataform
         * @interface ICompiledGraph
         * @property {dataform.IProjectConfig|null} [projectConfig] CompiledGraph projectConfig
         * @property {Array.<dataform.ITable>|null} [tables] CompiledGraph tables
         * @property {Array.<dataform.IOperation>|null} [operations] CompiledGraph operations
         * @property {Array.<dataform.IAssertion>|null} [assertions] CompiledGraph assertions
         * @property {Array.<dataform.IDeclaration>|null} [declarations] CompiledGraph declarations
         * @property {Array.<dataform.ITest>|null} [tests] CompiledGraph tests
         * @property {dataform.IGraphErrors|null} [graphErrors] CompiledGraph graphErrors
         * @property {string|null} [dataformCoreVersion] CompiledGraph dataformCoreVersion
         * @property {Array.<dataform.ITarget>|null} [targets] CompiledGraph targets
         */

        /**
         * Constructs a new CompiledGraph.
         * @memberof dataform
         * @classdesc Represents a CompiledGraph.
         * @implements ICompiledGraph
         * @constructor
         * @param {dataform.ICompiledGraph=} [properties] Properties to set
         */
        function CompiledGraph(properties) {
            this.tables = [];
            this.operations = [];
            this.assertions = [];
            this.declarations = [];
            this.tests = [];
            this.targets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompiledGraph projectConfig.
         * @member {dataform.IProjectConfig|null|undefined} projectConfig
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.projectConfig = null;

        /**
         * CompiledGraph tables.
         * @member {Array.<dataform.ITable>} tables
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.tables = $util.emptyArray;

        /**
         * CompiledGraph operations.
         * @member {Array.<dataform.IOperation>} operations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.operations = $util.emptyArray;

        /**
         * CompiledGraph assertions.
         * @member {Array.<dataform.IAssertion>} assertions
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.assertions = $util.emptyArray;

        /**
         * CompiledGraph declarations.
         * @member {Array.<dataform.IDeclaration>} declarations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.declarations = $util.emptyArray;

        /**
         * CompiledGraph tests.
         * @member {Array.<dataform.ITest>} tests
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.tests = $util.emptyArray;

        /**
         * CompiledGraph graphErrors.
         * @member {dataform.IGraphErrors|null|undefined} graphErrors
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.graphErrors = null;

        /**
         * CompiledGraph dataformCoreVersion.
         * @member {string} dataformCoreVersion
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.dataformCoreVersion = "";

        /**
         * CompiledGraph targets.
         * @member {Array.<dataform.ITarget>} targets
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.targets = $util.emptyArray;

        /**
         * Creates a new CompiledGraph instance using the specified properties.
         * @function create
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph=} [properties] Properties to set
         * @returns {dataform.CompiledGraph} CompiledGraph instance
         */
        CompiledGraph.create = function create(properties) {
            return new CompiledGraph(properties);
        };

        /**
         * Encodes the specified CompiledGraph message. Does not implicitly {@link dataform.CompiledGraph.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph} message CompiledGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompiledGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (let i = 0; i < message.tables.length; ++i)
                    $root.dataform.Table.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.operations != null && message.operations.length)
                for (let i = 0; i < message.operations.length; ++i)
                    $root.dataform.Operation.encode(message.operations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.assertions != null && message.assertions.length)
                for (let i = 0; i < message.assertions.length; ++i)
                    $root.dataform.Assertion.encode(message.assertions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                $root.dataform.ProjectConfig.encode(message.projectConfig, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors"))
                $root.dataform.GraphErrors.encode(message.graphErrors, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.tests != null && message.tests.length)
                for (let i = 0; i < message.tests.length; ++i)
                    $root.dataform.Test.encode(message.tests[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.declarations != null && message.declarations.length)
                for (let i = 0; i < message.declarations.length; ++i)
                    $root.dataform.Declaration.encode(message.declarations[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.dataformCoreVersion);
            if (message.targets != null && message.targets.length)
                for (let i = 0; i < message.targets.length; ++i)
                    $root.dataform.Target.encode(message.targets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompiledGraph message, length delimited. Does not implicitly {@link dataform.CompiledGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph} message CompiledGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompiledGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompiledGraph message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompiledGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompiledGraph} CompiledGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompiledGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompiledGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.projectConfig = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push($root.dataform.Table.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.operations && message.operations.length))
                        message.operations = [];
                    message.operations.push($root.dataform.Operation.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.assertions && message.assertions.length))
                        message.assertions = [];
                    message.assertions.push($root.dataform.Assertion.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.declarations && message.declarations.length))
                        message.declarations = [];
                    message.declarations.push($root.dataform.Declaration.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.tests && message.tests.length))
                        message.tests = [];
                    message.tests.push($root.dataform.Test.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.graphErrors = $root.dataform.GraphErrors.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.dataformCoreVersion = reader.string();
                    break;
                case 11:
                    if (!(message.targets && message.targets.length))
                        message.targets = [];
                    message.targets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompiledGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompiledGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompiledGraph} CompiledGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompiledGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompiledGraph message.
         * @function verify
         * @memberof dataform.CompiledGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompiledGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfig);
                if (error)
                    return "projectConfig." + error;
            }
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (let i = 0; i < message.tables.length; ++i) {
                    let error = $root.dataform.Table.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            if (message.operations != null && message.hasOwnProperty("operations")) {
                if (!Array.isArray(message.operations))
                    return "operations: array expected";
                for (let i = 0; i < message.operations.length; ++i) {
                    let error = $root.dataform.Operation.verify(message.operations[i]);
                    if (error)
                        return "operations." + error;
                }
            }
            if (message.assertions != null && message.hasOwnProperty("assertions")) {
                if (!Array.isArray(message.assertions))
                    return "assertions: array expected";
                for (let i = 0; i < message.assertions.length; ++i) {
                    let error = $root.dataform.Assertion.verify(message.assertions[i]);
                    if (error)
                        return "assertions." + error;
                }
            }
            if (message.declarations != null && message.hasOwnProperty("declarations")) {
                if (!Array.isArray(message.declarations))
                    return "declarations: array expected";
                for (let i = 0; i < message.declarations.length; ++i) {
                    let error = $root.dataform.Declaration.verify(message.declarations[i]);
                    if (error)
                        return "declarations." + error;
                }
            }
            if (message.tests != null && message.hasOwnProperty("tests")) {
                if (!Array.isArray(message.tests))
                    return "tests: array expected";
                for (let i = 0; i < message.tests.length; ++i) {
                    let error = $root.dataform.Test.verify(message.tests[i]);
                    if (error)
                        return "tests." + error;
                }
            }
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors")) {
                let error = $root.dataform.GraphErrors.verify(message.graphErrors);
                if (error)
                    return "graphErrors." + error;
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                if (!$util.isString(message.dataformCoreVersion))
                    return "dataformCoreVersion: string expected";
            if (message.targets != null && message.hasOwnProperty("targets")) {
                if (!Array.isArray(message.targets))
                    return "targets: array expected";
                for (let i = 0; i < message.targets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.targets[i]);
                    if (error)
                        return "targets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CompiledGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompiledGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompiledGraph} CompiledGraph
         */
        CompiledGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompiledGraph)
                return object;
            let message = new $root.dataform.CompiledGraph();
            if (object.projectConfig != null) {
                if (typeof object.projectConfig !== "object")
                    throw TypeError(".dataform.CompiledGraph.projectConfig: object expected");
                message.projectConfig = $root.dataform.ProjectConfig.fromObject(object.projectConfig);
            }
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".dataform.CompiledGraph.tables: array expected");
                message.tables = [];
                for (let i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.tables: object expected");
                    message.tables[i] = $root.dataform.Table.fromObject(object.tables[i]);
                }
            }
            if (object.operations) {
                if (!Array.isArray(object.operations))
                    throw TypeError(".dataform.CompiledGraph.operations: array expected");
                message.operations = [];
                for (let i = 0; i < object.operations.length; ++i) {
                    if (typeof object.operations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.operations: object expected");
                    message.operations[i] = $root.dataform.Operation.fromObject(object.operations[i]);
                }
            }
            if (object.assertions) {
                if (!Array.isArray(object.assertions))
                    throw TypeError(".dataform.CompiledGraph.assertions: array expected");
                message.assertions = [];
                for (let i = 0; i < object.assertions.length; ++i) {
                    if (typeof object.assertions[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.assertions: object expected");
                    message.assertions[i] = $root.dataform.Assertion.fromObject(object.assertions[i]);
                }
            }
            if (object.declarations) {
                if (!Array.isArray(object.declarations))
                    throw TypeError(".dataform.CompiledGraph.declarations: array expected");
                message.declarations = [];
                for (let i = 0; i < object.declarations.length; ++i) {
                    if (typeof object.declarations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.declarations: object expected");
                    message.declarations[i] = $root.dataform.Declaration.fromObject(object.declarations[i]);
                }
            }
            if (object.tests) {
                if (!Array.isArray(object.tests))
                    throw TypeError(".dataform.CompiledGraph.tests: array expected");
                message.tests = [];
                for (let i = 0; i < object.tests.length; ++i) {
                    if (typeof object.tests[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.tests: object expected");
                    message.tests[i] = $root.dataform.Test.fromObject(object.tests[i]);
                }
            }
            if (object.graphErrors != null) {
                if (typeof object.graphErrors !== "object")
                    throw TypeError(".dataform.CompiledGraph.graphErrors: object expected");
                message.graphErrors = $root.dataform.GraphErrors.fromObject(object.graphErrors);
            }
            if (object.dataformCoreVersion != null)
                message.dataformCoreVersion = String(object.dataformCoreVersion);
            if (object.targets) {
                if (!Array.isArray(object.targets))
                    throw TypeError(".dataform.CompiledGraph.targets: array expected");
                message.targets = [];
                for (let i = 0; i < object.targets.length; ++i) {
                    if (typeof object.targets[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.targets: object expected");
                    message.targets[i] = $root.dataform.Target.fromObject(object.targets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CompiledGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.CompiledGraph} message CompiledGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompiledGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tables = [];
                object.operations = [];
                object.assertions = [];
                object.tests = [];
                object.declarations = [];
                object.targets = [];
            }
            if (options.defaults) {
                object.projectConfig = null;
                object.graphErrors = null;
                object.dataformCoreVersion = "";
            }
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (let j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.dataform.Table.toObject(message.tables[j], options);
            }
            if (message.operations && message.operations.length) {
                object.operations = [];
                for (let j = 0; j < message.operations.length; ++j)
                    object.operations[j] = $root.dataform.Operation.toObject(message.operations[j], options);
            }
            if (message.assertions && message.assertions.length) {
                object.assertions = [];
                for (let j = 0; j < message.assertions.length; ++j)
                    object.assertions[j] = $root.dataform.Assertion.toObject(message.assertions[j], options);
            }
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                object.projectConfig = $root.dataform.ProjectConfig.toObject(message.projectConfig, options);
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors"))
                object.graphErrors = $root.dataform.GraphErrors.toObject(message.graphErrors, options);
            if (message.tests && message.tests.length) {
                object.tests = [];
                for (let j = 0; j < message.tests.length; ++j)
                    object.tests[j] = $root.dataform.Test.toObject(message.tests[j], options);
            }
            if (message.declarations && message.declarations.length) {
                object.declarations = [];
                for (let j = 0; j < message.declarations.length; ++j)
                    object.declarations[j] = $root.dataform.Declaration.toObject(message.declarations[j], options);
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                object.dataformCoreVersion = message.dataformCoreVersion;
            if (message.targets && message.targets.length) {
                object.targets = [];
                for (let j = 0; j < message.targets.length; ++j)
                    object.targets[j] = $root.dataform.Target.toObject(message.targets[j], options);
            }
            return object;
        };

        /**
         * Converts this CompiledGraph to JSON.
         * @function toJSON
         * @memberof dataform.CompiledGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompiledGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CompiledGraph;
    })();

    dataform.ExecutionTask = (function() {

        /**
         * Properties of an ExecutionTask.
         * @memberof dataform
         * @interface IExecutionTask
         * @property {string|null} [type] ExecutionTask type
         * @property {string|null} [statement] ExecutionTask statement
         */

        /**
         * Constructs a new ExecutionTask.
         * @memberof dataform
         * @classdesc Represents an ExecutionTask.
         * @implements IExecutionTask
         * @constructor
         * @param {dataform.IExecutionTask=} [properties] Properties to set
         */
        function ExecutionTask(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionTask type.
         * @member {string} type
         * @memberof dataform.ExecutionTask
         * @instance
         */
        ExecutionTask.prototype.type = "";

        /**
         * ExecutionTask statement.
         * @member {string} statement
         * @memberof dataform.ExecutionTask
         * @instance
         */
        ExecutionTask.prototype.statement = "";

        /**
         * Creates a new ExecutionTask instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask=} [properties] Properties to set
         * @returns {dataform.ExecutionTask} ExecutionTask instance
         */
        ExecutionTask.create = function create(properties) {
            return new ExecutionTask(properties);
        };

        /**
         * Encodes the specified ExecutionTask message. Does not implicitly {@link dataform.ExecutionTask.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask} message ExecutionTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionTask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.statement != null && message.hasOwnProperty("statement"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.statement);
            return writer;
        };

        /**
         * Encodes the specified ExecutionTask message, length delimited. Does not implicitly {@link dataform.ExecutionTask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask} message ExecutionTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionTask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionTask message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionTask} ExecutionTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionTask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionTask();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.statement = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionTask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionTask} ExecutionTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionTask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionTask message.
         * @function verify
         * @memberof dataform.ExecutionTask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionTask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.statement != null && message.hasOwnProperty("statement"))
                if (!$util.isString(message.statement))
                    return "statement: string expected";
            return null;
        };

        /**
         * Creates an ExecutionTask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionTask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionTask} ExecutionTask
         */
        ExecutionTask.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionTask)
                return object;
            let message = new $root.dataform.ExecutionTask();
            if (object.type != null)
                message.type = String(object.type);
            if (object.statement != null)
                message.statement = String(object.statement);
            return message;
        };

        /**
         * Creates a plain object from an ExecutionTask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.ExecutionTask} message ExecutionTask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionTask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = "";
                object.statement = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.statement != null && message.hasOwnProperty("statement"))
                object.statement = message.statement;
            return object;
        };

        /**
         * Converts this ExecutionTask to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionTask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionTask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutionTask;
    })();

    dataform.ExecutionAction = (function() {

        /**
         * Properties of an ExecutionAction.
         * @memberof dataform
         * @interface IExecutionAction
         * @property {string|null} [name] ExecutionAction name
         * @property {dataform.ITarget|null} [target] ExecutionAction target
         * @property {string|null} [fileName] ExecutionAction fileName
         * @property {string|null} [type] ExecutionAction type
         * @property {string|null} [tableType] ExecutionAction tableType
         * @property {Array.<string>|null} [dependencies] ExecutionAction dependencies
         * @property {Array.<dataform.ITarget>|null} [transitiveInputs] ExecutionAction transitiveInputs
         * @property {dataform.ActionHermeticity|null} [hermeticity] ExecutionAction hermeticity
         * @property {Array.<dataform.IExecutionTask>|null} [tasks] ExecutionAction tasks
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] ExecutionAction actionDescriptor
         */

        /**
         * Constructs a new ExecutionAction.
         * @memberof dataform
         * @classdesc Represents an ExecutionAction.
         * @implements IExecutionAction
         * @constructor
         * @param {dataform.IExecutionAction=} [properties] Properties to set
         */
        function ExecutionAction(properties) {
            this.dependencies = [];
            this.transitiveInputs = [];
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionAction name.
         * @member {string} name
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.name = "";

        /**
         * ExecutionAction target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.target = null;

        /**
         * ExecutionAction fileName.
         * @member {string} fileName
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.fileName = "";

        /**
         * ExecutionAction type.
         * @member {string} type
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.type = "";

        /**
         * ExecutionAction tableType.
         * @member {string} tableType
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.tableType = "";

        /**
         * ExecutionAction dependencies.
         * @member {Array.<string>} dependencies
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.dependencies = $util.emptyArray;

        /**
         * ExecutionAction transitiveInputs.
         * @member {Array.<dataform.ITarget>} transitiveInputs
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.transitiveInputs = $util.emptyArray;

        /**
         * ExecutionAction hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.hermeticity = 0;

        /**
         * ExecutionAction tasks.
         * @member {Array.<dataform.IExecutionTask>} tasks
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.tasks = $util.emptyArray;

        /**
         * ExecutionAction actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.actionDescriptor = null;

        /**
         * Creates a new ExecutionAction instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction=} [properties] Properties to set
         * @returns {dataform.ExecutionAction} ExecutionAction instance
         */
        ExecutionAction.create = function create(properties) {
            return new ExecutionAction(properties);
        };

        /**
         * Encodes the specified ExecutionAction message. Does not implicitly {@link dataform.ExecutionAction.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction} message ExecutionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.dataform.ExecutionTask.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.dependencies != null && message.dependencies.length)
                for (let i = 0; i < message.dependencies.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependencies[i]);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.tableType);
            if (message.transitiveInputs != null && message.transitiveInputs.length)
                for (let i = 0; i < message.transitiveInputs.length; ++i)
                    $root.dataform.Target.encode(message.transitiveInputs[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fileName);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.hermeticity);
            return writer;
        };

        /**
         * Encodes the specified ExecutionAction message, length delimited. Does not implicitly {@link dataform.ExecutionAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction} message ExecutionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionAction message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionAction} ExecutionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 5:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.fileName = reader.string();
                    break;
                case 4:
                    message.type = reader.string();
                    break;
                case 6:
                    message.tableType = reader.string();
                    break;
                case 3:
                    if (!(message.dependencies && message.dependencies.length))
                        message.dependencies = [];
                    message.dependencies.push(reader.string());
                    break;
                case 7:
                    if (!(message.transitiveInputs && message.transitiveInputs.length))
                        message.transitiveInputs = [];
                    message.transitiveInputs.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.hermeticity = reader.int32();
                    break;
                case 2:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.dataform.ExecutionTask.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionAction} ExecutionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionAction message.
         * @function verify
         * @memberof dataform.ExecutionAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                if (!$util.isString(message.tableType))
                    return "tableType: string expected";
            if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                if (!Array.isArray(message.dependencies))
                    return "dependencies: array expected";
                for (let i = 0; i < message.dependencies.length; ++i)
                    if (!$util.isString(message.dependencies[i]))
                        return "dependencies: string[] expected";
            }
            if (message.transitiveInputs != null && message.hasOwnProperty("transitiveInputs")) {
                if (!Array.isArray(message.transitiveInputs))
                    return "transitiveInputs: array expected";
                for (let i = 0; i < message.transitiveInputs.length; ++i) {
                    let error = $root.dataform.Target.verify(message.transitiveInputs[i]);
                    if (error)
                        return "transitiveInputs." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.dataform.ExecutionTask.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionAction} ExecutionAction
         */
        ExecutionAction.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionAction)
                return object;
            let message = new $root.dataform.ExecutionAction();
            if (object.name != null)
                message.name = String(object.name);
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.ExecutionAction.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.type != null)
                message.type = String(object.type);
            if (object.tableType != null)
                message.tableType = String(object.tableType);
            if (object.dependencies) {
                if (!Array.isArray(object.dependencies))
                    throw TypeError(".dataform.ExecutionAction.dependencies: array expected");
                message.dependencies = [];
                for (let i = 0; i < object.dependencies.length; ++i)
                    message.dependencies[i] = String(object.dependencies[i]);
            }
            if (object.transitiveInputs) {
                if (!Array.isArray(object.transitiveInputs))
                    throw TypeError(".dataform.ExecutionAction.transitiveInputs: array expected");
                message.transitiveInputs = [];
                for (let i = 0; i < object.transitiveInputs.length; ++i) {
                    if (typeof object.transitiveInputs[i] !== "object")
                        throw TypeError(".dataform.ExecutionAction.transitiveInputs: object expected");
                    message.transitiveInputs[i] = $root.dataform.Target.fromObject(object.transitiveInputs[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".dataform.ExecutionAction.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".dataform.ExecutionAction.tasks: object expected");
                    message.tasks[i] = $root.dataform.ExecutionTask.fromObject(object.tasks[i]);
                }
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.ExecutionAction.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.ExecutionAction} message ExecutionAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tasks = [];
                object.dependencies = [];
                object.transitiveInputs = [];
            }
            if (options.defaults) {
                object.name = "";
                object.type = "";
                object.target = null;
                object.tableType = "";
                object.fileName = "";
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.dataform.ExecutionTask.toObject(message.tasks[j], options);
            }
            if (message.dependencies && message.dependencies.length) {
                object.dependencies = [];
                for (let j = 0; j < message.dependencies.length; ++j)
                    object.dependencies[j] = message.dependencies[j];
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                object.tableType = message.tableType;
            if (message.transitiveInputs && message.transitiveInputs.length) {
                object.transitiveInputs = [];
                for (let j = 0; j < message.transitiveInputs.length; ++j)
                    object.transitiveInputs[j] = $root.dataform.Target.toObject(message.transitiveInputs[j], options);
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            return object;
        };

        /**
         * Converts this ExecutionAction to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutionAction;
    })();

    dataform.WarehouseState = (function() {

        /**
         * Properties of a WarehouseState.
         * @memberof dataform
         * @interface IWarehouseState
         * @property {Array.<dataform.ITableMetadata>|null} [tables] WarehouseState tables
         */

        /**
         * Constructs a new WarehouseState.
         * @memberof dataform
         * @classdesc Represents a WarehouseState.
         * @implements IWarehouseState
         * @constructor
         * @param {dataform.IWarehouseState=} [properties] Properties to set
         */
        function WarehouseState(properties) {
            this.tables = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarehouseState tables.
         * @member {Array.<dataform.ITableMetadata>} tables
         * @memberof dataform.WarehouseState
         * @instance
         */
        WarehouseState.prototype.tables = $util.emptyArray;

        /**
         * Creates a new WarehouseState instance using the specified properties.
         * @function create
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState=} [properties] Properties to set
         * @returns {dataform.WarehouseState} WarehouseState instance
         */
        WarehouseState.create = function create(properties) {
            return new WarehouseState(properties);
        };

        /**
         * Encodes the specified WarehouseState message. Does not implicitly {@link dataform.WarehouseState.verify|verify} messages.
         * @function encode
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState} message WarehouseState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarehouseState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (let i = 0; i < message.tables.length; ++i)
                    $root.dataform.TableMetadata.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WarehouseState message, length delimited. Does not implicitly {@link dataform.WarehouseState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState} message WarehouseState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarehouseState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarehouseState message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.WarehouseState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.WarehouseState} WarehouseState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarehouseState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.WarehouseState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push($root.dataform.TableMetadata.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarehouseState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.WarehouseState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.WarehouseState} WarehouseState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarehouseState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarehouseState message.
         * @function verify
         * @memberof dataform.WarehouseState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarehouseState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (let i = 0; i < message.tables.length; ++i) {
                    let error = $root.dataform.TableMetadata.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WarehouseState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.WarehouseState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.WarehouseState} WarehouseState
         */
        WarehouseState.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.WarehouseState)
                return object;
            let message = new $root.dataform.WarehouseState();
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".dataform.WarehouseState.tables: array expected");
                message.tables = [];
                for (let i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".dataform.WarehouseState.tables: object expected");
                    message.tables[i] = $root.dataform.TableMetadata.fromObject(object.tables[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WarehouseState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.WarehouseState} message WarehouseState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarehouseState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tables = [];
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (let j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.dataform.TableMetadata.toObject(message.tables[j], options);
            }
            return object;
        };

        /**
         * Converts this WarehouseState to JSON.
         * @function toJSON
         * @memberof dataform.WarehouseState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarehouseState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarehouseState;
    })();

    dataform.ExecutionGraph = (function() {

        /**
         * Properties of an ExecutionGraph.
         * @memberof dataform
         * @interface IExecutionGraph
         * @property {dataform.IProjectConfig|null} [projectConfig] ExecutionGraph projectConfig
         * @property {dataform.IRunConfig|null} [runConfig] ExecutionGraph runConfig
         * @property {dataform.IWarehouseState|null} [warehouseState] ExecutionGraph warehouseState
         * @property {Array.<dataform.ITarget>|null} [declarationTargets] ExecutionGraph declarationTargets
         * @property {Array.<dataform.IExecutionAction>|null} [actions] ExecutionGraph actions
         */

        /**
         * Constructs a new ExecutionGraph.
         * @memberof dataform
         * @classdesc Represents an ExecutionGraph.
         * @implements IExecutionGraph
         * @constructor
         * @param {dataform.IExecutionGraph=} [properties] Properties to set
         */
        function ExecutionGraph(properties) {
            this.declarationTargets = [];
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionGraph projectConfig.
         * @member {dataform.IProjectConfig|null|undefined} projectConfig
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.projectConfig = null;

        /**
         * ExecutionGraph runConfig.
         * @member {dataform.IRunConfig|null|undefined} runConfig
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.runConfig = null;

        /**
         * ExecutionGraph warehouseState.
         * @member {dataform.IWarehouseState|null|undefined} warehouseState
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.warehouseState = null;

        /**
         * ExecutionGraph declarationTargets.
         * @member {Array.<dataform.ITarget>} declarationTargets
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.declarationTargets = $util.emptyArray;

        /**
         * ExecutionGraph actions.
         * @member {Array.<dataform.IExecutionAction>} actions
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.actions = $util.emptyArray;

        /**
         * Creates a new ExecutionGraph instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph=} [properties] Properties to set
         * @returns {dataform.ExecutionGraph} ExecutionGraph instance
         */
        ExecutionGraph.create = function create(properties) {
            return new ExecutionGraph(properties);
        };

        /**
         * Encodes the specified ExecutionGraph message. Does not implicitly {@link dataform.ExecutionGraph.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph} message ExecutionGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                $root.dataform.ProjectConfig.encode(message.projectConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.runConfig != null && message.hasOwnProperty("runConfig"))
                $root.dataform.RunConfig.encode(message.runConfig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ExecutionAction.encode(message.actions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState"))
                $root.dataform.WarehouseState.encode(message.warehouseState, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.declarationTargets != null && message.declarationTargets.length)
                for (let i = 0; i < message.declarationTargets.length; ++i)
                    $root.dataform.Target.encode(message.declarationTargets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionGraph message, length delimited. Does not implicitly {@link dataform.ExecutionGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph} message ExecutionGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionGraph message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.projectConfig = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.runConfig = $root.dataform.RunConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.warehouseState = $root.dataform.WarehouseState.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.declarationTargets && message.declarationTargets.length))
                        message.declarationTargets = [];
                    message.declarationTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.actions && message.actions.length))
                        message.actions = [];
                    message.actions.push($root.dataform.ExecutionAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionGraph message.
         * @function verify
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfig);
                if (error)
                    return "projectConfig." + error;
            }
            if (message.runConfig != null && message.hasOwnProperty("runConfig")) {
                let error = $root.dataform.RunConfig.verify(message.runConfig);
                if (error)
                    return "runConfig." + error;
            }
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState")) {
                let error = $root.dataform.WarehouseState.verify(message.warehouseState);
                if (error)
                    return "warehouseState." + error;
            }
            if (message.declarationTargets != null && message.hasOwnProperty("declarationTargets")) {
                if (!Array.isArray(message.declarationTargets))
                    return "declarationTargets: array expected";
                for (let i = 0; i < message.declarationTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.declarationTargets[i]);
                    if (error)
                        return "declarationTargets." + error;
                }
            }
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ExecutionAction.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExecutionGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         */
        ExecutionGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionGraph)
                return object;
            let message = new $root.dataform.ExecutionGraph();
            if (object.projectConfig != null) {
                if (typeof object.projectConfig !== "object")
                    throw TypeError(".dataform.ExecutionGraph.projectConfig: object expected");
                message.projectConfig = $root.dataform.ProjectConfig.fromObject(object.projectConfig);
            }
            if (object.runConfig != null) {
                if (typeof object.runConfig !== "object")
                    throw TypeError(".dataform.ExecutionGraph.runConfig: object expected");
                message.runConfig = $root.dataform.RunConfig.fromObject(object.runConfig);
            }
            if (object.warehouseState != null) {
                if (typeof object.warehouseState !== "object")
                    throw TypeError(".dataform.ExecutionGraph.warehouseState: object expected");
                message.warehouseState = $root.dataform.WarehouseState.fromObject(object.warehouseState);
            }
            if (object.declarationTargets) {
                if (!Array.isArray(object.declarationTargets))
                    throw TypeError(".dataform.ExecutionGraph.declarationTargets: array expected");
                message.declarationTargets = [];
                for (let i = 0; i < object.declarationTargets.length; ++i) {
                    if (typeof object.declarationTargets[i] !== "object")
                        throw TypeError(".dataform.ExecutionGraph.declarationTargets: object expected");
                    message.declarationTargets[i] = $root.dataform.Target.fromObject(object.declarationTargets[i]);
                }
            }
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.ExecutionGraph.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.ExecutionGraph.actions: object expected");
                    message.actions[i] = $root.dataform.ExecutionAction.fromObject(object.actions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.ExecutionGraph} message ExecutionGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.declarationTargets = [];
            }
            if (options.defaults) {
                object.projectConfig = null;
                object.runConfig = null;
                object.warehouseState = null;
            }
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                object.projectConfig = $root.dataform.ProjectConfig.toObject(message.projectConfig, options);
            if (message.runConfig != null && message.hasOwnProperty("runConfig"))
                object.runConfig = $root.dataform.RunConfig.toObject(message.runConfig, options);
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ExecutionAction.toObject(message.actions[j], options);
            }
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState"))
                object.warehouseState = $root.dataform.WarehouseState.toObject(message.warehouseState, options);
            if (message.declarationTargets && message.declarationTargets.length) {
                object.declarationTargets = [];
                for (let j = 0; j < message.declarationTargets.length; ++j)
                    object.declarationTargets[j] = $root.dataform.Target.toObject(message.declarationTargets[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecutionGraph to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutionGraph;
    })();

    dataform.Timing = (function() {

        /**
         * Properties of a Timing.
         * @memberof dataform
         * @interface ITiming
         * @property {Long|null} [startTimeMillis] Timing startTimeMillis
         * @property {Long|null} [endTimeMillis] Timing endTimeMillis
         */

        /**
         * Constructs a new Timing.
         * @memberof dataform
         * @classdesc Represents a Timing.
         * @implements ITiming
         * @constructor
         * @param {dataform.ITiming=} [properties] Properties to set
         */
        function Timing(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timing startTimeMillis.
         * @member {Long} startTimeMillis
         * @memberof dataform.Timing
         * @instance
         */
        Timing.prototype.startTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Timing endTimeMillis.
         * @member {Long} endTimeMillis
         * @memberof dataform.Timing
         * @instance
         */
        Timing.prototype.endTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Timing instance using the specified properties.
         * @function create
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming=} [properties] Properties to set
         * @returns {dataform.Timing} Timing instance
         */
        Timing.create = function create(properties) {
            return new Timing(properties);
        };

        /**
         * Encodes the specified Timing message. Does not implicitly {@link dataform.Timing.verify|verify} messages.
         * @function encode
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTimeMillis);
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endTimeMillis);
            return writer;
        };

        /**
         * Encodes the specified Timing message, length delimited. Does not implicitly {@link dataform.Timing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timing message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Timing();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startTimeMillis = reader.int64();
                    break;
                case 2:
                    message.endTimeMillis = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timing message.
         * @function verify
         * @memberof dataform.Timing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                if (!$util.isInteger(message.startTimeMillis) && !(message.startTimeMillis && $util.isInteger(message.startTimeMillis.low) && $util.isInteger(message.startTimeMillis.high)))
                    return "startTimeMillis: integer|Long expected";
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                if (!$util.isInteger(message.endTimeMillis) && !(message.endTimeMillis && $util.isInteger(message.endTimeMillis.low) && $util.isInteger(message.endTimeMillis.high)))
                    return "endTimeMillis: integer|Long expected";
            return null;
        };

        /**
         * Creates a Timing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Timing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Timing} Timing
         */
        Timing.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Timing)
                return object;
            let message = new $root.dataform.Timing();
            if (object.startTimeMillis != null)
                if ($util.Long)
                    (message.startTimeMillis = $util.Long.fromValue(object.startTimeMillis)).unsigned = false;
                else if (typeof object.startTimeMillis === "string")
                    message.startTimeMillis = parseInt(object.startTimeMillis, 10);
                else if (typeof object.startTimeMillis === "number")
                    message.startTimeMillis = object.startTimeMillis;
                else if (typeof object.startTimeMillis === "object")
                    message.startTimeMillis = new $util.LongBits(object.startTimeMillis.low >>> 0, object.startTimeMillis.high >>> 0).toNumber();
            if (object.endTimeMillis != null)
                if ($util.Long)
                    (message.endTimeMillis = $util.Long.fromValue(object.endTimeMillis)).unsigned = false;
                else if (typeof object.endTimeMillis === "string")
                    message.endTimeMillis = parseInt(object.endTimeMillis, 10);
                else if (typeof object.endTimeMillis === "number")
                    message.endTimeMillis = object.endTimeMillis;
                else if (typeof object.endTimeMillis === "object")
                    message.endTimeMillis = new $util.LongBits(object.endTimeMillis.low >>> 0, object.endTimeMillis.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Timing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Timing
         * @static
         * @param {dataform.Timing} message Timing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTimeMillis = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.endTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTimeMillis = options.longs === String ? "0" : 0;
            }
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                if (typeof message.startTimeMillis === "number")
                    object.startTimeMillis = options.longs === String ? String(message.startTimeMillis) : message.startTimeMillis;
                else
                    object.startTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeMillis) : options.longs === Number ? new $util.LongBits(message.startTimeMillis.low >>> 0, message.startTimeMillis.high >>> 0).toNumber() : message.startTimeMillis;
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                if (typeof message.endTimeMillis === "number")
                    object.endTimeMillis = options.longs === String ? String(message.endTimeMillis) : message.endTimeMillis;
                else
                    object.endTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeMillis) : options.longs === Number ? new $util.LongBits(message.endTimeMillis.low >>> 0, message.endTimeMillis.high >>> 0).toNumber() : message.endTimeMillis;
            return object;
        };

        /**
         * Converts this Timing to JSON.
         * @function toJSON
         * @memberof dataform.Timing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Timing;
    })();

    dataform.RunResult = (function() {

        /**
         * Properties of a RunResult.
         * @memberof dataform
         * @interface IRunResult
         * @property {dataform.RunResult.ExecutionStatus|null} [status] RunResult status
         * @property {Array.<dataform.IActionResult>|null} [actions] RunResult actions
         * @property {dataform.ITiming|null} [timing] RunResult timing
         */

        /**
         * Constructs a new RunResult.
         * @memberof dataform
         * @classdesc Represents a RunResult.
         * @implements IRunResult
         * @constructor
         * @param {dataform.IRunResult=} [properties] Properties to set
         */
        function RunResult(properties) {
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RunResult status.
         * @member {dataform.RunResult.ExecutionStatus} status
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.status = 0;

        /**
         * RunResult actions.
         * @member {Array.<dataform.IActionResult>} actions
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.actions = $util.emptyArray;

        /**
         * RunResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.timing = null;

        /**
         * Creates a new RunResult instance using the specified properties.
         * @function create
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult=} [properties] Properties to set
         * @returns {dataform.RunResult} RunResult instance
         */
        RunResult.create = function create(properties) {
            return new RunResult(properties);
        };

        /**
         * Encodes the specified RunResult message. Does not implicitly {@link dataform.RunResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult} message RunResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ActionResult.encode(message.actions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timing != null && message.hasOwnProperty("timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RunResult message, length delimited. Does not implicitly {@link dataform.RunResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult} message RunResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RunResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RunResult} RunResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RunResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    if (!(message.actions && message.actions.length))
                        message.actions = [];
                    message.actions.push($root.dataform.ActionResult.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RunResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RunResult} RunResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunResult message.
         * @function verify
         * @memberof dataform.RunResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ActionResult.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            return null;
        };

        /**
         * Creates a RunResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RunResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RunResult} RunResult
         */
        RunResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RunResult)
                return object;
            let message = new $root.dataform.RunResult();
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "CANCELLED":
            case 4:
                message.status = 4;
                break;
            case "TIMED_OUT":
            case 5:
                message.status = 5;
                break;
            }
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.RunResult.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.RunResult.actions: object expected");
                    message.actions[i] = $root.dataform.ActionResult.fromObject(object.actions[i]);
                }
            }
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.RunResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            return message;
        };

        /**
         * Creates a plain object from a RunResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.RunResult} message RunResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.timing = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.RunResult.ExecutionStatus[message.status] : message.status;
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ActionResult.toObject(message.actions[j], options);
            }
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            return object;
        };

        /**
         * Converts this RunResult to JSON.
         * @function toJSON
         * @memberof dataform.RunResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.RunResult.ExecutionStatus
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} CANCELLED=4 CANCELLED value
         * @property {number} TIMED_OUT=5 TIMED_OUT value
         */
        RunResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "CANCELLED"] = 4;
            values[valuesById[5] = "TIMED_OUT"] = 5;
            return values;
        })();

        return RunResult;
    })();

    dataform.ActionResult = (function() {

        /**
         * Properties of an ActionResult.
         * @memberof dataform
         * @interface IActionResult
         * @property {string|null} [name] ActionResult name
         * @property {dataform.ITarget|null} [target] ActionResult target
         * @property {Array.<dataform.ActionResult.IInput>|null} [inputs] ActionResult inputs
         * @property {dataform.ActionResult.ExecutionStatus|null} [status] ActionResult status
         * @property {Array.<dataform.ITaskResult>|null} [tasks] ActionResult tasks
         * @property {dataform.ITiming|null} [timing] ActionResult timing
         * @property {Long|null} [postExecutionTimestampMillis] ActionResult postExecutionTimestampMillis
         */

        /**
         * Constructs a new ActionResult.
         * @memberof dataform
         * @classdesc Represents an ActionResult.
         * @implements IActionResult
         * @constructor
         * @param {dataform.IActionResult=} [properties] Properties to set
         */
        function ActionResult(properties) {
            this.inputs = [];
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionResult name.
         * @member {string} name
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.name = "";

        /**
         * ActionResult target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.target = null;

        /**
         * ActionResult inputs.
         * @member {Array.<dataform.ActionResult.IInput>} inputs
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.inputs = $util.emptyArray;

        /**
         * ActionResult status.
         * @member {dataform.ActionResult.ExecutionStatus} status
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.status = 0;

        /**
         * ActionResult tasks.
         * @member {Array.<dataform.ITaskResult>} tasks
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.tasks = $util.emptyArray;

        /**
         * ActionResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.timing = null;

        /**
         * ActionResult postExecutionTimestampMillis.
         * @member {Long} postExecutionTimestampMillis
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.postExecutionTimestampMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ActionResult instance using the specified properties.
         * @function create
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult=} [properties] Properties to set
         * @returns {dataform.ActionResult} ActionResult instance
         */
        ActionResult.create = function create(properties) {
            return new ActionResult(properties);
        };

        /**
         * Encodes the specified ActionResult message. Does not implicitly {@link dataform.ActionResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult} message ActionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.dataform.TaskResult.encode(message.tasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timing != null && message.hasOwnProperty("timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.inputs != null && message.inputs.length)
                for (let i = 0; i < message.inputs.length; ++i)
                    $root.dataform.ActionResult.Input.encode(message.inputs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.postExecutionTimestampMillis != null && message.hasOwnProperty("postExecutionTimestampMillis"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.postExecutionTimestampMillis);
            return writer;
        };

        /**
         * Encodes the specified ActionResult message, length delimited. Does not implicitly {@link dataform.ActionResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult} message ActionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionResult} ActionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 5:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.inputs && message.inputs.length))
                        message.inputs = [];
                    message.inputs.push($root.dataform.ActionResult.Input.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.dataform.TaskResult.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.postExecutionTimestampMillis = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionResult} ActionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionResult message.
         * @function verify
         * @memberof dataform.ActionResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.inputs != null && message.hasOwnProperty("inputs")) {
                if (!Array.isArray(message.inputs))
                    return "inputs: array expected";
                for (let i = 0; i < message.inputs.length; ++i) {
                    let error = $root.dataform.ActionResult.Input.verify(message.inputs[i]);
                    if (error)
                        return "inputs." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.dataform.TaskResult.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            if (message.postExecutionTimestampMillis != null && message.hasOwnProperty("postExecutionTimestampMillis"))
                if (!$util.isInteger(message.postExecutionTimestampMillis) && !(message.postExecutionTimestampMillis && $util.isInteger(message.postExecutionTimestampMillis.low) && $util.isInteger(message.postExecutionTimestampMillis.high)))
                    return "postExecutionTimestampMillis: integer|Long expected";
            return null;
        };

        /**
         * Creates an ActionResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionResult} ActionResult
         */
        ActionResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionResult)
                return object;
            let message = new $root.dataform.ActionResult();
            if (object.name != null)
                message.name = String(object.name);
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.ActionResult.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.inputs) {
                if (!Array.isArray(object.inputs))
                    throw TypeError(".dataform.ActionResult.inputs: array expected");
                message.inputs = [];
                for (let i = 0; i < object.inputs.length; ++i) {
                    if (typeof object.inputs[i] !== "object")
                        throw TypeError(".dataform.ActionResult.inputs: object expected");
                    message.inputs[i] = $root.dataform.ActionResult.Input.fromObject(object.inputs[i]);
                }
            }
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "SKIPPED":
            case 4:
                message.status = 4;
                break;
            case "DISABLED":
            case 5:
                message.status = 5;
                break;
            case "CANCELLED":
            case 6:
                message.status = 6;
                break;
            case "CACHE_SKIPPED":
            case 7:
                message.status = 7;
                break;
            }
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".dataform.ActionResult.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".dataform.ActionResult.tasks: object expected");
                    message.tasks[i] = $root.dataform.TaskResult.fromObject(object.tasks[i]);
                }
            }
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.ActionResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            if (object.postExecutionTimestampMillis != null)
                if ($util.Long)
                    (message.postExecutionTimestampMillis = $util.Long.fromValue(object.postExecutionTimestampMillis)).unsigned = false;
                else if (typeof object.postExecutionTimestampMillis === "string")
                    message.postExecutionTimestampMillis = parseInt(object.postExecutionTimestampMillis, 10);
                else if (typeof object.postExecutionTimestampMillis === "number")
                    message.postExecutionTimestampMillis = object.postExecutionTimestampMillis;
                else if (typeof object.postExecutionTimestampMillis === "object")
                    message.postExecutionTimestampMillis = new $util.LongBits(object.postExecutionTimestampMillis.low >>> 0, object.postExecutionTimestampMillis.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ActionResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.ActionResult} message ActionResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tasks = [];
                object.inputs = [];
            }
            if (options.defaults) {
                object.name = "";
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.timing = null;
                object.target = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.postExecutionTimestampMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.postExecutionTimestampMillis = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.ActionResult.ExecutionStatus[message.status] : message.status;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.dataform.TaskResult.toObject(message.tasks[j], options);
            }
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.inputs && message.inputs.length) {
                object.inputs = [];
                for (let j = 0; j < message.inputs.length; ++j)
                    object.inputs[j] = $root.dataform.ActionResult.Input.toObject(message.inputs[j], options);
            }
            if (message.postExecutionTimestampMillis != null && message.hasOwnProperty("postExecutionTimestampMillis"))
                if (typeof message.postExecutionTimestampMillis === "number")
                    object.postExecutionTimestampMillis = options.longs === String ? String(message.postExecutionTimestampMillis) : message.postExecutionTimestampMillis;
                else
                    object.postExecutionTimestampMillis = options.longs === String ? $util.Long.prototype.toString.call(message.postExecutionTimestampMillis) : options.longs === Number ? new $util.LongBits(message.postExecutionTimestampMillis.low >>> 0, message.postExecutionTimestampMillis.high >>> 0).toNumber() : message.postExecutionTimestampMillis;
            return object;
        };

        /**
         * Converts this ActionResult to JSON.
         * @function toJSON
         * @memberof dataform.ActionResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ActionResult.Input = (function() {

            /**
             * Properties of an Input.
             * @memberof dataform.ActionResult
             * @interface IInput
             * @property {dataform.ITarget|null} [target] Input target
             * @property {dataform.ActionResult.Input.IMetadata|null} [metadata] Input metadata
             */

            /**
             * Constructs a new Input.
             * @memberof dataform.ActionResult
             * @classdesc Represents an Input.
             * @implements IInput
             * @constructor
             * @param {dataform.ActionResult.IInput=} [properties] Properties to set
             */
            function Input(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Input target.
             * @member {dataform.ITarget|null|undefined} target
             * @memberof dataform.ActionResult.Input
             * @instance
             */
            Input.prototype.target = null;

            /**
             * Input metadata.
             * @member {dataform.ActionResult.Input.IMetadata|null|undefined} metadata
             * @memberof dataform.ActionResult.Input
             * @instance
             */
            Input.prototype.metadata = null;

            /**
             * Creates a new Input instance using the specified properties.
             * @function create
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {dataform.ActionResult.IInput=} [properties] Properties to set
             * @returns {dataform.ActionResult.Input} Input instance
             */
            Input.create = function create(properties) {
                return new Input(properties);
            };

            /**
             * Encodes the specified Input message. Does not implicitly {@link dataform.ActionResult.Input.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {dataform.ActionResult.IInput} message Input message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Input.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && message.hasOwnProperty("target"))
                    $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.dataform.ActionResult.Input.Metadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Input message, length delimited. Does not implicitly {@link dataform.ActionResult.Input.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {dataform.ActionResult.IInput} message Input message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Input.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Input message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionResult.Input} Input
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Input.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionResult.Input();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.metadata = $root.dataform.ActionResult.Input.Metadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Input message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionResult.Input} Input
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Input.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Input message.
             * @function verify
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Input.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target")) {
                    let error = $root.dataform.Target.verify(message.target);
                    if (error)
                        return "target." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.dataform.ActionResult.Input.Metadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            /**
             * Creates an Input message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionResult.Input} Input
             */
            Input.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionResult.Input)
                    return object;
                let message = new $root.dataform.ActionResult.Input();
                if (object.target != null) {
                    if (typeof object.target !== "object")
                        throw TypeError(".dataform.ActionResult.Input.target: object expected");
                    message.target = $root.dataform.Target.fromObject(object.target);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".dataform.ActionResult.Input.metadata: object expected");
                    message.metadata = $root.dataform.ActionResult.Input.Metadata.fromObject(object.metadata);
                }
                return message;
            };

            /**
             * Creates a plain object from an Input message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {dataform.ActionResult.Input} message Input
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Input.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.target = null;
                    object.metadata = null;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    object.target = $root.dataform.Target.toObject(message.target, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.dataform.ActionResult.Input.Metadata.toObject(message.metadata, options);
                return object;
            };

            /**
             * Converts this Input to JSON.
             * @function toJSON
             * @memberof dataform.ActionResult.Input
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Input.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Input.Metadata = (function() {

                /**
                 * Properties of a Metadata.
                 * @memberof dataform.ActionResult.Input
                 * @interface IMetadata
                 * @property {Long|null} [lastModifiedTimestampMillis] Metadata lastModifiedTimestampMillis
                 */

                /**
                 * Constructs a new Metadata.
                 * @memberof dataform.ActionResult.Input
                 * @classdesc Represents a Metadata.
                 * @implements IMetadata
                 * @constructor
                 * @param {dataform.ActionResult.Input.IMetadata=} [properties] Properties to set
                 */
                function Metadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Metadata lastModifiedTimestampMillis.
                 * @member {Long} lastModifiedTimestampMillis
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @instance
                 */
                Metadata.prototype.lastModifiedTimestampMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new Metadata instance using the specified properties.
                 * @function create
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {dataform.ActionResult.Input.IMetadata=} [properties] Properties to set
                 * @returns {dataform.ActionResult.Input.Metadata} Metadata instance
                 */
                Metadata.create = function create(properties) {
                    return new Metadata(properties);
                };

                /**
                 * Encodes the specified Metadata message. Does not implicitly {@link dataform.ActionResult.Input.Metadata.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {dataform.ActionResult.Input.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.lastModifiedTimestampMillis != null && message.hasOwnProperty("lastModifiedTimestampMillis"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lastModifiedTimestampMillis);
                    return writer;
                };

                /**
                 * Encodes the specified Metadata message, length delimited. Does not implicitly {@link dataform.ActionResult.Input.Metadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {dataform.ActionResult.Input.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Metadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.ActionResult.Input.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionResult.Input.Metadata();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.lastModifiedTimestampMillis = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Metadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.ActionResult.Input.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Metadata message.
                 * @function verify
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Metadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.lastModifiedTimestampMillis != null && message.hasOwnProperty("lastModifiedTimestampMillis"))
                        if (!$util.isInteger(message.lastModifiedTimestampMillis) && !(message.lastModifiedTimestampMillis && $util.isInteger(message.lastModifiedTimestampMillis.low) && $util.isInteger(message.lastModifiedTimestampMillis.high)))
                            return "lastModifiedTimestampMillis: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.ActionResult.Input.Metadata} Metadata
                 */
                Metadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.ActionResult.Input.Metadata)
                        return object;
                    let message = new $root.dataform.ActionResult.Input.Metadata();
                    if (object.lastModifiedTimestampMillis != null)
                        if ($util.Long)
                            (message.lastModifiedTimestampMillis = $util.Long.fromValue(object.lastModifiedTimestampMillis)).unsigned = false;
                        else if (typeof object.lastModifiedTimestampMillis === "string")
                            message.lastModifiedTimestampMillis = parseInt(object.lastModifiedTimestampMillis, 10);
                        else if (typeof object.lastModifiedTimestampMillis === "number")
                            message.lastModifiedTimestampMillis = object.lastModifiedTimestampMillis;
                        else if (typeof object.lastModifiedTimestampMillis === "object")
                            message.lastModifiedTimestampMillis = new $util.LongBits(object.lastModifiedTimestampMillis.low >>> 0, object.lastModifiedTimestampMillis.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a Metadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {dataform.ActionResult.Input.Metadata} message Metadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Metadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.lastModifiedTimestampMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lastModifiedTimestampMillis = options.longs === String ? "0" : 0;
                    if (message.lastModifiedTimestampMillis != null && message.hasOwnProperty("lastModifiedTimestampMillis"))
                        if (typeof message.lastModifiedTimestampMillis === "number")
                            object.lastModifiedTimestampMillis = options.longs === String ? String(message.lastModifiedTimestampMillis) : message.lastModifiedTimestampMillis;
                        else
                            object.lastModifiedTimestampMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastModifiedTimestampMillis) : options.longs === Number ? new $util.LongBits(message.lastModifiedTimestampMillis.low >>> 0, message.lastModifiedTimestampMillis.high >>> 0).toNumber() : message.lastModifiedTimestampMillis;
                    return object;
                };

                /**
                 * Converts this Metadata to JSON.
                 * @function toJSON
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Metadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Metadata;
            })();

            return Input;
        })();

        /**
         * ExecutionStatus enum.
         * @name dataform.ActionResult.ExecutionStatus
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SKIPPED=4 SKIPPED value
         * @property {number} DISABLED=5 DISABLED value
         * @property {number} CANCELLED=6 CANCELLED value
         * @property {number} CACHE_SKIPPED=7 CACHE_SKIPPED value
         */
        ActionResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SKIPPED"] = 4;
            values[valuesById[5] = "DISABLED"] = 5;
            values[valuesById[6] = "CANCELLED"] = 6;
            values[valuesById[7] = "CACHE_SKIPPED"] = 7;
            return values;
        })();

        return ActionResult;
    })();

    dataform.ExecutionMetadata = (function() {

        /**
         * Properties of an ExecutionMetadata.
         * @memberof dataform
         * @interface IExecutionMetadata
         * @property {dataform.ExecutionMetadata.IBigqueryMetadata|null} [bigquery] ExecutionMetadata bigquery
         */

        /**
         * Constructs a new ExecutionMetadata.
         * @memberof dataform
         * @classdesc Represents an ExecutionMetadata.
         * @implements IExecutionMetadata
         * @constructor
         * @param {dataform.IExecutionMetadata=} [properties] Properties to set
         */
        function ExecutionMetadata(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionMetadata bigquery.
         * @member {dataform.ExecutionMetadata.IBigqueryMetadata|null|undefined} bigquery
         * @memberof dataform.ExecutionMetadata
         * @instance
         */
        ExecutionMetadata.prototype.bigquery = null;

        /**
         * Creates a new ExecutionMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata=} [properties] Properties to set
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata instance
         */
        ExecutionMetadata.create = function create(properties) {
            return new ExecutionMetadata(properties);
        };

        /**
         * Encodes the specified ExecutionMetadata message. Does not implicitly {@link dataform.ExecutionMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                $root.dataform.ExecutionMetadata.BigqueryMetadata.encode(message.bigquery, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionMetadata message, length delimited. Does not implicitly {@link dataform.ExecutionMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionMetadata();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionMetadata message.
         * @function verify
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.ExecutionMetadata.BigqueryMetadata.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         */
        ExecutionMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionMetadata)
                return object;
            let message = new $root.dataform.ExecutionMetadata();
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.ExecutionMetadata.bigquery: object expected");
                message.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.fromObject(object.bigquery);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.ExecutionMetadata} message ExecutionMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.bigquery = null;
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.toObject(message.bigquery, options);
            return object;
        };

        /**
         * Converts this ExecutionMetadata to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ExecutionMetadata.BigqueryMetadata = (function() {

            /**
             * Properties of a BigqueryMetadata.
             * @memberof dataform.ExecutionMetadata
             * @interface IBigqueryMetadata
             * @property {string|null} [jobId] BigqueryMetadata jobId
             * @property {Long|null} [totalBytesProcessed] BigqueryMetadata totalBytesProcessed
             * @property {Long|null} [totalBytesBilled] BigqueryMetadata totalBytesBilled
             */

            /**
             * Constructs a new BigqueryMetadata.
             * @memberof dataform.ExecutionMetadata
             * @classdesc Represents a BigqueryMetadata.
             * @implements IBigqueryMetadata
             * @constructor
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata=} [properties] Properties to set
             */
            function BigqueryMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BigqueryMetadata jobId.
             * @member {string} jobId
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.jobId = "";

            /**
             * BigqueryMetadata totalBytesProcessed.
             * @member {Long} totalBytesProcessed
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.totalBytesProcessed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BigqueryMetadata totalBytesBilled.
             * @member {Long} totalBytesBilled
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.totalBytesBilled = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BigqueryMetadata instance using the specified properties.
             * @function create
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata=} [properties] Properties to set
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata instance
             */
            BigqueryMetadata.create = function create(properties) {
                return new BigqueryMetadata(properties);
            };

            /**
             * Encodes the specified BigqueryMetadata message. Does not implicitly {@link dataform.ExecutionMetadata.BigqueryMetadata.verify|verify} messages.
             * @function encode
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata} message BigqueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigqueryMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.jobId);
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalBytesProcessed);
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalBytesBilled);
                return writer;
            };

            /**
             * Encodes the specified BigqueryMetadata message, length delimited. Does not implicitly {@link dataform.ExecutionMetadata.BigqueryMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata} message BigqueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigqueryMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BigqueryMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigqueryMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionMetadata.BigqueryMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.jobId = reader.string();
                        break;
                    case 2:
                        message.totalBytesProcessed = reader.int64();
                        break;
                    case 3:
                        message.totalBytesBilled = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BigqueryMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigqueryMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BigqueryMetadata message.
             * @function verify
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BigqueryMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    if (!$util.isString(message.jobId))
                        return "jobId: string expected";
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    if (!$util.isInteger(message.totalBytesProcessed) && !(message.totalBytesProcessed && $util.isInteger(message.totalBytesProcessed.low) && $util.isInteger(message.totalBytesProcessed.high)))
                        return "totalBytesProcessed: integer|Long expected";
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    if (!$util.isInteger(message.totalBytesBilled) && !(message.totalBytesBilled && $util.isInteger(message.totalBytesBilled.low) && $util.isInteger(message.totalBytesBilled.high)))
                        return "totalBytesBilled: integer|Long expected";
                return null;
            };

            /**
             * Creates a BigqueryMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             */
            BigqueryMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ExecutionMetadata.BigqueryMetadata)
                    return object;
                let message = new $root.dataform.ExecutionMetadata.BigqueryMetadata();
                if (object.jobId != null)
                    message.jobId = String(object.jobId);
                if (object.totalBytesProcessed != null)
                    if ($util.Long)
                        (message.totalBytesProcessed = $util.Long.fromValue(object.totalBytesProcessed)).unsigned = false;
                    else if (typeof object.totalBytesProcessed === "string")
                        message.totalBytesProcessed = parseInt(object.totalBytesProcessed, 10);
                    else if (typeof object.totalBytesProcessed === "number")
                        message.totalBytesProcessed = object.totalBytesProcessed;
                    else if (typeof object.totalBytesProcessed === "object")
                        message.totalBytesProcessed = new $util.LongBits(object.totalBytesProcessed.low >>> 0, object.totalBytesProcessed.high >>> 0).toNumber();
                if (object.totalBytesBilled != null)
                    if ($util.Long)
                        (message.totalBytesBilled = $util.Long.fromValue(object.totalBytesBilled)).unsigned = false;
                    else if (typeof object.totalBytesBilled === "string")
                        message.totalBytesBilled = parseInt(object.totalBytesBilled, 10);
                    else if (typeof object.totalBytesBilled === "number")
                        message.totalBytesBilled = object.totalBytesBilled;
                    else if (typeof object.totalBytesBilled === "object")
                        message.totalBytesBilled = new $util.LongBits(object.totalBytesBilled.low >>> 0, object.totalBytesBilled.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BigqueryMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.BigqueryMetadata} message BigqueryMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BigqueryMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.jobId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.totalBytesProcessed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalBytesProcessed = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.totalBytesBilled = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalBytesBilled = options.longs === String ? "0" : 0;
                }
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    object.jobId = message.jobId;
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    if (typeof message.totalBytesProcessed === "number")
                        object.totalBytesProcessed = options.longs === String ? String(message.totalBytesProcessed) : message.totalBytesProcessed;
                    else
                        object.totalBytesProcessed = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytesProcessed) : options.longs === Number ? new $util.LongBits(message.totalBytesProcessed.low >>> 0, message.totalBytesProcessed.high >>> 0).toNumber() : message.totalBytesProcessed;
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    if (typeof message.totalBytesBilled === "number")
                        object.totalBytesBilled = options.longs === String ? String(message.totalBytesBilled) : message.totalBytesBilled;
                    else
                        object.totalBytesBilled = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytesBilled) : options.longs === Number ? new $util.LongBits(message.totalBytesBilled.low >>> 0, message.totalBytesBilled.high >>> 0).toNumber() : message.totalBytesBilled;
                return object;
            };

            /**
             * Converts this BigqueryMetadata to JSON.
             * @function toJSON
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BigqueryMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BigqueryMetadata;
        })();

        return ExecutionMetadata;
    })();

    dataform.TaskResult = (function() {

        /**
         * Properties of a TaskResult.
         * @memberof dataform
         * @interface ITaskResult
         * @property {dataform.TaskResult.ExecutionStatus|null} [status] TaskResult status
         * @property {string|null} [errorMessage] TaskResult errorMessage
         * @property {dataform.ITiming|null} [timing] TaskResult timing
         * @property {dataform.IExecutionMetadata|null} [metadata] TaskResult metadata
         */

        /**
         * Constructs a new TaskResult.
         * @memberof dataform
         * @classdesc Represents a TaskResult.
         * @implements ITaskResult
         * @constructor
         * @param {dataform.ITaskResult=} [properties] Properties to set
         */
        function TaskResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskResult status.
         * @member {dataform.TaskResult.ExecutionStatus} status
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.status = 0;

        /**
         * TaskResult errorMessage.
         * @member {string} errorMessage
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.errorMessage = "";

        /**
         * TaskResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.timing = null;

        /**
         * TaskResult metadata.
         * @member {dataform.IExecutionMetadata|null|undefined} metadata
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.metadata = null;

        /**
         * Creates a new TaskResult instance using the specified properties.
         * @function create
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult=} [properties] Properties to set
         * @returns {dataform.TaskResult} TaskResult instance
         */
        TaskResult.create = function create(properties) {
            return new TaskResult(properties);
        };

        /**
         * Encodes the specified TaskResult message. Does not implicitly {@link dataform.TaskResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
            if (message.timing != null && message.hasOwnProperty("timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.dataform.ExecutionMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TaskResult message, length delimited. Does not implicitly {@link dataform.TaskResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TaskResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.errorMessage = reader.string();
                    break;
                case 3:
                    message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.metadata = $root.dataform.ExecutionMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskResult message.
         * @function verify
         * @memberof dataform.TaskResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                let error = $root.dataform.ExecutionMetadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            return null;
        };

        /**
         * Creates a TaskResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TaskResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TaskResult} TaskResult
         */
        TaskResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TaskResult)
                return object;
            let message = new $root.dataform.TaskResult();
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "SKIPPED":
            case 4:
                message.status = 4;
                break;
            case "CANCELLED":
            case 5:
                message.status = 5;
                break;
            }
            if (object.errorMessage != null)
                message.errorMessage = String(object.errorMessage);
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.TaskResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".dataform.TaskResult.metadata: object expected");
                message.metadata = $root.dataform.ExecutionMetadata.fromObject(object.metadata);
            }
            return message;
        };

        /**
         * Creates a plain object from a TaskResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.TaskResult} message TaskResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.errorMessage = "";
                object.timing = null;
                object.metadata = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.TaskResult.ExecutionStatus[message.status] : message.status;
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                object.errorMessage = message.errorMessage;
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.dataform.ExecutionMetadata.toObject(message.metadata, options);
            return object;
        };

        /**
         * Converts this TaskResult to JSON.
         * @function toJSON
         * @memberof dataform.TaskResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.TaskResult.ExecutionStatus
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SKIPPED=4 SKIPPED value
         * @property {number} CANCELLED=5 CANCELLED value
         */
        TaskResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SKIPPED"] = 4;
            values[valuesById[5] = "CANCELLED"] = 5;
            return values;
        })();

        return TaskResult;
    })();

    dataform.TestResult = (function() {

        /**
         * Properties of a TestResult.
         * @memberof dataform
         * @interface ITestResult
         * @property {string|null} [name] TestResult name
         * @property {boolean|null} [successful] TestResult successful
         * @property {Array.<string>|null} [messages] TestResult messages
         */

        /**
         * Constructs a new TestResult.
         * @memberof dataform
         * @classdesc Represents a TestResult.
         * @implements ITestResult
         * @constructor
         * @param {dataform.ITestResult=} [properties] Properties to set
         */
        function TestResult(properties) {
            this.messages = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestResult name.
         * @member {string} name
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.name = "";

        /**
         * TestResult successful.
         * @member {boolean} successful
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.successful = false;

        /**
         * TestResult messages.
         * @member {Array.<string>} messages
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.messages = $util.emptyArray;

        /**
         * Creates a new TestResult instance using the specified properties.
         * @function create
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult=} [properties] Properties to set
         * @returns {dataform.TestResult} TestResult instance
         */
        TestResult.create = function create(properties) {
            return new TestResult(properties);
        };

        /**
         * Encodes the specified TestResult message. Does not implicitly {@link dataform.TestResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult} message TestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.successful != null && message.hasOwnProperty("successful"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.successful);
            if (message.messages != null && message.messages.length)
                for (let i = 0; i < message.messages.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.messages[i]);
            return writer;
        };

        /**
         * Encodes the specified TestResult message, length delimited. Does not implicitly {@link dataform.TestResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult} message TestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TestResult} TestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TestResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.successful = reader.bool();
                    break;
                case 3:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TestResult} TestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestResult message.
         * @function verify
         * @memberof dataform.TestResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.successful != null && message.hasOwnProperty("successful"))
                if (typeof message.successful !== "boolean")
                    return "successful: boolean expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (let i = 0; i < message.messages.length; ++i)
                    if (!$util.isString(message.messages[i]))
                        return "messages: string[] expected";
            }
            return null;
        };

        /**
         * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TestResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TestResult} TestResult
         */
        TestResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TestResult)
                return object;
            let message = new $root.dataform.TestResult();
            if (object.name != null)
                message.name = String(object.name);
            if (object.successful != null)
                message.successful = Boolean(object.successful);
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".dataform.TestResult.messages: array expected");
                message.messages = [];
                for (let i = 0; i < object.messages.length; ++i)
                    message.messages[i] = String(object.messages[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.TestResult} message TestResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (options.defaults) {
                object.name = "";
                object.successful = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.successful != null && message.hasOwnProperty("successful"))
                object.successful = message.successful;
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (let j = 0; j < message.messages.length; ++j)
                    object.messages[j] = message.messages[j];
            }
            return object;
        };

        /**
         * Converts this TestResult to JSON.
         * @function toJSON
         * @memberof dataform.TestResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestResult;
    })();

    dataform.Field = (function() {

        /**
         * Properties of a Field.
         * @memberof dataform
         * @interface IField
         * @property {string|null} [name] Field name
         * @property {Array.<dataform.Field.Flag>|null} [flags] Field flags
         * @property {dataform.Field.Primitive|null} [primitive] Field primitive
         * @property {dataform.IFields|null} [struct] Field struct
         * @property {string|null} [description] Field description
         * @property {Array.<string>|null} [flagsDeprecated] Field flagsDeprecated
         */

        /**
         * Constructs a new Field.
         * @memberof dataform
         * @classdesc Represents a Field.
         * @implements IField
         * @constructor
         * @param {dataform.IField=} [properties] Properties to set
         */
        function Field(properties) {
            this.flags = [];
            this.flagsDeprecated = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Field name.
         * @member {string} name
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.name = "";

        /**
         * Field flags.
         * @member {Array.<dataform.Field.Flag>} flags
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.flags = $util.emptyArray;

        /**
         * Field primitive.
         * @member {dataform.Field.Primitive} primitive
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.primitive = 0;

        /**
         * Field struct.
         * @member {dataform.IFields|null|undefined} struct
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.struct = null;

        /**
         * Field description.
         * @member {string} description
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.description = "";

        /**
         * Field flagsDeprecated.
         * @member {Array.<string>} flagsDeprecated
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.flagsDeprecated = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Field type.
         * @member {"primitive"|"struct"|undefined} type
         * @memberof dataform.Field
         * @instance
         */
        Object.defineProperty(Field.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["primitive", "struct"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Field instance using the specified properties.
         * @function create
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField=} [properties] Properties to set
         * @returns {dataform.Field} Field instance
         */
        Field.create = function create(properties) {
            return new Field(properties);
        };

        /**
         * Encodes the specified Field message. Does not implicitly {@link dataform.Field.verify|verify} messages.
         * @function encode
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.struct != null && message.hasOwnProperty("struct"))
                $root.dataform.Fields.encode(message.struct, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.flagsDeprecated != null && message.flagsDeprecated.length)
                for (let i = 0; i < message.flagsDeprecated.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.flagsDeprecated[i]);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.flags != null && message.flags.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (let i = 0; i < message.flags.length; ++i)
                    writer.int32(message.flags[i]);
                writer.ldelim();
            }
            if (message.primitive != null && message.hasOwnProperty("primitive"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.primitive);
            return writer;
        };

        /**
         * Encodes the specified Field message, length delimited. Does not implicitly {@link dataform.Field.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Field message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Field();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 6:
                    if (!(message.flags && message.flags.length))
                        message.flags = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.flags.push(reader.int32());
                    } else
                        message.flags.push(reader.int32());
                    break;
                case 7:
                    message.primitive = reader.int32();
                    break;
                case 3:
                    message.struct = $root.dataform.Fields.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                case 4:
                    if (!(message.flagsDeprecated && message.flagsDeprecated.length))
                        message.flagsDeprecated = [];
                    message.flagsDeprecated.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Field message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Field message.
         * @function verify
         * @memberof dataform.Field
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Field.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (let i = 0; i < message.flags.length; ++i)
                    switch (message.flags[i]) {
                    default:
                        return "flags: enum value[] expected";
                    case 0:
                    case 1:
                        break;
                    }
            }
            if (message.primitive != null && message.hasOwnProperty("primitive")) {
                properties.type = 1;
                switch (message.primitive) {
                default:
                    return "primitive: enum value expected";
                case 0:
                case 1:
                case 2:
                case 5:
                case 3:
                case 4:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            }
            if (message.struct != null && message.hasOwnProperty("struct")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.dataform.Fields.verify(message.struct);
                    if (error)
                        return "struct." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.flagsDeprecated != null && message.hasOwnProperty("flagsDeprecated")) {
                if (!Array.isArray(message.flagsDeprecated))
                    return "flagsDeprecated: array expected";
                for (let i = 0; i < message.flagsDeprecated.length; ++i)
                    if (!$util.isString(message.flagsDeprecated[i]))
                        return "flagsDeprecated: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Field message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Field
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Field} Field
         */
        Field.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Field)
                return object;
            let message = new $root.dataform.Field();
            if (object.name != null)
                message.name = String(object.name);
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".dataform.Field.flags: array expected");
                message.flags = [];
                for (let i = 0; i < object.flags.length; ++i)
                    switch (object.flags[i]) {
                    default:
                    case "UNKNOWN_FLAG":
                    case 0:
                        message.flags[i] = 0;
                        break;
                    case "REPEATED":
                    case 1:
                        message.flags[i] = 1;
                        break;
                    }
            }
            switch (object.primitive) {
            case "UNKNOWN":
            case 0:
                message.primitive = 0;
                break;
            case "INTEGER":
            case 1:
                message.primitive = 1;
                break;
            case "FLOAT":
            case 2:
                message.primitive = 2;
                break;
            case "NUMERIC":
            case 5:
                message.primitive = 5;
                break;
            case "BOOLEAN":
            case 3:
                message.primitive = 3;
                break;
            case "STRING":
            case 4:
                message.primitive = 4;
                break;
            case "DATE":
            case 6:
                message.primitive = 6;
                break;
            case "DATETIME":
            case 7:
                message.primitive = 7;
                break;
            case "TIMESTAMP":
            case 8:
                message.primitive = 8;
                break;
            case "TIME":
            case 9:
                message.primitive = 9;
                break;
            case "BYTES":
            case 10:
                message.primitive = 10;
                break;
            case "ANY":
            case 11:
                message.primitive = 11;
                break;
            case "GEOGRAPHY":
            case 12:
                message.primitive = 12;
                break;
            }
            if (object.struct != null) {
                if (typeof object.struct !== "object")
                    throw TypeError(".dataform.Field.struct: object expected");
                message.struct = $root.dataform.Fields.fromObject(object.struct);
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.flagsDeprecated) {
                if (!Array.isArray(object.flagsDeprecated))
                    throw TypeError(".dataform.Field.flagsDeprecated: array expected");
                message.flagsDeprecated = [];
                for (let i = 0; i < object.flagsDeprecated.length; ++i)
                    message.flagsDeprecated[i] = String(object.flagsDeprecated[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Field message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Field
         * @static
         * @param {dataform.Field} message Field
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Field.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.flagsDeprecated = [];
                object.flags = [];
            }
            if (options.defaults) {
                object.name = "";
                object.description = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.struct != null && message.hasOwnProperty("struct")) {
                object.struct = $root.dataform.Fields.toObject(message.struct, options);
                if (options.oneofs)
                    object.type = "struct";
            }
            if (message.flagsDeprecated && message.flagsDeprecated.length) {
                object.flagsDeprecated = [];
                for (let j = 0; j < message.flagsDeprecated.length; ++j)
                    object.flagsDeprecated[j] = message.flagsDeprecated[j];
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (let j = 0; j < message.flags.length; ++j)
                    object.flags[j] = options.enums === String ? $root.dataform.Field.Flag[message.flags[j]] : message.flags[j];
            }
            if (message.primitive != null && message.hasOwnProperty("primitive")) {
                object.primitive = options.enums === String ? $root.dataform.Field.Primitive[message.primitive] : message.primitive;
                if (options.oneofs)
                    object.type = "primitive";
            }
            return object;
        };

        /**
         * Converts this Field to JSON.
         * @function toJSON
         * @memberof dataform.Field
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Field.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Primitive enum.
         * @name dataform.Field.Primitive
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} INTEGER=1 INTEGER value
         * @property {number} FLOAT=2 FLOAT value
         * @property {number} NUMERIC=5 NUMERIC value
         * @property {number} BOOLEAN=3 BOOLEAN value
         * @property {number} STRING=4 STRING value
         * @property {number} DATE=6 DATE value
         * @property {number} DATETIME=7 DATETIME value
         * @property {number} TIMESTAMP=8 TIMESTAMP value
         * @property {number} TIME=9 TIME value
         * @property {number} BYTES=10 BYTES value
         * @property {number} ANY=11 ANY value
         * @property {number} GEOGRAPHY=12 GEOGRAPHY value
         */
        Field.Primitive = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "INTEGER"] = 1;
            values[valuesById[2] = "FLOAT"] = 2;
            values[valuesById[5] = "NUMERIC"] = 5;
            values[valuesById[3] = "BOOLEAN"] = 3;
            values[valuesById[4] = "STRING"] = 4;
            values[valuesById[6] = "DATE"] = 6;
            values[valuesById[7] = "DATETIME"] = 7;
            values[valuesById[8] = "TIMESTAMP"] = 8;
            values[valuesById[9] = "TIME"] = 9;
            values[valuesById[10] = "BYTES"] = 10;
            values[valuesById[11] = "ANY"] = 11;
            values[valuesById[12] = "GEOGRAPHY"] = 12;
            return values;
        })();

        /**
         * Flag enum.
         * @name dataform.Field.Flag
         * @enum {string}
         * @property {number} UNKNOWN_FLAG=0 UNKNOWN_FLAG value
         * @property {number} REPEATED=1 REPEATED value
         */
        Field.Flag = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_FLAG"] = 0;
            values[valuesById[1] = "REPEATED"] = 1;
            return values;
        })();

        return Field;
    })();

    dataform.Fields = (function() {

        /**
         * Properties of a Fields.
         * @memberof dataform
         * @interface IFields
         * @property {Array.<dataform.IField>|null} [fields] Fields fields
         */

        /**
         * Constructs a new Fields.
         * @memberof dataform
         * @classdesc Represents a Fields.
         * @implements IFields
         * @constructor
         * @param {dataform.IFields=} [properties] Properties to set
         */
        function Fields(properties) {
            this.fields = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fields fields.
         * @member {Array.<dataform.IField>} fields
         * @memberof dataform.Fields
         * @instance
         */
        Fields.prototype.fields = $util.emptyArray;

        /**
         * Creates a new Fields instance using the specified properties.
         * @function create
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields=} [properties] Properties to set
         * @returns {dataform.Fields} Fields instance
         */
        Fields.create = function create(properties) {
            return new Fields(properties);
        };

        /**
         * Encodes the specified Fields message. Does not implicitly {@link dataform.Fields.verify|verify} messages.
         * @function encode
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields} message Fields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fields != null && message.fields.length)
                for (let i = 0; i < message.fields.length; ++i)
                    $root.dataform.Field.encode(message.fields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Fields message, length delimited. Does not implicitly {@link dataform.Fields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields} message Fields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fields message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Fields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Fields} Fields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Fields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.dataform.Field.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Fields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Fields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Fields} Fields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fields message.
         * @function verify
         * @memberof dataform.Fields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (let i = 0; i < message.fields.length; ++i) {
                    let error = $root.dataform.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Fields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Fields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Fields} Fields
         */
        Fields.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Fields)
                return object;
            let message = new $root.dataform.Fields();
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".dataform.Fields.fields: array expected");
                message.fields = [];
                for (let i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".dataform.Fields.fields: object expected");
                    message.fields[i] = $root.dataform.Field.fromObject(object.fields[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Fields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Fields
         * @static
         * @param {dataform.Fields} message Fields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (let j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.dataform.Field.toObject(message.fields[j], options);
            }
            return object;
        };

        /**
         * Converts this Fields to JSON.
         * @function toJSON
         * @memberof dataform.Fields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fields;
    })();

    dataform.TableMetadata = (function() {

        /**
         * Properties of a TableMetadata.
         * @memberof dataform
         * @interface ITableMetadata
         * @property {dataform.ITarget|null} [target] TableMetadata target
         * @property {dataform.TableMetadata.Type|null} [type] TableMetadata type
         * @property {Array.<dataform.IField>|null} [fields] TableMetadata fields
         * @property {string|null} [description] TableMetadata description
         * @property {Object.<string,string>|null} [labels] TableMetadata labels
         * @property {Long|null} [lastUpdatedMillis] TableMetadata lastUpdatedMillis
         * @property {dataform.TableMetadata.IBigQuery|null} [bigquery] TableMetadata bigquery
         * @property {string|null} [typeDeprecated] TableMetadata typeDeprecated
         */

        /**
         * Constructs a new TableMetadata.
         * @memberof dataform
         * @classdesc Represents a TableMetadata.
         * @implements ITableMetadata
         * @constructor
         * @param {dataform.ITableMetadata=} [properties] Properties to set
         */
        function TableMetadata(properties) {
            this.fields = [];
            this.labels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TableMetadata target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.target = null;

        /**
         * TableMetadata type.
         * @member {dataform.TableMetadata.Type} type
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.type = 0;

        /**
         * TableMetadata fields.
         * @member {Array.<dataform.IField>} fields
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.fields = $util.emptyArray;

        /**
         * TableMetadata description.
         * @member {string} description
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.description = "";

        /**
         * TableMetadata labels.
         * @member {Object.<string,string>} labels
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.labels = $util.emptyObject;

        /**
         * TableMetadata lastUpdatedMillis.
         * @member {Long} lastUpdatedMillis
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.lastUpdatedMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TableMetadata bigquery.
         * @member {dataform.TableMetadata.IBigQuery|null|undefined} bigquery
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.bigquery = null;

        /**
         * TableMetadata typeDeprecated.
         * @member {string} typeDeprecated
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.typeDeprecated = "";

        /**
         * Creates a new TableMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata=} [properties] Properties to set
         * @returns {dataform.TableMetadata} TableMetadata instance
         */
        TableMetadata.create = function create(properties) {
            return new TableMetadata(properties);
        };

        /**
         * Encodes the specified TableMetadata message. Does not implicitly {@link dataform.TableMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata} message TableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.typeDeprecated != null && message.hasOwnProperty("typeDeprecated"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeDeprecated);
            if (message.fields != null && message.fields.length)
                for (let i = 0; i < message.fields.length; ++i)
                    $root.dataform.Field.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lastUpdatedMillis);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            if (message.labels != null && message.hasOwnProperty("labels"))
                for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                $root.dataform.TableMetadata.BigQuery.encode(message.bigquery, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TableMetadata message, length delimited. Does not implicitly {@link dataform.TableMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata} message TableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TableMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TableMetadata} TableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TableMetadata(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                case 3:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.dataform.Field.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                case 7:
                    reader.skip().pos++;
                    if (message.labels === $util.emptyObject)
                        message.labels = {};
                    key = reader.string();
                    reader.pos++;
                    message.labels[key] = reader.string();
                    break;
                case 4:
                    message.lastUpdatedMillis = reader.int64();
                    break;
                case 8:
                    message.bigquery = $root.dataform.TableMetadata.BigQuery.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.typeDeprecated = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TableMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TableMetadata} TableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TableMetadata message.
         * @function verify
         * @memberof dataform.TableMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TableMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (let i = 0; i < message.fields.length; ++i) {
                    let error = $root.dataform.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!$util.isObject(message.labels))
                    return "labels: object expected";
                let key = Object.keys(message.labels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.labels[key[i]]))
                        return "labels: string{k:string} expected";
            }
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (!$util.isInteger(message.lastUpdatedMillis) && !(message.lastUpdatedMillis && $util.isInteger(message.lastUpdatedMillis.low) && $util.isInteger(message.lastUpdatedMillis.high)))
                    return "lastUpdatedMillis: integer|Long expected";
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.TableMetadata.BigQuery.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            if (message.typeDeprecated != null && message.hasOwnProperty("typeDeprecated"))
                if (!$util.isString(message.typeDeprecated))
                    return "typeDeprecated: string expected";
            return null;
        };

        /**
         * Creates a TableMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TableMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TableMetadata} TableMetadata
         */
        TableMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TableMetadata)
                return object;
            let message = new $root.dataform.TableMetadata();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.TableMetadata.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "TABLE":
            case 1:
                message.type = 1;
                break;
            case "VIEW":
            case 2:
                message.type = 2;
                break;
            }
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".dataform.TableMetadata.fields: array expected");
                message.fields = [];
                for (let i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".dataform.TableMetadata.fields: object expected");
                    message.fields[i] = $root.dataform.Field.fromObject(object.fields[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.labels) {
                if (typeof object.labels !== "object")
                    throw TypeError(".dataform.TableMetadata.labels: object expected");
                message.labels = {};
                for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                    message.labels[keys[i]] = String(object.labels[keys[i]]);
            }
            if (object.lastUpdatedMillis != null)
                if ($util.Long)
                    (message.lastUpdatedMillis = $util.Long.fromValue(object.lastUpdatedMillis)).unsigned = false;
                else if (typeof object.lastUpdatedMillis === "string")
                    message.lastUpdatedMillis = parseInt(object.lastUpdatedMillis, 10);
                else if (typeof object.lastUpdatedMillis === "number")
                    message.lastUpdatedMillis = object.lastUpdatedMillis;
                else if (typeof object.lastUpdatedMillis === "object")
                    message.lastUpdatedMillis = new $util.LongBits(object.lastUpdatedMillis.low >>> 0, object.lastUpdatedMillis.high >>> 0).toNumber();
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.TableMetadata.bigquery: object expected");
                message.bigquery = $root.dataform.TableMetadata.BigQuery.fromObject(object.bigquery);
            }
            if (object.typeDeprecated != null)
                message.typeDeprecated = String(object.typeDeprecated);
            return message;
        };

        /**
         * Creates a plain object from a TableMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.TableMetadata} message TableMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TableMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (options.objects || options.defaults)
                object.labels = {};
            if (options.defaults) {
                object.target = null;
                object.typeDeprecated = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lastUpdatedMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastUpdatedMillis = options.longs === String ? "0" : 0;
                object.description = "";
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.bigquery = null;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.typeDeprecated != null && message.hasOwnProperty("typeDeprecated"))
                object.typeDeprecated = message.typeDeprecated;
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (let j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.dataform.Field.toObject(message.fields[j], options);
            }
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (typeof message.lastUpdatedMillis === "number")
                    object.lastUpdatedMillis = options.longs === String ? String(message.lastUpdatedMillis) : message.lastUpdatedMillis;
                else
                    object.lastUpdatedMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdatedMillis) : options.longs === Number ? new $util.LongBits(message.lastUpdatedMillis.low >>> 0, message.lastUpdatedMillis.high >>> 0).toNumber() : message.lastUpdatedMillis;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.dataform.TableMetadata.Type[message.type] : message.type;
            let keys2;
            if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                object.labels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.labels[keys2[j]] = message.labels[keys2[j]];
            }
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.TableMetadata.BigQuery.toObject(message.bigquery, options);
            return object;
        };

        /**
         * Converts this TableMetadata to JSON.
         * @function toJSON
         * @memberof dataform.TableMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TableMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name dataform.TableMetadata.Type
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} TABLE=1 TABLE value
         * @property {number} VIEW=2 VIEW value
         */
        TableMetadata.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "TABLE"] = 1;
            values[valuesById[2] = "VIEW"] = 2;
            return values;
        })();

        TableMetadata.BigQuery = (function() {

            /**
             * Properties of a BigQuery.
             * @memberof dataform.TableMetadata
             * @interface IBigQuery
             * @property {boolean|null} [hasStreamingBuffer] BigQuery hasStreamingBuffer
             */

            /**
             * Constructs a new BigQuery.
             * @memberof dataform.TableMetadata
             * @classdesc Represents a BigQuery.
             * @implements IBigQuery
             * @constructor
             * @param {dataform.TableMetadata.IBigQuery=} [properties] Properties to set
             */
            function BigQuery(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BigQuery hasStreamingBuffer.
             * @member {boolean} hasStreamingBuffer
             * @memberof dataform.TableMetadata.BigQuery
             * @instance
             */
            BigQuery.prototype.hasStreamingBuffer = false;

            /**
             * Creates a new BigQuery instance using the specified properties.
             * @function create
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery=} [properties] Properties to set
             * @returns {dataform.TableMetadata.BigQuery} BigQuery instance
             */
            BigQuery.create = function create(properties) {
                return new BigQuery(properties);
            };

            /**
             * Encodes the specified BigQuery message. Does not implicitly {@link dataform.TableMetadata.BigQuery.verify|verify} messages.
             * @function encode
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery} message BigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hasStreamingBuffer);
                return writer;
            };

            /**
             * Encodes the specified BigQuery message, length delimited. Does not implicitly {@link dataform.TableMetadata.BigQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery} message BigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BigQuery message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TableMetadata.BigQuery();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hasStreamingBuffer = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BigQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BigQuery message.
             * @function verify
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BigQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    if (typeof message.hasStreamingBuffer !== "boolean")
                        return "hasStreamingBuffer: boolean expected";
                return null;
            };

            /**
             * Creates a BigQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             */
            BigQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.TableMetadata.BigQuery)
                    return object;
                let message = new $root.dataform.TableMetadata.BigQuery();
                if (object.hasStreamingBuffer != null)
                    message.hasStreamingBuffer = Boolean(object.hasStreamingBuffer);
                return message;
            };

            /**
             * Creates a plain object from a BigQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.BigQuery} message BigQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BigQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.hasStreamingBuffer = false;
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    object.hasStreamingBuffer = message.hasStreamingBuffer;
                return object;
            };

            /**
             * Converts this BigQuery to JSON.
             * @function toJSON
             * @memberof dataform.TableMetadata.BigQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BigQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BigQuery;
        })();

        return TableMetadata;
    })();

    dataform.PersistedTableMetadata = (function() {

        /**
         * Properties of a PersistedTableMetadata.
         * @memberof dataform
         * @interface IPersistedTableMetadata
         * @property {dataform.ITarget|null} [target] PersistedTableMetadata target
         * @property {string|null} [definitionHash] PersistedTableMetadata definitionHash
         * @property {Long|null} [lastUpdatedMillis] PersistedTableMetadata lastUpdatedMillis
         * @property {Array.<dataform.PersistedTableMetadata.ITransitiveInputMetadata>|null} [transitiveInputTables] PersistedTableMetadata transitiveInputTables
         */

        /**
         * Constructs a new PersistedTableMetadata.
         * @memberof dataform
         * @classdesc Represents a PersistedTableMetadata.
         * @implements IPersistedTableMetadata
         * @constructor
         * @param {dataform.IPersistedTableMetadata=} [properties] Properties to set
         */
        function PersistedTableMetadata(properties) {
            this.transitiveInputTables = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PersistedTableMetadata target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.PersistedTableMetadata
         * @instance
         */
        PersistedTableMetadata.prototype.target = null;

        /**
         * PersistedTableMetadata definitionHash.
         * @member {string} definitionHash
         * @memberof dataform.PersistedTableMetadata
         * @instance
         */
        PersistedTableMetadata.prototype.definitionHash = "";

        /**
         * PersistedTableMetadata lastUpdatedMillis.
         * @member {Long} lastUpdatedMillis
         * @memberof dataform.PersistedTableMetadata
         * @instance
         */
        PersistedTableMetadata.prototype.lastUpdatedMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PersistedTableMetadata transitiveInputTables.
         * @member {Array.<dataform.PersistedTableMetadata.ITransitiveInputMetadata>} transitiveInputTables
         * @memberof dataform.PersistedTableMetadata
         * @instance
         */
        PersistedTableMetadata.prototype.transitiveInputTables = $util.emptyArray;

        /**
         * Creates a new PersistedTableMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {dataform.IPersistedTableMetadata=} [properties] Properties to set
         * @returns {dataform.PersistedTableMetadata} PersistedTableMetadata instance
         */
        PersistedTableMetadata.create = function create(properties) {
            return new PersistedTableMetadata(properties);
        };

        /**
         * Encodes the specified PersistedTableMetadata message. Does not implicitly {@link dataform.PersistedTableMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {dataform.IPersistedTableMetadata} message PersistedTableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PersistedTableMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.definitionHash != null && message.hasOwnProperty("definitionHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.definitionHash);
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastUpdatedMillis);
            if (message.transitiveInputTables != null && message.transitiveInputTables.length)
                for (let i = 0; i < message.transitiveInputTables.length; ++i)
                    $root.dataform.PersistedTableMetadata.TransitiveInputMetadata.encode(message.transitiveInputTables[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PersistedTableMetadata message, length delimited. Does not implicitly {@link dataform.PersistedTableMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {dataform.IPersistedTableMetadata} message PersistedTableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PersistedTableMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PersistedTableMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.PersistedTableMetadata} PersistedTableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersistedTableMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.PersistedTableMetadata();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.definitionHash = reader.string();
                    break;
                case 3:
                    message.lastUpdatedMillis = reader.int64();
                    break;
                case 7:
                    if (!(message.transitiveInputTables && message.transitiveInputTables.length))
                        message.transitiveInputTables = [];
                    message.transitiveInputTables.push($root.dataform.PersistedTableMetadata.TransitiveInputMetadata.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PersistedTableMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.PersistedTableMetadata} PersistedTableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersistedTableMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PersistedTableMetadata message.
         * @function verify
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PersistedTableMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.definitionHash != null && message.hasOwnProperty("definitionHash"))
                if (!$util.isString(message.definitionHash))
                    return "definitionHash: string expected";
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (!$util.isInteger(message.lastUpdatedMillis) && !(message.lastUpdatedMillis && $util.isInteger(message.lastUpdatedMillis.low) && $util.isInteger(message.lastUpdatedMillis.high)))
                    return "lastUpdatedMillis: integer|Long expected";
            if (message.transitiveInputTables != null && message.hasOwnProperty("transitiveInputTables")) {
                if (!Array.isArray(message.transitiveInputTables))
                    return "transitiveInputTables: array expected";
                for (let i = 0; i < message.transitiveInputTables.length; ++i) {
                    let error = $root.dataform.PersistedTableMetadata.TransitiveInputMetadata.verify(message.transitiveInputTables[i]);
                    if (error)
                        return "transitiveInputTables." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PersistedTableMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.PersistedTableMetadata} PersistedTableMetadata
         */
        PersistedTableMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.PersistedTableMetadata)
                return object;
            let message = new $root.dataform.PersistedTableMetadata();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.PersistedTableMetadata.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.definitionHash != null)
                message.definitionHash = String(object.definitionHash);
            if (object.lastUpdatedMillis != null)
                if ($util.Long)
                    (message.lastUpdatedMillis = $util.Long.fromValue(object.lastUpdatedMillis)).unsigned = false;
                else if (typeof object.lastUpdatedMillis === "string")
                    message.lastUpdatedMillis = parseInt(object.lastUpdatedMillis, 10);
                else if (typeof object.lastUpdatedMillis === "number")
                    message.lastUpdatedMillis = object.lastUpdatedMillis;
                else if (typeof object.lastUpdatedMillis === "object")
                    message.lastUpdatedMillis = new $util.LongBits(object.lastUpdatedMillis.low >>> 0, object.lastUpdatedMillis.high >>> 0).toNumber();
            if (object.transitiveInputTables) {
                if (!Array.isArray(object.transitiveInputTables))
                    throw TypeError(".dataform.PersistedTableMetadata.transitiveInputTables: array expected");
                message.transitiveInputTables = [];
                for (let i = 0; i < object.transitiveInputTables.length; ++i) {
                    if (typeof object.transitiveInputTables[i] !== "object")
                        throw TypeError(".dataform.PersistedTableMetadata.transitiveInputTables: object expected");
                    message.transitiveInputTables[i] = $root.dataform.PersistedTableMetadata.TransitiveInputMetadata.fromObject(object.transitiveInputTables[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PersistedTableMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {dataform.PersistedTableMetadata} message PersistedTableMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PersistedTableMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.transitiveInputTables = [];
            if (options.defaults) {
                object.target = null;
                object.definitionHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lastUpdatedMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastUpdatedMillis = options.longs === String ? "0" : 0;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.definitionHash != null && message.hasOwnProperty("definitionHash"))
                object.definitionHash = message.definitionHash;
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (typeof message.lastUpdatedMillis === "number")
                    object.lastUpdatedMillis = options.longs === String ? String(message.lastUpdatedMillis) : message.lastUpdatedMillis;
                else
                    object.lastUpdatedMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdatedMillis) : options.longs === Number ? new $util.LongBits(message.lastUpdatedMillis.low >>> 0, message.lastUpdatedMillis.high >>> 0).toNumber() : message.lastUpdatedMillis;
            if (message.transitiveInputTables && message.transitiveInputTables.length) {
                object.transitiveInputTables = [];
                for (let j = 0; j < message.transitiveInputTables.length; ++j)
                    object.transitiveInputTables[j] = $root.dataform.PersistedTableMetadata.TransitiveInputMetadata.toObject(message.transitiveInputTables[j], options);
            }
            return object;
        };

        /**
         * Converts this PersistedTableMetadata to JSON.
         * @function toJSON
         * @memberof dataform.PersistedTableMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PersistedTableMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        PersistedTableMetadata.TransitiveInputMetadata = (function() {

            /**
             * Properties of a TransitiveInputMetadata.
             * @memberof dataform.PersistedTableMetadata
             * @interface ITransitiveInputMetadata
             * @property {dataform.ITarget|null} [target] TransitiveInputMetadata target
             * @property {Long|null} [lastUpdatedMillis] TransitiveInputMetadata lastUpdatedMillis
             */

            /**
             * Constructs a new TransitiveInputMetadata.
             * @memberof dataform.PersistedTableMetadata
             * @classdesc Represents a TransitiveInputMetadata.
             * @implements ITransitiveInputMetadata
             * @constructor
             * @param {dataform.PersistedTableMetadata.ITransitiveInputMetadata=} [properties] Properties to set
             */
            function TransitiveInputMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransitiveInputMetadata target.
             * @member {dataform.ITarget|null|undefined} target
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @instance
             */
            TransitiveInputMetadata.prototype.target = null;

            /**
             * TransitiveInputMetadata lastUpdatedMillis.
             * @member {Long} lastUpdatedMillis
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @instance
             */
            TransitiveInputMetadata.prototype.lastUpdatedMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new TransitiveInputMetadata instance using the specified properties.
             * @function create
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {dataform.PersistedTableMetadata.ITransitiveInputMetadata=} [properties] Properties to set
             * @returns {dataform.PersistedTableMetadata.TransitiveInputMetadata} TransitiveInputMetadata instance
             */
            TransitiveInputMetadata.create = function create(properties) {
                return new TransitiveInputMetadata(properties);
            };

            /**
             * Encodes the specified TransitiveInputMetadata message. Does not implicitly {@link dataform.PersistedTableMetadata.TransitiveInputMetadata.verify|verify} messages.
             * @function encode
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {dataform.PersistedTableMetadata.ITransitiveInputMetadata} message TransitiveInputMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransitiveInputMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && message.hasOwnProperty("target"))
                    $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastUpdatedMillis);
                return writer;
            };

            /**
             * Encodes the specified TransitiveInputMetadata message, length delimited. Does not implicitly {@link dataform.PersistedTableMetadata.TransitiveInputMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {dataform.PersistedTableMetadata.ITransitiveInputMetadata} message TransitiveInputMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransitiveInputMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransitiveInputMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.PersistedTableMetadata.TransitiveInputMetadata} TransitiveInputMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransitiveInputMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.PersistedTableMetadata.TransitiveInputMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.lastUpdatedMillis = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransitiveInputMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.PersistedTableMetadata.TransitiveInputMetadata} TransitiveInputMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransitiveInputMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransitiveInputMetadata message.
             * @function verify
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransitiveInputMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target")) {
                    let error = $root.dataform.Target.verify(message.target);
                    if (error)
                        return "target." + error;
                }
                if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                    if (!$util.isInteger(message.lastUpdatedMillis) && !(message.lastUpdatedMillis && $util.isInteger(message.lastUpdatedMillis.low) && $util.isInteger(message.lastUpdatedMillis.high)))
                        return "lastUpdatedMillis: integer|Long expected";
                return null;
            };

            /**
             * Creates a TransitiveInputMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.PersistedTableMetadata.TransitiveInputMetadata} TransitiveInputMetadata
             */
            TransitiveInputMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.PersistedTableMetadata.TransitiveInputMetadata)
                    return object;
                let message = new $root.dataform.PersistedTableMetadata.TransitiveInputMetadata();
                if (object.target != null) {
                    if (typeof object.target !== "object")
                        throw TypeError(".dataform.PersistedTableMetadata.TransitiveInputMetadata.target: object expected");
                    message.target = $root.dataform.Target.fromObject(object.target);
                }
                if (object.lastUpdatedMillis != null)
                    if ($util.Long)
                        (message.lastUpdatedMillis = $util.Long.fromValue(object.lastUpdatedMillis)).unsigned = false;
                    else if (typeof object.lastUpdatedMillis === "string")
                        message.lastUpdatedMillis = parseInt(object.lastUpdatedMillis, 10);
                    else if (typeof object.lastUpdatedMillis === "number")
                        message.lastUpdatedMillis = object.lastUpdatedMillis;
                    else if (typeof object.lastUpdatedMillis === "object")
                        message.lastUpdatedMillis = new $util.LongBits(object.lastUpdatedMillis.low >>> 0, object.lastUpdatedMillis.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a TransitiveInputMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {dataform.PersistedTableMetadata.TransitiveInputMetadata} message TransitiveInputMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransitiveInputMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.target = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.lastUpdatedMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastUpdatedMillis = options.longs === String ? "0" : 0;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    object.target = $root.dataform.Target.toObject(message.target, options);
                if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                    if (typeof message.lastUpdatedMillis === "number")
                        object.lastUpdatedMillis = options.longs === String ? String(message.lastUpdatedMillis) : message.lastUpdatedMillis;
                    else
                        object.lastUpdatedMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdatedMillis) : options.longs === Number ? new $util.LongBits(message.lastUpdatedMillis.low >>> 0, message.lastUpdatedMillis.high >>> 0).toNumber() : message.lastUpdatedMillis;
                return object;
            };

            /**
             * Converts this TransitiveInputMetadata to JSON.
             * @function toJSON
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransitiveInputMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransitiveInputMetadata;
        })();

        return PersistedTableMetadata;
    })();

    dataform.JDBC = (function() {

        /**
         * Properties of a JDBC.
         * @memberof dataform
         * @interface IJDBC
         * @property {string|null} [host] JDBC host
         * @property {number|null} [port] JDBC port
         * @property {string|null} [username] JDBC username
         * @property {string|null} [password] JDBC password
         * @property {string|null} [databaseName] JDBC databaseName
         * @property {dataform.JDBC.ISslConfiguration|null} [ssl] JDBC ssl
         * @property {dataform.JDBC.ISshTunnel|null} [sshTunnel] JDBC sshTunnel
         */

        /**
         * Constructs a new JDBC.
         * @memberof dataform
         * @classdesc Represents a JDBC.
         * @implements IJDBC
         * @constructor
         * @param {dataform.IJDBC=} [properties] Properties to set
         */
        function JDBC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JDBC host.
         * @member {string} host
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.host = "";

        /**
         * JDBC port.
         * @member {number} port
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.port = 0;

        /**
         * JDBC username.
         * @member {string} username
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.username = "";

        /**
         * JDBC password.
         * @member {string} password
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.password = "";

        /**
         * JDBC databaseName.
         * @member {string} databaseName
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.databaseName = "";

        /**
         * JDBC ssl.
         * @member {dataform.JDBC.ISslConfiguration|null|undefined} ssl
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.ssl = null;

        /**
         * JDBC sshTunnel.
         * @member {dataform.JDBC.ISshTunnel|null|undefined} sshTunnel
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.sshTunnel = null;

        /**
         * Creates a new JDBC instance using the specified properties.
         * @function create
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC=} [properties] Properties to set
         * @returns {dataform.JDBC} JDBC instance
         */
        JDBC.create = function create(properties) {
            return new JDBC(properties);
        };

        /**
         * Encodes the specified JDBC message. Does not implicitly {@link dataform.JDBC.verify|verify} messages.
         * @function encode
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC} message JDBC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JDBC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && message.hasOwnProperty("host"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
            if (message.port != null && message.hasOwnProperty("port"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.port);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.username);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.databaseName);
            if (message.sshTunnel != null && message.hasOwnProperty("sshTunnel"))
                $root.dataform.JDBC.SshTunnel.encode(message.sshTunnel, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.ssl != null && message.hasOwnProperty("ssl"))
                $root.dataform.JDBC.SslConfiguration.encode(message.ssl, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified JDBC message, length delimited. Does not implicitly {@link dataform.JDBC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC} message JDBC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JDBC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JDBC message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.JDBC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.JDBC} JDBC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JDBC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.host = reader.string();
                    break;
                case 3:
                    message.port = reader.int32();
                    break;
                case 4:
                    message.username = reader.string();
                    break;
                case 5:
                    message.password = reader.string();
                    break;
                case 6:
                    message.databaseName = reader.string();
                    break;
                case 8:
                    message.ssl = $root.dataform.JDBC.SslConfiguration.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.sshTunnel = $root.dataform.JDBC.SshTunnel.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JDBC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.JDBC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.JDBC} JDBC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JDBC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JDBC message.
         * @function verify
         * @memberof dataform.JDBC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JDBC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                if (!$util.isString(message.databaseName))
                    return "databaseName: string expected";
            if (message.ssl != null && message.hasOwnProperty("ssl")) {
                let error = $root.dataform.JDBC.SslConfiguration.verify(message.ssl);
                if (error)
                    return "ssl." + error;
            }
            if (message.sshTunnel != null && message.hasOwnProperty("sshTunnel")) {
                let error = $root.dataform.JDBC.SshTunnel.verify(message.sshTunnel);
                if (error)
                    return "sshTunnel." + error;
            }
            return null;
        };

        /**
         * Creates a JDBC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.JDBC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.JDBC} JDBC
         */
        JDBC.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.JDBC)
                return object;
            let message = new $root.dataform.JDBC();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.databaseName != null)
                message.databaseName = String(object.databaseName);
            if (object.ssl != null) {
                if (typeof object.ssl !== "object")
                    throw TypeError(".dataform.JDBC.ssl: object expected");
                message.ssl = $root.dataform.JDBC.SslConfiguration.fromObject(object.ssl);
            }
            if (object.sshTunnel != null) {
                if (typeof object.sshTunnel !== "object")
                    throw TypeError(".dataform.JDBC.sshTunnel: object expected");
                message.sshTunnel = $root.dataform.JDBC.SshTunnel.fromObject(object.sshTunnel);
            }
            return message;
        };

        /**
         * Creates a plain object from a JDBC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.JDBC} message JDBC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JDBC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.username = "";
                object.password = "";
                object.databaseName = "";
                object.sshTunnel = null;
                object.ssl = null;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                object.databaseName = message.databaseName;
            if (message.sshTunnel != null && message.hasOwnProperty("sshTunnel"))
                object.sshTunnel = $root.dataform.JDBC.SshTunnel.toObject(message.sshTunnel, options);
            if (message.ssl != null && message.hasOwnProperty("ssl"))
                object.ssl = $root.dataform.JDBC.SslConfiguration.toObject(message.ssl, options);
            return object;
        };

        /**
         * Converts this JDBC to JSON.
         * @function toJSON
         * @memberof dataform.JDBC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JDBC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        JDBC.SslConfiguration = (function() {

            /**
             * Properties of a SslConfiguration.
             * @memberof dataform.JDBC
             * @interface ISslConfiguration
             * @property {string|null} [serverCertificate] SslConfiguration serverCertificate
             * @property {string|null} [clientCertificate] SslConfiguration clientCertificate
             * @property {string|null} [clientPrivateKey] SslConfiguration clientPrivateKey
             */

            /**
             * Constructs a new SslConfiguration.
             * @memberof dataform.JDBC
             * @classdesc Represents a SslConfiguration.
             * @implements ISslConfiguration
             * @constructor
             * @param {dataform.JDBC.ISslConfiguration=} [properties] Properties to set
             */
            function SslConfiguration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SslConfiguration serverCertificate.
             * @member {string} serverCertificate
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.serverCertificate = "";

            /**
             * SslConfiguration clientCertificate.
             * @member {string} clientCertificate
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.clientCertificate = "";

            /**
             * SslConfiguration clientPrivateKey.
             * @member {string} clientPrivateKey
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.clientPrivateKey = "";

            /**
             * Creates a new SslConfiguration instance using the specified properties.
             * @function create
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration=} [properties] Properties to set
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration instance
             */
            SslConfiguration.create = function create(properties) {
                return new SslConfiguration(properties);
            };

            /**
             * Encodes the specified SslConfiguration message. Does not implicitly {@link dataform.JDBC.SslConfiguration.verify|verify} messages.
             * @function encode
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration} message SslConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SslConfiguration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serverCertificate != null && message.hasOwnProperty("serverCertificate"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverCertificate);
                if (message.clientCertificate != null && message.hasOwnProperty("clientCertificate"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientCertificate);
                if (message.clientPrivateKey != null && message.hasOwnProperty("clientPrivateKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientPrivateKey);
                return writer;
            };

            /**
             * Encodes the specified SslConfiguration message, length delimited. Does not implicitly {@link dataform.JDBC.SslConfiguration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration} message SslConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SslConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SslConfiguration message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SslConfiguration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC.SslConfiguration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serverCertificate = reader.string();
                        break;
                    case 2:
                        message.clientCertificate = reader.string();
                        break;
                    case 3:
                        message.clientPrivateKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SslConfiguration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SslConfiguration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SslConfiguration message.
             * @function verify
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SslConfiguration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serverCertificate != null && message.hasOwnProperty("serverCertificate"))
                    if (!$util.isString(message.serverCertificate))
                        return "serverCertificate: string expected";
                if (message.clientCertificate != null && message.hasOwnProperty("clientCertificate"))
                    if (!$util.isString(message.clientCertificate))
                        return "clientCertificate: string expected";
                if (message.clientPrivateKey != null && message.hasOwnProperty("clientPrivateKey"))
                    if (!$util.isString(message.clientPrivateKey))
                        return "clientPrivateKey: string expected";
                return null;
            };

            /**
             * Creates a SslConfiguration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             */
            SslConfiguration.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.JDBC.SslConfiguration)
                    return object;
                let message = new $root.dataform.JDBC.SslConfiguration();
                if (object.serverCertificate != null)
                    message.serverCertificate = String(object.serverCertificate);
                if (object.clientCertificate != null)
                    message.clientCertificate = String(object.clientCertificate);
                if (object.clientPrivateKey != null)
                    message.clientPrivateKey = String(object.clientPrivateKey);
                return message;
            };

            /**
             * Creates a plain object from a SslConfiguration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.SslConfiguration} message SslConfiguration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SslConfiguration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.serverCertificate = "";
                    object.clientCertificate = "";
                    object.clientPrivateKey = "";
                }
                if (message.serverCertificate != null && message.hasOwnProperty("serverCertificate"))
                    object.serverCertificate = message.serverCertificate;
                if (message.clientCertificate != null && message.hasOwnProperty("clientCertificate"))
                    object.clientCertificate = message.clientCertificate;
                if (message.clientPrivateKey != null && message.hasOwnProperty("clientPrivateKey"))
                    object.clientPrivateKey = message.clientPrivateKey;
                return object;
            };

            /**
             * Converts this SslConfiguration to JSON.
             * @function toJSON
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SslConfiguration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SslConfiguration;
        })();

        JDBC.SshTunnel = (function() {

            /**
             * Properties of a SshTunnel.
             * @memberof dataform.JDBC
             * @interface ISshTunnel
             * @property {string|null} [privateKey] SshTunnel privateKey
             * @property {string|null} [username] SshTunnel username
             * @property {string|null} [password] SshTunnel password
             * @property {string|null} [host] SshTunnel host
             * @property {number|null} [port] SshTunnel port
             */

            /**
             * Constructs a new SshTunnel.
             * @memberof dataform.JDBC
             * @classdesc Represents a SshTunnel.
             * @implements ISshTunnel
             * @constructor
             * @param {dataform.JDBC.ISshTunnel=} [properties] Properties to set
             */
            function SshTunnel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SshTunnel privateKey.
             * @member {string} privateKey
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.privateKey = "";

            /**
             * SshTunnel username.
             * @member {string} username
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.username = "";

            /**
             * SshTunnel password.
             * @member {string} password
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.password = "";

            /**
             * SshTunnel host.
             * @member {string} host
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.host = "";

            /**
             * SshTunnel port.
             * @member {number} port
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.port = 0;

            /**
             * Creates a new SshTunnel instance using the specified properties.
             * @function create
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel=} [properties] Properties to set
             * @returns {dataform.JDBC.SshTunnel} SshTunnel instance
             */
            SshTunnel.create = function create(properties) {
                return new SshTunnel(properties);
            };

            /**
             * Encodes the specified SshTunnel message. Does not implicitly {@link dataform.JDBC.SshTunnel.verify|verify} messages.
             * @function encode
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel} message SshTunnel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SshTunnel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.privateKey);
                if (message.username != null && message.hasOwnProperty("username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && message.hasOwnProperty("password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.port);
                return writer;
            };

            /**
             * Encodes the specified SshTunnel message, length delimited. Does not implicitly {@link dataform.JDBC.SshTunnel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel} message SshTunnel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SshTunnel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SshTunnel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SshTunnel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC.SshTunnel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.privateKey = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    case 4:
                        message.host = reader.string();
                        break;
                    case 5:
                        message.port = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SshTunnel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SshTunnel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SshTunnel message.
             * @function verify
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SshTunnel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    if (!$util.isString(message.privateKey))
                        return "privateKey: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                return null;
            };

            /**
             * Creates a SshTunnel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             */
            SshTunnel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.JDBC.SshTunnel)
                    return object;
                let message = new $root.dataform.JDBC.SshTunnel();
                if (object.privateKey != null)
                    message.privateKey = String(object.privateKey);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                return message;
            };

            /**
             * Creates a plain object from a SshTunnel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.SshTunnel} message SshTunnel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SshTunnel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.privateKey = "";
                    object.username = "";
                    object.password = "";
                    object.host = "";
                    object.port = 0;
                }
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    object.privateKey = message.privateKey;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };

            /**
             * Converts this SshTunnel to JSON.
             * @function toJSON
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SshTunnel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SshTunnel;
        })();

        return JDBC;
    })();

    dataform.Snowflake = (function() {

        /**
         * Properties of a Snowflake.
         * @memberof dataform
         * @interface ISnowflake
         * @property {string|null} [accountId] Snowflake accountId
         * @property {string|null} [username] Snowflake username
         * @property {string|null} [password] Snowflake password
         * @property {string|null} [role] Snowflake role
         * @property {string|null} [databaseName] Snowflake databaseName
         * @property {string|null} [warehouse] Snowflake warehouse
         */

        /**
         * Constructs a new Snowflake.
         * @memberof dataform
         * @classdesc Represents a Snowflake.
         * @implements ISnowflake
         * @constructor
         * @param {dataform.ISnowflake=} [properties] Properties to set
         */
        function Snowflake(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Snowflake accountId.
         * @member {string} accountId
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.accountId = "";

        /**
         * Snowflake username.
         * @member {string} username
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.username = "";

        /**
         * Snowflake password.
         * @member {string} password
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.password = "";

        /**
         * Snowflake role.
         * @member {string} role
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.role = "";

        /**
         * Snowflake databaseName.
         * @member {string} databaseName
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.databaseName = "";

        /**
         * Snowflake warehouse.
         * @member {string} warehouse
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.warehouse = "";

        /**
         * Creates a new Snowflake instance using the specified properties.
         * @function create
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake=} [properties] Properties to set
         * @returns {dataform.Snowflake} Snowflake instance
         */
        Snowflake.create = function create(properties) {
            return new Snowflake(properties);
        };

        /**
         * Encodes the specified Snowflake message. Does not implicitly {@link dataform.Snowflake.verify|verify} messages.
         * @function encode
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake} message Snowflake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snowflake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.accountId);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            if (message.role != null && message.hasOwnProperty("role"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.role);
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.databaseName);
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.warehouse);
            return writer;
        };

        /**
         * Encodes the specified Snowflake message, length delimited. Does not implicitly {@link dataform.Snowflake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake} message Snowflake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snowflake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Snowflake message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Snowflake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Snowflake} Snowflake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snowflake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Snowflake();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.accountId = reader.string();
                    break;
                case 3:
                    message.username = reader.string();
                    break;
                case 4:
                    message.password = reader.string();
                    break;
                case 5:
                    message.role = reader.string();
                    break;
                case 6:
                    message.databaseName = reader.string();
                    break;
                case 7:
                    message.warehouse = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Snowflake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Snowflake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Snowflake} Snowflake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snowflake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Snowflake message.
         * @function verify
         * @memberof dataform.Snowflake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Snowflake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!$util.isString(message.accountId))
                    return "accountId: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isString(message.role))
                    return "role: string expected";
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                if (!$util.isString(message.databaseName))
                    return "databaseName: string expected";
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                if (!$util.isString(message.warehouse))
                    return "warehouse: string expected";
            return null;
        };

        /**
         * Creates a Snowflake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Snowflake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Snowflake} Snowflake
         */
        Snowflake.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Snowflake)
                return object;
            let message = new $root.dataform.Snowflake();
            if (object.accountId != null)
                message.accountId = String(object.accountId);
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.role != null)
                message.role = String(object.role);
            if (object.databaseName != null)
                message.databaseName = String(object.databaseName);
            if (object.warehouse != null)
                message.warehouse = String(object.warehouse);
            return message;
        };

        /**
         * Creates a plain object from a Snowflake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.Snowflake} message Snowflake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Snowflake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.accountId = "";
                object.username = "";
                object.password = "";
                object.role = "";
                object.databaseName = "";
                object.warehouse = "";
            }
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                object.accountId = message.accountId;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                object.databaseName = message.databaseName;
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                object.warehouse = message.warehouse;
            return object;
        };

        /**
         * Converts this Snowflake to JSON.
         * @function toJSON
         * @memberof dataform.Snowflake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Snowflake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Snowflake;
    })();

    dataform.BigQuery = (function() {

        /**
         * Properties of a BigQuery.
         * @memberof dataform
         * @interface IBigQuery
         * @property {string|null} [projectId] BigQuery projectId
         * @property {string|null} [credentials] BigQuery credentials
         * @property {string|null} [location] BigQuery location
         */

        /**
         * Constructs a new BigQuery.
         * @memberof dataform
         * @classdesc Represents a BigQuery.
         * @implements IBigQuery
         * @constructor
         * @param {dataform.IBigQuery=} [properties] Properties to set
         */
        function BigQuery(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigQuery projectId.
         * @member {string} projectId
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.projectId = "";

        /**
         * BigQuery credentials.
         * @member {string} credentials
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.credentials = "";

        /**
         * BigQuery location.
         * @member {string} location
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.location = "";

        /**
         * Creates a new BigQuery instance using the specified properties.
         * @function create
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery=} [properties] Properties to set
         * @returns {dataform.BigQuery} BigQuery instance
         */
        BigQuery.create = function create(properties) {
            return new BigQuery(properties);
        };

        /**
         * Encodes the specified BigQuery message. Does not implicitly {@link dataform.BigQuery.verify|verify} messages.
         * @function encode
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery} message BigQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectId);
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.credentials);
            if (message.location != null && message.hasOwnProperty("location"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.location);
            return writer;
        };

        /**
         * Encodes the specified BigQuery message, length delimited. Does not implicitly {@link dataform.BigQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery} message BigQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BigQuery message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.BigQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.BigQuery} BigQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.BigQuery();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.projectId = reader.string();
                    break;
                case 3:
                    message.credentials = reader.string();
                    break;
                case 4:
                    message.location = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BigQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.BigQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.BigQuery} BigQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BigQuery message.
         * @function verify
         * @memberof dataform.BigQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BigQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                if (!$util.isString(message.projectId))
                    return "projectId: string expected";
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                if (!$util.isString(message.credentials))
                    return "credentials: string expected";
            if (message.location != null && message.hasOwnProperty("location"))
                if (!$util.isString(message.location))
                    return "location: string expected";
            return null;
        };

        /**
         * Creates a BigQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.BigQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.BigQuery} BigQuery
         */
        BigQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.BigQuery)
                return object;
            let message = new $root.dataform.BigQuery();
            if (object.projectId != null)
                message.projectId = String(object.projectId);
            if (object.credentials != null)
                message.credentials = String(object.credentials);
            if (object.location != null)
                message.location = String(object.location);
            return message;
        };

        /**
         * Creates a plain object from a BigQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.BigQuery} message BigQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BigQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.projectId = "";
                object.credentials = "";
                object.location = "";
            }
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                object.projectId = message.projectId;
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                object.credentials = message.credentials;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = message.location;
            return object;
        };

        /**
         * Converts this BigQuery to JSON.
         * @function toJSON
         * @memberof dataform.BigQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BigQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BigQuery;
    })();

    dataform.SQLDataWarehouse = (function() {

        /**
         * Properties of a SQLDataWarehouse.
         * @memberof dataform
         * @interface ISQLDataWarehouse
         * @property {string|null} [server] SQLDataWarehouse server
         * @property {number|null} [port] SQLDataWarehouse port
         * @property {string|null} [username] SQLDataWarehouse username
         * @property {string|null} [password] SQLDataWarehouse password
         * @property {string|null} [database] SQLDataWarehouse database
         */

        /**
         * Constructs a new SQLDataWarehouse.
         * @memberof dataform
         * @classdesc Represents a SQLDataWarehouse.
         * @implements ISQLDataWarehouse
         * @constructor
         * @param {dataform.ISQLDataWarehouse=} [properties] Properties to set
         */
        function SQLDataWarehouse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SQLDataWarehouse server.
         * @member {string} server
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.server = "";

        /**
         * SQLDataWarehouse port.
         * @member {number} port
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.port = 0;

        /**
         * SQLDataWarehouse username.
         * @member {string} username
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.username = "";

        /**
         * SQLDataWarehouse password.
         * @member {string} password
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.password = "";

        /**
         * SQLDataWarehouse database.
         * @member {string} database
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.database = "";

        /**
         * Creates a new SQLDataWarehouse instance using the specified properties.
         * @function create
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse=} [properties] Properties to set
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse instance
         */
        SQLDataWarehouse.create = function create(properties) {
            return new SQLDataWarehouse(properties);
        };

        /**
         * Encodes the specified SQLDataWarehouse message. Does not implicitly {@link dataform.SQLDataWarehouse.verify|verify} messages.
         * @function encode
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse} message SQLDataWarehouse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.server != null && message.hasOwnProperty("server"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.server);
            if (message.port != null && message.hasOwnProperty("port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            if (message.database != null && message.hasOwnProperty("database"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.database);
            return writer;
        };

        /**
         * Encodes the specified SQLDataWarehouse message, length delimited. Does not implicitly {@link dataform.SQLDataWarehouse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse} message SQLDataWarehouse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SQLDataWarehouse message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SQLDataWarehouse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.server = reader.string();
                    break;
                case 2:
                    message.port = reader.int32();
                    break;
                case 3:
                    message.username = reader.string();
                    break;
                case 4:
                    message.password = reader.string();
                    break;
                case 5:
                    message.database = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SQLDataWarehouse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SQLDataWarehouse message.
         * @function verify
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SQLDataWarehouse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.server != null && message.hasOwnProperty("server"))
                if (!$util.isString(message.server))
                    return "server: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            return null;
        };

        /**
         * Creates a SQLDataWarehouse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         */
        SQLDataWarehouse.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SQLDataWarehouse)
                return object;
            let message = new $root.dataform.SQLDataWarehouse();
            if (object.server != null)
                message.server = String(object.server);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.database != null)
                message.database = String(object.database);
            return message;
        };

        /**
         * Creates a plain object from a SQLDataWarehouse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.SQLDataWarehouse} message SQLDataWarehouse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SQLDataWarehouse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.server = "";
                object.port = 0;
                object.username = "";
                object.password = "";
                object.database = "";
            }
            if (message.server != null && message.hasOwnProperty("server"))
                object.server = message.server;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            return object;
        };

        /**
         * Converts this SQLDataWarehouse to JSON.
         * @function toJSON
         * @memberof dataform.SQLDataWarehouse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SQLDataWarehouse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SQLDataWarehouse;
    })();

    dataform.Presto = (function() {

        /**
         * Properties of a Presto.
         * @memberof dataform
         * @interface IPresto
         * @property {string|null} [host] Presto host
         * @property {number|null} [port] Presto port
         * @property {string|null} [user] Presto user
         * @property {string|null} [catalog] Presto catalog
         * @property {string|null} [schema] Presto schema
         */

        /**
         * Constructs a new Presto.
         * @memberof dataform
         * @classdesc Represents a Presto.
         * @implements IPresto
         * @constructor
         * @param {dataform.IPresto=} [properties] Properties to set
         */
        function Presto(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Presto host.
         * @member {string} host
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.host = "";

        /**
         * Presto port.
         * @member {number} port
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.port = 0;

        /**
         * Presto user.
         * @member {string} user
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.user = "";

        /**
         * Presto catalog.
         * @member {string} catalog
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.catalog = "";

        /**
         * Presto schema.
         * @member {string} schema
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.schema = "";

        /**
         * Creates a new Presto instance using the specified properties.
         * @function create
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto=} [properties] Properties to set
         * @returns {dataform.Presto} Presto instance
         */
        Presto.create = function create(properties) {
            return new Presto(properties);
        };

        /**
         * Encodes the specified Presto message. Does not implicitly {@link dataform.Presto.verify|verify} messages.
         * @function encode
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto} message Presto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && message.hasOwnProperty("host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && message.hasOwnProperty("port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            if (message.user != null && message.hasOwnProperty("user"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.user);
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.catalog);
            if (message.schema != null && message.hasOwnProperty("schema"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.schema);
            return writer;
        };

        /**
         * Encodes the specified Presto message, length delimited. Does not implicitly {@link dataform.Presto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto} message Presto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Presto message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Presto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Presto} Presto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Presto();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.port = reader.int32();
                    break;
                case 3:
                    message.user = reader.string();
                    break;
                case 4:
                    message.catalog = reader.string();
                    break;
                case 5:
                    message.schema = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Presto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Presto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Presto} Presto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Presto message.
         * @function verify
         * @memberof dataform.Presto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Presto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.user != null && message.hasOwnProperty("user"))
                if (!$util.isString(message.user))
                    return "user: string expected";
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                if (!$util.isString(message.catalog))
                    return "catalog: string expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isString(message.schema))
                    return "schema: string expected";
            return null;
        };

        /**
         * Creates a Presto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Presto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Presto} Presto
         */
        Presto.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Presto)
                return object;
            let message = new $root.dataform.Presto();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.user != null)
                message.user = String(object.user);
            if (object.catalog != null)
                message.catalog = String(object.catalog);
            if (object.schema != null)
                message.schema = String(object.schema);
            return message;
        };

        /**
         * Creates a plain object from a Presto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Presto
         * @static
         * @param {dataform.Presto} message Presto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Presto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.user = "";
                object.catalog = "";
                object.schema = "";
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                object.catalog = message.catalog;
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            return object;
        };

        /**
         * Converts this Presto to JSON.
         * @function toJSON
         * @memberof dataform.Presto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Presto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Presto;
    })();

    dataform.schedules = (function() {

        /**
         * Namespace schedules.
         * @memberof dataform
         * @namespace
         */
        const schedules = {};

        /**
         * NotificationEventType enum.
         * @name dataform.schedules.NotificationEventType
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        schedules.NotificationEventType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        schedules.EmailNotificationChannel = (function() {

            /**
             * Properties of an EmailNotificationChannel.
             * @memberof dataform.schedules
             * @interface IEmailNotificationChannel
             * @property {Array.<string>|null} [to] EmailNotificationChannel to
             */

            /**
             * Constructs a new EmailNotificationChannel.
             * @memberof dataform.schedules
             * @classdesc Represents an EmailNotificationChannel.
             * @implements IEmailNotificationChannel
             * @constructor
             * @param {dataform.schedules.IEmailNotificationChannel=} [properties] Properties to set
             */
            function EmailNotificationChannel(properties) {
                this.to = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailNotificationChannel to.
             * @member {Array.<string>} to
             * @memberof dataform.schedules.EmailNotificationChannel
             * @instance
             */
            EmailNotificationChannel.prototype.to = $util.emptyArray;

            /**
             * Creates a new EmailNotificationChannel instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {dataform.schedules.IEmailNotificationChannel=} [properties] Properties to set
             * @returns {dataform.schedules.EmailNotificationChannel} EmailNotificationChannel instance
             */
            EmailNotificationChannel.create = function create(properties) {
                return new EmailNotificationChannel(properties);
            };

            /**
             * Encodes the specified EmailNotificationChannel message. Does not implicitly {@link dataform.schedules.EmailNotificationChannel.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {dataform.schedules.IEmailNotificationChannel} message EmailNotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailNotificationChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.to != null && message.to.length)
                    for (let i = 0; i < message.to.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.to[i]);
                return writer;
            };

            /**
             * Encodes the specified EmailNotificationChannel message, length delimited. Does not implicitly {@link dataform.schedules.EmailNotificationChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {dataform.schedules.IEmailNotificationChannel} message EmailNotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailNotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmailNotificationChannel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.EmailNotificationChannel} EmailNotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailNotificationChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.EmailNotificationChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.to && message.to.length))
                            message.to = [];
                        message.to.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EmailNotificationChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.EmailNotificationChannel} EmailNotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailNotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmailNotificationChannel message.
             * @function verify
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailNotificationChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.to != null && message.hasOwnProperty("to")) {
                    if (!Array.isArray(message.to))
                        return "to: array expected";
                    for (let i = 0; i < message.to.length; ++i)
                        if (!$util.isString(message.to[i]))
                            return "to: string[] expected";
                }
                return null;
            };

            /**
             * Creates an EmailNotificationChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.EmailNotificationChannel} EmailNotificationChannel
             */
            EmailNotificationChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.EmailNotificationChannel)
                    return object;
                let message = new $root.dataform.schedules.EmailNotificationChannel();
                if (object.to) {
                    if (!Array.isArray(object.to))
                        throw TypeError(".dataform.schedules.EmailNotificationChannel.to: array expected");
                    message.to = [];
                    for (let i = 0; i < object.to.length; ++i)
                        message.to[i] = String(object.to[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an EmailNotificationChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {dataform.schedules.EmailNotificationChannel} message EmailNotificationChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EmailNotificationChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.to = [];
                if (message.to && message.to.length) {
                    object.to = [];
                    for (let j = 0; j < message.to.length; ++j)
                        object.to[j] = message.to[j];
                }
                return object;
            };

            /**
             * Converts this EmailNotificationChannel to JSON.
             * @function toJSON
             * @memberof dataform.schedules.EmailNotificationChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EmailNotificationChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EmailNotificationChannel;
        })();

        schedules.SlackNotificationChannel = (function() {

            /**
             * Properties of a SlackNotificationChannel.
             * @memberof dataform.schedules
             * @interface ISlackNotificationChannel
             * @property {string|null} [webhookUrl] SlackNotificationChannel webhookUrl
             */

            /**
             * Constructs a new SlackNotificationChannel.
             * @memberof dataform.schedules
             * @classdesc Represents a SlackNotificationChannel.
             * @implements ISlackNotificationChannel
             * @constructor
             * @param {dataform.schedules.ISlackNotificationChannel=} [properties] Properties to set
             */
            function SlackNotificationChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SlackNotificationChannel webhookUrl.
             * @member {string} webhookUrl
             * @memberof dataform.schedules.SlackNotificationChannel
             * @instance
             */
            SlackNotificationChannel.prototype.webhookUrl = "";

            /**
             * Creates a new SlackNotificationChannel instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {dataform.schedules.ISlackNotificationChannel=} [properties] Properties to set
             * @returns {dataform.schedules.SlackNotificationChannel} SlackNotificationChannel instance
             */
            SlackNotificationChannel.create = function create(properties) {
                return new SlackNotificationChannel(properties);
            };

            /**
             * Encodes the specified SlackNotificationChannel message. Does not implicitly {@link dataform.schedules.SlackNotificationChannel.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {dataform.schedules.ISlackNotificationChannel} message SlackNotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlackNotificationChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.webhookUrl);
                return writer;
            };

            /**
             * Encodes the specified SlackNotificationChannel message, length delimited. Does not implicitly {@link dataform.schedules.SlackNotificationChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {dataform.schedules.ISlackNotificationChannel} message SlackNotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlackNotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SlackNotificationChannel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.SlackNotificationChannel} SlackNotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlackNotificationChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.SlackNotificationChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.webhookUrl = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SlackNotificationChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.SlackNotificationChannel} SlackNotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlackNotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SlackNotificationChannel message.
             * @function verify
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SlackNotificationChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                    if (!$util.isString(message.webhookUrl))
                        return "webhookUrl: string expected";
                return null;
            };

            /**
             * Creates a SlackNotificationChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.SlackNotificationChannel} SlackNotificationChannel
             */
            SlackNotificationChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.SlackNotificationChannel)
                    return object;
                let message = new $root.dataform.schedules.SlackNotificationChannel();
                if (object.webhookUrl != null)
                    message.webhookUrl = String(object.webhookUrl);
                return message;
            };

            /**
             * Creates a plain object from a SlackNotificationChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {dataform.schedules.SlackNotificationChannel} message SlackNotificationChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SlackNotificationChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.webhookUrl = "";
                if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                    object.webhookUrl = message.webhookUrl;
                return object;
            };

            /**
             * Converts this SlackNotificationChannel to JSON.
             * @function toJSON
             * @memberof dataform.schedules.SlackNotificationChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SlackNotificationChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SlackNotificationChannel;
        })();

        schedules.NotificationChannel = (function() {

            /**
             * Properties of a NotificationChannel.
             * @memberof dataform.schedules
             * @interface INotificationChannel
             * @property {string|null} [name] NotificationChannel name
             * @property {dataform.schedules.IEmailNotificationChannel|null} [email] NotificationChannel email
             * @property {dataform.schedules.ISlackNotificationChannel|null} [slack] NotificationChannel slack
             */

            /**
             * Constructs a new NotificationChannel.
             * @memberof dataform.schedules
             * @classdesc Represents a NotificationChannel.
             * @implements INotificationChannel
             * @constructor
             * @param {dataform.schedules.INotificationChannel=} [properties] Properties to set
             */
            function NotificationChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotificationChannel name.
             * @member {string} name
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.name = "";

            /**
             * NotificationChannel email.
             * @member {dataform.schedules.IEmailNotificationChannel|null|undefined} email
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.email = null;

            /**
             * NotificationChannel slack.
             * @member {dataform.schedules.ISlackNotificationChannel|null|undefined} slack
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.slack = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NotificationChannel channel.
             * @member {"email"|"slack"|undefined} channel
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             */
            Object.defineProperty(NotificationChannel.prototype, "channel", {
                get: $util.oneOfGetter($oneOfFields = ["email", "slack"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NotificationChannel instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {dataform.schedules.INotificationChannel=} [properties] Properties to set
             * @returns {dataform.schedules.NotificationChannel} NotificationChannel instance
             */
            NotificationChannel.create = function create(properties) {
                return new NotificationChannel(properties);
            };

            /**
             * Encodes the specified NotificationChannel message. Does not implicitly {@link dataform.schedules.NotificationChannel.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {dataform.schedules.INotificationChannel} message NotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.email != null && message.hasOwnProperty("email"))
                    $root.dataform.schedules.EmailNotificationChannel.encode(message.email, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.slack != null && message.hasOwnProperty("slack"))
                    $root.dataform.schedules.SlackNotificationChannel.encode(message.slack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NotificationChannel message, length delimited. Does not implicitly {@link dataform.schedules.NotificationChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {dataform.schedules.INotificationChannel} message NotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotificationChannel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.NotificationChannel} NotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.NotificationChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.email = $root.dataform.schedules.EmailNotificationChannel.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.slack = $root.dataform.schedules.SlackNotificationChannel.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotificationChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.NotificationChannel} NotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotificationChannel message.
             * @function verify
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotificationChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties.channel = 1;
                    {
                        let error = $root.dataform.schedules.EmailNotificationChannel.verify(message.email);
                        if (error)
                            return "email." + error;
                    }
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    if (properties.channel === 1)
                        return "channel: multiple values";
                    properties.channel = 1;
                    {
                        let error = $root.dataform.schedules.SlackNotificationChannel.verify(message.slack);
                        if (error)
                            return "slack." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NotificationChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.NotificationChannel} NotificationChannel
             */
            NotificationChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.NotificationChannel)
                    return object;
                let message = new $root.dataform.schedules.NotificationChannel();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.email != null) {
                    if (typeof object.email !== "object")
                        throw TypeError(".dataform.schedules.NotificationChannel.email: object expected");
                    message.email = $root.dataform.schedules.EmailNotificationChannel.fromObject(object.email);
                }
                if (object.slack != null) {
                    if (typeof object.slack !== "object")
                        throw TypeError(".dataform.schedules.NotificationChannel.slack: object expected");
                    message.slack = $root.dataform.schedules.SlackNotificationChannel.fromObject(object.slack);
                }
                return message;
            };

            /**
             * Creates a plain object from a NotificationChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {dataform.schedules.NotificationChannel} message NotificationChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotificationChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.email != null && message.hasOwnProperty("email")) {
                    object.email = $root.dataform.schedules.EmailNotificationChannel.toObject(message.email, options);
                    if (options.oneofs)
                        object.channel = "email";
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    object.slack = $root.dataform.schedules.SlackNotificationChannel.toObject(message.slack, options);
                    if (options.oneofs)
                        object.channel = "slack";
                }
                return object;
            };

            /**
             * Converts this NotificationChannel to JSON.
             * @function toJSON
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotificationChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NotificationChannel;
        })();

        schedules.ScheduleNotification = (function() {

            /**
             * Properties of a ScheduleNotification.
             * @memberof dataform.schedules
             * @interface IScheduleNotification
             * @property {Array.<string>|null} [environments] ScheduleNotification environments
             * @property {Array.<string>|null} [events] ScheduleNotification events
             * @property {Array.<string>|null} [channels] ScheduleNotification channels
             */

            /**
             * Constructs a new ScheduleNotification.
             * @memberof dataform.schedules
             * @classdesc Represents a ScheduleNotification.
             * @implements IScheduleNotification
             * @constructor
             * @param {dataform.schedules.IScheduleNotification=} [properties] Properties to set
             */
            function ScheduleNotification(properties) {
                this.environments = [];
                this.events = [];
                this.channels = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScheduleNotification environments.
             * @member {Array.<string>} environments
             * @memberof dataform.schedules.ScheduleNotification
             * @instance
             */
            ScheduleNotification.prototype.environments = $util.emptyArray;

            /**
             * ScheduleNotification events.
             * @member {Array.<string>} events
             * @memberof dataform.schedules.ScheduleNotification
             * @instance
             */
            ScheduleNotification.prototype.events = $util.emptyArray;

            /**
             * ScheduleNotification channels.
             * @member {Array.<string>} channels
             * @memberof dataform.schedules.ScheduleNotification
             * @instance
             */
            ScheduleNotification.prototype.channels = $util.emptyArray;

            /**
             * Creates a new ScheduleNotification instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {dataform.schedules.IScheduleNotification=} [properties] Properties to set
             * @returns {dataform.schedules.ScheduleNotification} ScheduleNotification instance
             */
            ScheduleNotification.create = function create(properties) {
                return new ScheduleNotification(properties);
            };

            /**
             * Encodes the specified ScheduleNotification message. Does not implicitly {@link dataform.schedules.ScheduleNotification.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {dataform.schedules.IScheduleNotification} message ScheduleNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduleNotification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.environments != null && message.environments.length)
                    for (let i = 0; i < message.environments.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.environments[i]);
                if (message.events != null && message.events.length)
                    for (let i = 0; i < message.events.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.events[i]);
                if (message.channels != null && message.channels.length)
                    for (let i = 0; i < message.channels.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.channels[i]);
                return writer;
            };

            /**
             * Encodes the specified ScheduleNotification message, length delimited. Does not implicitly {@link dataform.schedules.ScheduleNotification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {dataform.schedules.IScheduleNotification} message ScheduleNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduleNotification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScheduleNotification message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.ScheduleNotification} ScheduleNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduleNotification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.ScheduleNotification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.environments && message.environments.length))
                            message.environments = [];
                        message.environments.push(reader.string());
                        break;
                    case 2:
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push(reader.string());
                        break;
                    case 3:
                        if (!(message.channels && message.channels.length))
                            message.channels = [];
                        message.channels.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScheduleNotification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.ScheduleNotification} ScheduleNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduleNotification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScheduleNotification message.
             * @function verify
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScheduleNotification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.environments != null && message.hasOwnProperty("environments")) {
                    if (!Array.isArray(message.environments))
                        return "environments: array expected";
                    for (let i = 0; i < message.environments.length; ++i)
                        if (!$util.isString(message.environments[i]))
                            return "environments: string[] expected";
                }
                if (message.events != null && message.hasOwnProperty("events")) {
                    if (!Array.isArray(message.events))
                        return "events: array expected";
                    for (let i = 0; i < message.events.length; ++i)
                        if (!$util.isString(message.events[i]))
                            return "events: string[] expected";
                }
                if (message.channels != null && message.hasOwnProperty("channels")) {
                    if (!Array.isArray(message.channels))
                        return "channels: array expected";
                    for (let i = 0; i < message.channels.length; ++i)
                        if (!$util.isString(message.channels[i]))
                            return "channels: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ScheduleNotification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.ScheduleNotification} ScheduleNotification
             */
            ScheduleNotification.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.ScheduleNotification)
                    return object;
                let message = new $root.dataform.schedules.ScheduleNotification();
                if (object.environments) {
                    if (!Array.isArray(object.environments))
                        throw TypeError(".dataform.schedules.ScheduleNotification.environments: array expected");
                    message.environments = [];
                    for (let i = 0; i < object.environments.length; ++i)
                        message.environments[i] = String(object.environments[i]);
                }
                if (object.events) {
                    if (!Array.isArray(object.events))
                        throw TypeError(".dataform.schedules.ScheduleNotification.events: array expected");
                    message.events = [];
                    for (let i = 0; i < object.events.length; ++i)
                        message.events[i] = String(object.events[i]);
                }
                if (object.channels) {
                    if (!Array.isArray(object.channels))
                        throw TypeError(".dataform.schedules.ScheduleNotification.channels: array expected");
                    message.channels = [];
                    for (let i = 0; i < object.channels.length; ++i)
                        message.channels[i] = String(object.channels[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ScheduleNotification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {dataform.schedules.ScheduleNotification} message ScheduleNotification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScheduleNotification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.environments = [];
                    object.events = [];
                    object.channels = [];
                }
                if (message.environments && message.environments.length) {
                    object.environments = [];
                    for (let j = 0; j < message.environments.length; ++j)
                        object.environments[j] = message.environments[j];
                }
                if (message.events && message.events.length) {
                    object.events = [];
                    for (let j = 0; j < message.events.length; ++j)
                        object.events[j] = message.events[j];
                }
                if (message.channels && message.channels.length) {
                    object.channels = [];
                    for (let j = 0; j < message.channels.length; ++j)
                        object.channels[j] = message.channels[j];
                }
                return object;
            };

            /**
             * Converts this ScheduleNotification to JSON.
             * @function toJSON
             * @memberof dataform.schedules.ScheduleNotification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScheduleNotification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScheduleNotification;
        })();

        schedules.NotificationSettings = (function() {

            /**
             * Properties of a NotificationSettings.
             * @memberof dataform.schedules
             * @interface INotificationSettings
             * @property {Array.<string>|null} [emails] NotificationSettings emails
             * @property {boolean|null} [onSuccess] NotificationSettings onSuccess
             * @property {boolean|null} [onFailure] NotificationSettings onFailure
             */

            /**
             * Constructs a new NotificationSettings.
             * @memberof dataform.schedules
             * @classdesc Represents a NotificationSettings.
             * @implements INotificationSettings
             * @constructor
             * @param {dataform.schedules.INotificationSettings=} [properties] Properties to set
             */
            function NotificationSettings(properties) {
                this.emails = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotificationSettings emails.
             * @member {Array.<string>} emails
             * @memberof dataform.schedules.NotificationSettings
             * @instance
             */
            NotificationSettings.prototype.emails = $util.emptyArray;

            /**
             * NotificationSettings onSuccess.
             * @member {boolean} onSuccess
             * @memberof dataform.schedules.NotificationSettings
             * @instance
             */
            NotificationSettings.prototype.onSuccess = false;

            /**
             * NotificationSettings onFailure.
             * @member {boolean} onFailure
             * @memberof dataform.schedules.NotificationSettings
             * @instance
             */
            NotificationSettings.prototype.onFailure = false;

            /**
             * Creates a new NotificationSettings instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {dataform.schedules.INotificationSettings=} [properties] Properties to set
             * @returns {dataform.schedules.NotificationSettings} NotificationSettings instance
             */
            NotificationSettings.create = function create(properties) {
                return new NotificationSettings(properties);
            };

            /**
             * Encodes the specified NotificationSettings message. Does not implicitly {@link dataform.schedules.NotificationSettings.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {dataform.schedules.INotificationSettings} message NotificationSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.emails != null && message.emails.length)
                    for (let i = 0; i < message.emails.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.emails[i]);
                if (message.onSuccess != null && message.hasOwnProperty("onSuccess"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.onSuccess);
                if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.onFailure);
                return writer;
            };

            /**
             * Encodes the specified NotificationSettings message, length delimited. Does not implicitly {@link dataform.schedules.NotificationSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {dataform.schedules.INotificationSettings} message NotificationSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotificationSettings message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.NotificationSettings} NotificationSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.NotificationSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.emails && message.emails.length))
                            message.emails = [];
                        message.emails.push(reader.string());
                        break;
                    case 2:
                        message.onSuccess = reader.bool();
                        break;
                    case 3:
                        message.onFailure = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotificationSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.NotificationSettings} NotificationSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotificationSettings message.
             * @function verify
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotificationSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.emails != null && message.hasOwnProperty("emails")) {
                    if (!Array.isArray(message.emails))
                        return "emails: array expected";
                    for (let i = 0; i < message.emails.length; ++i)
                        if (!$util.isString(message.emails[i]))
                            return "emails: string[] expected";
                }
                if (message.onSuccess != null && message.hasOwnProperty("onSuccess"))
                    if (typeof message.onSuccess !== "boolean")
                        return "onSuccess: boolean expected";
                if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                    if (typeof message.onFailure !== "boolean")
                        return "onFailure: boolean expected";
                return null;
            };

            /**
             * Creates a NotificationSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.NotificationSettings} NotificationSettings
             */
            NotificationSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.NotificationSettings)
                    return object;
                let message = new $root.dataform.schedules.NotificationSettings();
                if (object.emails) {
                    if (!Array.isArray(object.emails))
                        throw TypeError(".dataform.schedules.NotificationSettings.emails: array expected");
                    message.emails = [];
                    for (let i = 0; i < object.emails.length; ++i)
                        message.emails[i] = String(object.emails[i]);
                }
                if (object.onSuccess != null)
                    message.onSuccess = Boolean(object.onSuccess);
                if (object.onFailure != null)
                    message.onFailure = Boolean(object.onFailure);
                return message;
            };

            /**
             * Creates a plain object from a NotificationSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {dataform.schedules.NotificationSettings} message NotificationSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotificationSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.emails = [];
                if (options.defaults) {
                    object.onSuccess = false;
                    object.onFailure = false;
                }
                if (message.emails && message.emails.length) {
                    object.emails = [];
                    for (let j = 0; j < message.emails.length; ++j)
                        object.emails[j] = message.emails[j];
                }
                if (message.onSuccess != null && message.hasOwnProperty("onSuccess"))
                    object.onSuccess = message.onSuccess;
                if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                    object.onFailure = message.onFailure;
                return object;
            };

            /**
             * Converts this NotificationSettings to JSON.
             * @function toJSON
             * @memberof dataform.schedules.NotificationSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotificationSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NotificationSettings;
        })();

        schedules.ScheduleOptions = (function() {

            /**
             * Properties of a ScheduleOptions.
             * @memberof dataform.schedules
             * @interface IScheduleOptions
             * @property {Array.<string>|null} [actions] ScheduleOptions actions
             * @property {Array.<string>|null} [tags] ScheduleOptions tags
             * @property {boolean|null} [includeDependencies] ScheduleOptions includeDependencies
             * @property {boolean|null} [includeDependents] ScheduleOptions includeDependents
             * @property {boolean|null} [fullRefresh] ScheduleOptions fullRefresh
             */

            /**
             * Constructs a new ScheduleOptions.
             * @memberof dataform.schedules
             * @classdesc Represents a ScheduleOptions.
             * @implements IScheduleOptions
             * @constructor
             * @param {dataform.schedules.IScheduleOptions=} [properties] Properties to set
             */
            function ScheduleOptions(properties) {
                this.actions = [];
                this.tags = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScheduleOptions actions.
             * @member {Array.<string>} actions
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.actions = $util.emptyArray;

            /**
             * ScheduleOptions tags.
             * @member {Array.<string>} tags
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.tags = $util.emptyArray;

            /**
             * ScheduleOptions includeDependencies.
             * @member {boolean} includeDependencies
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.includeDependencies = false;

            /**
             * ScheduleOptions includeDependents.
             * @member {boolean} includeDependents
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.includeDependents = false;

            /**
             * ScheduleOptions fullRefresh.
             * @member {boolean} fullRefresh
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.fullRefresh = false;

            /**
             * Creates a new ScheduleOptions instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {dataform.schedules.IScheduleOptions=} [properties] Properties to set
             * @returns {dataform.schedules.ScheduleOptions} ScheduleOptions instance
             */
            ScheduleOptions.create = function create(properties) {
                return new ScheduleOptions(properties);
            };

            /**
             * Encodes the specified ScheduleOptions message. Does not implicitly {@link dataform.schedules.ScheduleOptions.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {dataform.schedules.IScheduleOptions} message ScheduleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduleOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actions != null && message.actions.length)
                    for (let i = 0; i < message.actions.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actions[i]);
                if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includeDependencies);
                if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.fullRefresh);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.includeDependents);
                return writer;
            };

            /**
             * Encodes the specified ScheduleOptions message, length delimited. Does not implicitly {@link dataform.schedules.ScheduleOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {dataform.schedules.IScheduleOptions} message ScheduleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduleOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScheduleOptions message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.ScheduleOptions} ScheduleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduleOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.ScheduleOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push(reader.string());
                        break;
                    case 4:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    case 2:
                        message.includeDependencies = reader.bool();
                        break;
                    case 5:
                        message.includeDependents = reader.bool();
                        break;
                    case 3:
                        message.fullRefresh = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScheduleOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.ScheduleOptions} ScheduleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduleOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScheduleOptions message.
             * @function verify
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScheduleOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actions != null && message.hasOwnProperty("actions")) {
                    if (!Array.isArray(message.actions))
                        return "actions: array expected";
                    for (let i = 0; i < message.actions.length; ++i)
                        if (!$util.isString(message.actions[i]))
                            return "actions: string[] expected";
                }
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                    if (typeof message.includeDependencies !== "boolean")
                        return "includeDependencies: boolean expected";
                if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                    if (typeof message.includeDependents !== "boolean")
                        return "includeDependents: boolean expected";
                if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                    if (typeof message.fullRefresh !== "boolean")
                        return "fullRefresh: boolean expected";
                return null;
            };

            /**
             * Creates a ScheduleOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.ScheduleOptions} ScheduleOptions
             */
            ScheduleOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.ScheduleOptions)
                    return object;
                let message = new $root.dataform.schedules.ScheduleOptions();
                if (object.actions) {
                    if (!Array.isArray(object.actions))
                        throw TypeError(".dataform.schedules.ScheduleOptions.actions: array expected");
                    message.actions = [];
                    for (let i = 0; i < object.actions.length; ++i)
                        message.actions[i] = String(object.actions[i]);
                }
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.schedules.ScheduleOptions.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.includeDependencies != null)
                    message.includeDependencies = Boolean(object.includeDependencies);
                if (object.includeDependents != null)
                    message.includeDependents = Boolean(object.includeDependents);
                if (object.fullRefresh != null)
                    message.fullRefresh = Boolean(object.fullRefresh);
                return message;
            };

            /**
             * Creates a plain object from a ScheduleOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {dataform.schedules.ScheduleOptions} message ScheduleOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScheduleOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.actions = [];
                    object.tags = [];
                }
                if (options.defaults) {
                    object.includeDependencies = false;
                    object.fullRefresh = false;
                    object.includeDependents = false;
                }
                if (message.actions && message.actions.length) {
                    object.actions = [];
                    for (let j = 0; j < message.actions.length; ++j)
                        object.actions[j] = message.actions[j];
                }
                if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                    object.includeDependencies = message.includeDependencies;
                if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                    object.fullRefresh = message.fullRefresh;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                    object.includeDependents = message.includeDependents;
                return object;
            };

            /**
             * Converts this ScheduleOptions to JSON.
             * @function toJSON
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScheduleOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScheduleOptions;
        })();

        schedules.Schedule = (function() {

            /**
             * Properties of a Schedule.
             * @memberof dataform.schedules
             * @interface ISchedule
             * @property {string|null} [name] Schedule name
             * @property {boolean|null} [disabled] Schedule disabled
             * @property {dataform.schedules.IScheduleOptions|null} [options] Schedule options
             * @property {string|null} [cron] Schedule cron
             * @property {dataform.schedules.INotificationSettings|null} [notification] Schedule notification
             * @property {Array.<dataform.schedules.IScheduleNotification>|null} [notifications] Schedule notifications
             */

            /**
             * Constructs a new Schedule.
             * @memberof dataform.schedules
             * @classdesc Represents a Schedule.
             * @implements ISchedule
             * @constructor
             * @param {dataform.schedules.ISchedule=} [properties] Properties to set
             */
            function Schedule(properties) {
                this.notifications = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Schedule name.
             * @member {string} name
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.name = "";

            /**
             * Schedule disabled.
             * @member {boolean} disabled
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.disabled = false;

            /**
             * Schedule options.
             * @member {dataform.schedules.IScheduleOptions|null|undefined} options
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.options = null;

            /**
             * Schedule cron.
             * @member {string} cron
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.cron = "";

            /**
             * Schedule notification.
             * @member {dataform.schedules.INotificationSettings|null|undefined} notification
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.notification = null;

            /**
             * Schedule notifications.
             * @member {Array.<dataform.schedules.IScheduleNotification>} notifications
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.notifications = $util.emptyArray;

            /**
             * Creates a new Schedule instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {dataform.schedules.ISchedule=} [properties] Properties to set
             * @returns {dataform.schedules.Schedule} Schedule instance
             */
            Schedule.create = function create(properties) {
                return new Schedule(properties);
            };

            /**
             * Encodes the specified Schedule message. Does not implicitly {@link dataform.schedules.Schedule.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {dataform.schedules.ISchedule} message Schedule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Schedule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.disabled);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.dataform.schedules.ScheduleOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.cron != null && message.hasOwnProperty("cron"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.cron);
                if (message.notification != null && message.hasOwnProperty("notification"))
                    $root.dataform.schedules.NotificationSettings.encode(message.notification, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.notifications != null && message.notifications.length)
                    for (let i = 0; i < message.notifications.length; ++i)
                        $root.dataform.schedules.ScheduleNotification.encode(message.notifications[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Schedule message, length delimited. Does not implicitly {@link dataform.schedules.Schedule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {dataform.schedules.ISchedule} message Schedule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Schedule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Schedule message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.Schedule} Schedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Schedule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.Schedule();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.disabled = reader.bool();
                        break;
                    case 3:
                        message.options = $root.dataform.schedules.ScheduleOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.cron = reader.string();
                        break;
                    case 5:
                        message.notification = $root.dataform.schedules.NotificationSettings.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.notifications && message.notifications.length))
                            message.notifications = [];
                        message.notifications.push($root.dataform.schedules.ScheduleNotification.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Schedule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.Schedule} Schedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Schedule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Schedule message.
             * @function verify
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Schedule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.dataform.schedules.ScheduleOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.cron != null && message.hasOwnProperty("cron"))
                    if (!$util.isString(message.cron))
                        return "cron: string expected";
                if (message.notification != null && message.hasOwnProperty("notification")) {
                    let error = $root.dataform.schedules.NotificationSettings.verify(message.notification);
                    if (error)
                        return "notification." + error;
                }
                if (message.notifications != null && message.hasOwnProperty("notifications")) {
                    if (!Array.isArray(message.notifications))
                        return "notifications: array expected";
                    for (let i = 0; i < message.notifications.length; ++i) {
                        let error = $root.dataform.schedules.ScheduleNotification.verify(message.notifications[i]);
                        if (error)
                            return "notifications." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Schedule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.Schedule} Schedule
             */
            Schedule.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.Schedule)
                    return object;
                let message = new $root.dataform.schedules.Schedule();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".dataform.schedules.Schedule.options: object expected");
                    message.options = $root.dataform.schedules.ScheduleOptions.fromObject(object.options);
                }
                if (object.cron != null)
                    message.cron = String(object.cron);
                if (object.notification != null) {
                    if (typeof object.notification !== "object")
                        throw TypeError(".dataform.schedules.Schedule.notification: object expected");
                    message.notification = $root.dataform.schedules.NotificationSettings.fromObject(object.notification);
                }
                if (object.notifications) {
                    if (!Array.isArray(object.notifications))
                        throw TypeError(".dataform.schedules.Schedule.notifications: array expected");
                    message.notifications = [];
                    for (let i = 0; i < object.notifications.length; ++i) {
                        if (typeof object.notifications[i] !== "object")
                            throw TypeError(".dataform.schedules.Schedule.notifications: object expected");
                        message.notifications[i] = $root.dataform.schedules.ScheduleNotification.fromObject(object.notifications[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Schedule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {dataform.schedules.Schedule} message Schedule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Schedule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.notifications = [];
                if (options.defaults) {
                    object.name = "";
                    object.disabled = false;
                    object.options = null;
                    object.cron = "";
                    object.notification = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.dataform.schedules.ScheduleOptions.toObject(message.options, options);
                if (message.cron != null && message.hasOwnProperty("cron"))
                    object.cron = message.cron;
                if (message.notification != null && message.hasOwnProperty("notification"))
                    object.notification = $root.dataform.schedules.NotificationSettings.toObject(message.notification, options);
                if (message.notifications && message.notifications.length) {
                    object.notifications = [];
                    for (let j = 0; j < message.notifications.length; ++j)
                        object.notifications[j] = $root.dataform.schedules.ScheduleNotification.toObject(message.notifications[j], options);
                }
                return object;
            };

            /**
             * Converts this Schedule to JSON.
             * @function toJSON
             * @memberof dataform.schedules.Schedule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Schedule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Schedule;
        })();

        schedules.SchedulesJSON = (function() {

            /**
             * Properties of a SchedulesJSON.
             * @memberof dataform.schedules
             * @interface ISchedulesJSON
             * @property {Array.<dataform.schedules.ISchedule>|null} [schedules] SchedulesJSON schedules
             * @property {Array.<dataform.schedules.INotificationChannel>|null} [notificationChannels] SchedulesJSON notificationChannels
             */

            /**
             * Constructs a new SchedulesJSON.
             * @memberof dataform.schedules
             * @classdesc Represents a SchedulesJSON.
             * @implements ISchedulesJSON
             * @constructor
             * @param {dataform.schedules.ISchedulesJSON=} [properties] Properties to set
             */
            function SchedulesJSON(properties) {
                this.schedules = [];
                this.notificationChannels = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SchedulesJSON schedules.
             * @member {Array.<dataform.schedules.ISchedule>} schedules
             * @memberof dataform.schedules.SchedulesJSON
             * @instance
             */
            SchedulesJSON.prototype.schedules = $util.emptyArray;

            /**
             * SchedulesJSON notificationChannels.
             * @member {Array.<dataform.schedules.INotificationChannel>} notificationChannels
             * @memberof dataform.schedules.SchedulesJSON
             * @instance
             */
            SchedulesJSON.prototype.notificationChannels = $util.emptyArray;

            /**
             * Creates a new SchedulesJSON instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {dataform.schedules.ISchedulesJSON=} [properties] Properties to set
             * @returns {dataform.schedules.SchedulesJSON} SchedulesJSON instance
             */
            SchedulesJSON.create = function create(properties) {
                return new SchedulesJSON(properties);
            };

            /**
             * Encodes the specified SchedulesJSON message. Does not implicitly {@link dataform.schedules.SchedulesJSON.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {dataform.schedules.ISchedulesJSON} message SchedulesJSON message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SchedulesJSON.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schedules != null && message.schedules.length)
                    for (let i = 0; i < message.schedules.length; ++i)
                        $root.dataform.schedules.Schedule.encode(message.schedules[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.notificationChannels != null && message.notificationChannels.length)
                    for (let i = 0; i < message.notificationChannels.length; ++i)
                        $root.dataform.schedules.NotificationChannel.encode(message.notificationChannels[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SchedulesJSON message, length delimited. Does not implicitly {@link dataform.schedules.SchedulesJSON.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {dataform.schedules.ISchedulesJSON} message SchedulesJSON message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SchedulesJSON.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SchedulesJSON message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.SchedulesJSON} SchedulesJSON
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SchedulesJSON.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.SchedulesJSON();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.schedules && message.schedules.length))
                            message.schedules = [];
                        message.schedules.push($root.dataform.schedules.Schedule.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.notificationChannels && message.notificationChannels.length))
                            message.notificationChannels = [];
                        message.notificationChannels.push($root.dataform.schedules.NotificationChannel.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SchedulesJSON message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.SchedulesJSON} SchedulesJSON
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SchedulesJSON.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SchedulesJSON message.
             * @function verify
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SchedulesJSON.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schedules != null && message.hasOwnProperty("schedules")) {
                    if (!Array.isArray(message.schedules))
                        return "schedules: array expected";
                    for (let i = 0; i < message.schedules.length; ++i) {
                        let error = $root.dataform.schedules.Schedule.verify(message.schedules[i]);
                        if (error)
                            return "schedules." + error;
                    }
                }
                if (message.notificationChannels != null && message.hasOwnProperty("notificationChannels")) {
                    if (!Array.isArray(message.notificationChannels))
                        return "notificationChannels: array expected";
                    for (let i = 0; i < message.notificationChannels.length; ++i) {
                        let error = $root.dataform.schedules.NotificationChannel.verify(message.notificationChannels[i]);
                        if (error)
                            return "notificationChannels." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SchedulesJSON message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.SchedulesJSON} SchedulesJSON
             */
            SchedulesJSON.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.SchedulesJSON)
                    return object;
                let message = new $root.dataform.schedules.SchedulesJSON();
                if (object.schedules) {
                    if (!Array.isArray(object.schedules))
                        throw TypeError(".dataform.schedules.SchedulesJSON.schedules: array expected");
                    message.schedules = [];
                    for (let i = 0; i < object.schedules.length; ++i) {
                        if (typeof object.schedules[i] !== "object")
                            throw TypeError(".dataform.schedules.SchedulesJSON.schedules: object expected");
                        message.schedules[i] = $root.dataform.schedules.Schedule.fromObject(object.schedules[i]);
                    }
                }
                if (object.notificationChannels) {
                    if (!Array.isArray(object.notificationChannels))
                        throw TypeError(".dataform.schedules.SchedulesJSON.notificationChannels: array expected");
                    message.notificationChannels = [];
                    for (let i = 0; i < object.notificationChannels.length; ++i) {
                        if (typeof object.notificationChannels[i] !== "object")
                            throw TypeError(".dataform.schedules.SchedulesJSON.notificationChannels: object expected");
                        message.notificationChannels[i] = $root.dataform.schedules.NotificationChannel.fromObject(object.notificationChannels[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SchedulesJSON message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {dataform.schedules.SchedulesJSON} message SchedulesJSON
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SchedulesJSON.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.schedules = [];
                    object.notificationChannels = [];
                }
                if (message.schedules && message.schedules.length) {
                    object.schedules = [];
                    for (let j = 0; j < message.schedules.length; ++j)
                        object.schedules[j] = $root.dataform.schedules.Schedule.toObject(message.schedules[j], options);
                }
                if (message.notificationChannels && message.notificationChannels.length) {
                    object.notificationChannels = [];
                    for (let j = 0; j < message.notificationChannels.length; ++j)
                        object.notificationChannels[j] = $root.dataform.schedules.NotificationChannel.toObject(message.notificationChannels[j], options);
                }
                return object;
            };

            /**
             * Converts this SchedulesJSON to JSON.
             * @function toJSON
             * @memberof dataform.schedules.SchedulesJSON
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SchedulesJSON.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SchedulesJSON;
        })();

        return schedules;
    })();

    dataform.server = (function() {

        /**
         * Namespace server.
         * @memberof dataform
         * @namespace
         */
        const server = {};

        server.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof dataform.server
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof dataform.server
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {dataform.server.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty=} [properties] Properties to set
             * @returns {dataform.server.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link dataform.server.Empty.verify|verify} messages.
             * @function encode
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link dataform.server.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.server.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.server.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.server.Empty();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.server.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.server.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof dataform.server.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.server.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.server.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.server.Empty)
                    return object;
                return new $root.dataform.server.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof dataform.server.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        server.MetadataResponse = (function() {

            /**
             * Properties of a MetadataResponse.
             * @memberof dataform.server
             * @interface IMetadataResponse
             * @property {string|null} [projectDir] MetadataResponse projectDir
             */

            /**
             * Constructs a new MetadataResponse.
             * @memberof dataform.server
             * @classdesc Represents a MetadataResponse.
             * @implements IMetadataResponse
             * @constructor
             * @param {dataform.server.IMetadataResponse=} [properties] Properties to set
             */
            function MetadataResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MetadataResponse projectDir.
             * @member {string} projectDir
             * @memberof dataform.server.MetadataResponse
             * @instance
             */
            MetadataResponse.prototype.projectDir = "";

            /**
             * Creates a new MetadataResponse instance using the specified properties.
             * @function create
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse=} [properties] Properties to set
             * @returns {dataform.server.MetadataResponse} MetadataResponse instance
             */
            MetadataResponse.create = function create(properties) {
                return new MetadataResponse(properties);
            };

            /**
             * Encodes the specified MetadataResponse message. Does not implicitly {@link dataform.server.MetadataResponse.verify|verify} messages.
             * @function encode
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse} message MetadataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectDir);
                return writer;
            };

            /**
             * Encodes the specified MetadataResponse message, length delimited. Does not implicitly {@link dataform.server.MetadataResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse} message MetadataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MetadataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.server.MetadataResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.projectDir = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MetadataResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MetadataResponse message.
             * @function verify
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetadataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                    if (!$util.isString(message.projectDir))
                        return "projectDir: string expected";
                return null;
            };

            /**
             * Creates a MetadataResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             */
            MetadataResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.server.MetadataResponse)
                    return object;
                let message = new $root.dataform.server.MetadataResponse();
                if (object.projectDir != null)
                    message.projectDir = String(object.projectDir);
                return message;
            };

            /**
             * Creates a plain object from a MetadataResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.MetadataResponse} message MetadataResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetadataResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.projectDir = "";
                if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                    object.projectDir = message.projectDir;
                return object;
            };

            /**
             * Converts this MetadataResponse to JSON.
             * @function toJSON
             * @memberof dataform.server.MetadataResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetadataResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MetadataResponse;
        })();

        server.Service = (function() {

            /**
             * Constructs a new Service service.
             * @memberof dataform.server
             * @classdesc Represents a Service
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Service(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Service.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Service;

            /**
             * Creates new Service service using the specified rpc implementation.
             * @function create
             * @memberof dataform.server.Service
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Service} RPC service. Useful where requests and/or responses are streamed.
             */
            Service.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link dataform.server.Service#metadata}.
             * @memberof dataform.server.Service
             * @typedef MetadataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dataform.server.MetadataResponse} [response] MetadataResponse
             */

            /**
             * Calls Metadata.
             * @function metadata
             * @memberof dataform.server.Service
             * @instance
             * @param {dataform.server.IEmpty} request Empty message or plain object
             * @param {dataform.server.Service.MetadataCallback} callback Node-style callback called with the error, if any, and MetadataResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.metadata = function metadata(request, callback) {
                return this.rpcCall(metadata, $root.dataform.server.Empty, $root.dataform.server.MetadataResponse, request, callback);
            }, "name", { value: "Metadata" });

            /**
             * Calls Metadata.
             * @function metadata
             * @memberof dataform.server.Service
             * @instance
             * @param {dataform.server.IEmpty} request Empty message or plain object
             * @returns {Promise<dataform.server.MetadataResponse>} Promise
             * @variation 2
             */

            return Service;
        })();

        return server;
    })();

    return dataform;
})();

function relativePath(fullPath, base) {
    if (base.length === 0) {
        return fullPath;
    }
    const stripped = fullPath.substr(base.length);
    if (stripped.startsWith(path.sep)) {
        return stripped.substr(1);
    }
    else {
        return stripped;
    }
}
function matchPatterns(patterns, values) {
    const fullyQualifiedActions = [];
    patterns.forEach(pattern => {
        if (pattern.includes(".")) {
            if (values.includes(pattern)) {
                fullyQualifiedActions.push(pattern);
            }
        }
        else {
            const matchingActions = values.filter(value => pattern === value.split(".").slice(-1)[0]);
            if (matchingActions.length === 0) {
                return;
            }
            if (matchingActions.length > 1) {
                throw new Error(ambiguousActionNameMsg(pattern, matchingActions));
            }
            fullyQualifiedActions.push(matchingActions[0]);
        }
    });
    return fullyQualifiedActions;
}
function getCallerFile(rootDir) {
    let lastfile;
    const stack = getCurrentStack();
    while (stack.length) {
        const nextLastfile = stack.shift().getFileName();
        if (!nextLastfile) {
            continue;
        }
        if (!nextLastfile.includes(rootDir)) {
            continue;
        }
        if (nextLastfile.includes("node_modules")) {
            continue;
        }
        lastfile = nextLastfile;
        if (!(nextLastfile.includes(`definitions${path.sep}`) ||
            nextLastfile.includes(`models${path.sep}`))) {
            continue;
        }
        break;
    }
    if (!lastfile) {
        throw new Error("Unable to find valid caller file; please report this issue.");
    }
    return relativePath(lastfile, rootDir);
}
function getCurrentStack() {
    const originalStackTraceLimit = Error.stackTraceLimit;
    const originalPrepareStackTrace = Error.prepareStackTrace;
    try {
        Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        Error.prepareStackTrace = (err, stack) => {
            return stack;
        };
        return new Error().stack;
    }
    finally {
        Error.stackTraceLimit = originalStackTraceLimit;
        Error.prepareStackTrace = originalPrepareStackTrace;
    }
}
function graphHasErrors(graph) {
    var _a;
    return ((_a = graph.graphErrors) === null || _a === void 0 ? void 0 : _a.compilationErrors.length) > 0;
}
const invalidRefInputMessage = "Invalid input. Accepted inputs include: a single object containing " +
    "an (optional) 'database', (optional) 'schema', and 'name', " +
    "or 1-3 inputs consisting of an (optional) database, (optional) schema, and 'name'.";
function toResolvable(ref, rest = []) {
    if (Array.isArray(ref) && rest.length > 0) {
        throw new Error(invalidRefInputMessage);
    }
    if (rest.length === 0 && !Array.isArray(ref)) {
        return ref;
    }
    const resolvableArray = Array.isArray(ref) ? ref.reverse() : [ref, ...rest].reverse();
    if (!isResolvableArray(resolvableArray)) {
        throw new Error(invalidRefInputMessage);
    }
    const [name, schema, database] = resolvableArray;
    return { database, schema, name };
}
function isResolvableArray(parts) {
    if (parts.some(part => typeof part !== "string")) {
        return false;
    }
    return parts.length > 0 && parts.length <= 3;
}
function resolvableAsTarget(resolvable) {
    if (typeof resolvable === "string") {
        return {
            name: resolvable
        };
    }
    return resolvable;
}
function stringifyResolvable(res) {
    return typeof res === "string" ? res : JSON.stringify(res);
}
function ambiguousActionNameMsg(act, allActs) {
    const allActNames = typeof allActs[0] === "string"
        ? allActs
        : allActs.map(r => `${r.proto.target.schema}.${r.proto.target.name}`);
    return `Ambiguous Action name: ${stringifyResolvable(act)}. Did you mean one of: ${allActNames.join(", ")}.`;
}
function target(adapter, config, name, schema, database) {
    schema = schema || config.defaultSchema;
    database = database || config.defaultDatabase;
    return dataform.Target.create({
        name: adapter.normalizeIdentifier(name),
        schema: !!schema ? adapter.normalizeIdentifier(schema || config.defaultSchema) : undefined,
        database: !!database ? adapter.normalizeIdentifier(database) : undefined
    });
}
function setNameAndTarget(session, action, name, overrideSchema, overrideDatabase) {
    action.target = target(session.adapter(), session.config, name, overrideSchema, overrideDatabase);
    action.canonicalTarget = target(session.adapter(), session.canonicalConfig, name, overrideSchema, overrideDatabase);
    action.name = targetToName(action.target);
}
function targetToName(actionTarget) {
    const nameParts = [actionTarget.name, actionTarget.schema];
    if (!!actionTarget.database) {
        nameParts.push(actionTarget.database);
    }
    return nameParts.reverse().join(".");
}
function strictKeysOf() {
    return (array) => array;
}
function checkExcessProperties(reportError, object, supportedProperties, name) {
    const extraProperties = Object.keys(object).filter(key => !supportedProperties.includes(key));
    if (extraProperties.length > 0) {
        reportError(new Error(`Unexpected property "${extraProperties[0]}"${!!name ? ` in ${name}` : ""}. Supported properties are: ${JSON.stringify(supportedProperties)}`));
    }
}
function validateQueryString(session, query, filename) {
    if ((query === null || query === void 0 ? void 0 : query.trim().slice(-1)) === ";") {
        session.compileError(new Error("Semi-colons are not allowed at the end of SQL statements."), filename);
    }
}

function prune(compiledGraph, runConfig) {
    const includedActionNames = computeIncludedActionNames(compiledGraph, runConfig);
    return Object.assign(Object.assign({}, compiledGraph), { tables: compiledGraph.tables.filter(action => includedActionNames.has(action.name)), assertions: compiledGraph.assertions.filter(action => includedActionNames.has(action.name)), operations: compiledGraph.operations.filter(action => includedActionNames.has(action.name)) });
}
function computeIncludedActionNames(compiledGraph, runConfig) {
    var _a, _b, _c;
    const filteredTables = compiledGraph.tables.filter(t => t.type !== "inline");
    const allActions = [].concat(filteredTables, compiledGraph.operations, compiledGraph.assertions);
    const allActionNames = allActions.map(n => n.name);
    const allActionsByName = {};
    allActions.forEach(action => (allActionsByName[action.name] = action));
    const hasActionSelector = ((_a = runConfig.actions) === null || _a === void 0 ? void 0 : _a.length) > 0;
    const hasTagSelector = ((_b = runConfig.tags) === null || _b === void 0 ? void 0 : _b.length) > 0;
    if (!hasActionSelector && !hasTagSelector) {
        return new Set(allActionNames);
    }
    const includedActionNames = new Set();
    if (hasActionSelector) {
        matchPatterns(runConfig.actions, allActionNames)
            .forEach(actionName => includedActionNames.add(actionName));
    }
    if (hasTagSelector) {
        allActions
            .filter(action => action.tags.some(tag => runConfig.tags.includes(tag)))
            .forEach(action => includedActionNames.add(action.name));
    }
    if (runConfig.includeDependencies) {
        const queue = [...includedActionNames];
        while (queue.length > 0) {
            const actionName = queue.pop();
            const action = allActionsByName[actionName];
            const matchingDependencyNames = ((_c = action.dependencies) === null || _c === void 0 ? void 0 : _c.length) > 0
                ? matchPatterns(action.dependencies, allActionNames)
                : [];
            matchingDependencyNames.forEach(dependencyName => {
                if (!includedActionNames.has(dependencyName)) {
                    queue.push(dependencyName);
                    includedActionNames.add(dependencyName);
                }
            });
        }
    }
    if (runConfig.includeDependents) {
        const queue = [...includedActionNames];
        while (queue.length > 0) {
            const actionName = queue.pop();
            const matchingDependentNames = allActions
                .filter(compileAction => matchPatterns([actionName], compileAction.dependencies || []).length >= 1)
                .map(compileAction => compileAction.name);
            matchingDependentNames.forEach(dependentName => {
                if (!includedActionNames.has(dependentName)) {
                    queue.push(dependentName);
                    includedActionNames.add(dependentName);
                }
            });
        }
    }
    [...compiledGraph.assertions].forEach(assertion => {
        if (!!assertion.parentAction) {
            if (includedActionNames.has(targetToName(assertion.parentAction))) {
                includedActionNames.add(targetToName(assertion.target));
            }
        }
    });
    return includedActionNames;
}

async function state(dbadapter, targets) {
    const allTables = await Promise.all(targets.map(async (target) => dbadapter.table(target)));
    const tablesWithValues = allTables.filter(table => {
        return !!table && !!table.type;
    });
    return { tables: tablesWithValues };
}

class JSONObjectStringifier {
    static create() {
        return new JSONObjectStringifier();
    }
    stringify(value) {
        return JSON.stringify(Object.keys(value)
            .sort()
            .reduce((acc, curr) => (Object.assign(Object.assign({}, acc), { [curr]: value[curr] })), {}));
    }
    parse(value) {
        return JSON.parse(value);
    }
}
class StringifiedMap {
    constructor(stringifier, entries) {
        this.stringifier = stringifier;
        if (entries) {
            this.map = new Map(entries.map(([key, value]) => [stringifier.stringify(key), value]));
        }
        else {
            this.map = new Map();
        }
    }
    get [Symbol.toStringTag]() {
        return StringifiedMap.name;
    }
    get size() {
        return this.map.size;
    }
    clear() {
        return this.map.clear();
    }
    delete(key) {
        return this.map.delete(this.stringifier.stringify(key));
    }
    forEach(callbackfn, thisArg) {
        return this.map.forEach((value, key, _) => callbackfn(value, this.stringifier.parse(key), null), thisArg);
    }
    get(key) {
        return this.map.get(this.stringifier.stringify(key));
    }
    has(key) {
        return this.map.has(this.stringifier.stringify(key));
    }
    set(key, value) {
        this.map.set(this.stringifier.stringify(key), value);
        return this;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        const stringifier = this.stringifier;
        const innerIterator = this.map[Symbol.iterator]();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? [stringifier.parse(next.value[0]), next.value[1]] : undefined,
                    done: next.done
                };
            }
        })();
    }
    keys() {
        const stringifier = this.stringifier;
        const innerIterator = this.map.keys();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? stringifier.parse(next.value) : undefined,
                    done: next.done
                };
            }
        })();
    }
    values() {
        return this.map.values();
    }
}
class StringifiedSet {
    constructor(stringifier, values) {
        this.stringifier = stringifier;
        if (values) {
            this.set = new Set(values.map(value => stringifier.stringify(value)));
        }
        else {
            this.set = new Set();
        }
    }
    get size() {
        return this.set.size;
    }
    get [Symbol.toStringTag]() {
        return StringifiedSet.name;
    }
    add(value) {
        this.set.add(this.stringifier.stringify(value));
        return this;
    }
    clear() {
        return this.set.clear();
    }
    delete(value) {
        return this.set.delete(this.stringifier.stringify(value));
    }
    forEach(callbackfn, thisArg) {
        return this.set.forEach((value, value2, _) => callbackfn(this.stringifier.parse(value), this.stringifier.parse(value2), null), thisArg);
    }
    has(value) {
        return this.set.has(this.stringifier.stringify(value));
    }
    [Symbol.iterator]() {
        return this.keys();
    }
    entries() {
        const stringifier = this.stringifier;
        const innerIterator = this.set[Symbol.iterator]();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? [stringifier.parse(next.value[0]), next.value[1]] : undefined,
                    done: next.done
                };
            }
        })();
    }
    keys() {
        const stringifier = this.stringifier;
        const innerIterator = this.set.keys();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? stringifier.parse(next.value) : undefined,
                    done: next.done
                };
            }
        })();
    }
    values() {
        const stringifier = this.stringifier;
        const innerIterator = this.set.values();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? stringifier.parse(next.value) : undefined,
                    done: next.done
                };
            }
        })();
    }
}

const combineAllActions = (graph) => {
    return [].concat(graph.tables || [], graph.operations || [], graph.assertions || [], graph.declarations || []);
};
function actionsByTarget(compiledGraph) {
    return new StringifiedMap(JSONObjectStringifier.create(), combineAllActions(compiledGraph)
        .filter(action => !!action.target)
        .map(action => [action.target, action]));
}

class ErrorWithCause extends Error {
    constructor(message, cause) {
        super(typeof message === "string" ? message : undefined);
        this.cause = cause;
        if (typeof message !== "string") {
            this.cause = message;
        }
        if (this.cause) {
            this.stack += `\nCaused by: ${this.cause.stack}`;
        }
    }
}
function coerceAsError(errorLike) {
    if (errorLike instanceof Error) {
        return errorLike;
    }
    const message = errorLike.message ? String(errorLike.message) : String(errorLike);
    const coercedError = new Error(message);
    if (errorLike.stack) {
        coercedError.stack = errorLike.stack;
    }
    if (errorLike.name) {
        coercedError.name = errorLike.name;
    }
    return coercedError;
}

function concatenateQueries(statements, modifier) {
    return statements
        .filter(statement => !!statement)
        .map(statement => statement.trim())
        .map(statement => statement.length > 0 && statement.charAt(statement.length - 1) === ";"
        ? statement.substring(0, statement.length - 1)
        : statement)
        .map(statement => (!!modifier ? modifier(statement) : statement))
        .join(";\n");
}
class Tasks {
    constructor() {
        this.tasks = [];
    }
    static create() {
        return new Tasks();
    }
    add(task) {
        this.tasks.push(task);
        return this;
    }
    addAll(tasks) {
        this.tasks = this.tasks.concat(tasks.tasks);
        return this;
    }
    build() {
        return this.tasks.map(task => task.build());
    }
    concatenate() {
        return Tasks.create().add(Task.statement(concatenateQueries(this.tasks.map(task => task.getStatement()))));
    }
}
class Task {
    constructor() {
        this.proto = dataform.ExecutionTask.create();
    }
    static create() {
        return new Task();
    }
    static statement(statement) {
        return Task.create()
            .type("statement")
            .statement(statement);
    }
    static assertion(statement) {
        return Task.create()
            .type("assertion")
            .statement(statement);
    }
    type(v) {
        this.proto.type = v;
        return this;
    }
    statement(v) {
        this.proto.statement = v;
        return this;
    }
    getStatement() {
        return this.proto.statement;
    }
    build() {
        return dataform.ExecutionTask.create(this.proto);
    }
}

class Adapter {
    constructor(dataformCoreVersion) {
        this.dataformCoreVersion = dataformCoreVersion;
    }
    normalizeIdentifier(identifier) {
        return identifier;
    }
    sqlString(stringContents) {
        return `'${stringContents.replace(/\\/g, "\\\\").replace(/'/g, "\\'")}'`;
    }
    dropIfExists(target, type) {
        return `drop ${this.tableTypeAsSql(type)} if exists ${this.resolveTarget(target)} ${type === dataform.TableMetadata.Type.TABLE ? "cascade" : ""}`;
    }
    baseTableType(type) {
        switch (type) {
            case "table":
            case "incremental":
                return dataform.TableMetadata.Type.TABLE;
            case "view":
                return dataform.TableMetadata.Type.VIEW;
            default:
                throw new Error(`Unexpected table type: ${type}`);
        }
    }
    tableTypeAsSql(type) {
        switch (type) {
            case dataform.TableMetadata.Type.TABLE:
                return "table";
            case dataform.TableMetadata.Type.VIEW:
                return "view";
            default:
                throw new Error(`Unexpected table type: ${type}`);
        }
    }
    indexAssertion(dataset, indexCols) {
        const commaSeparatedColumns = indexCols.join(", ");
        return `
SELECT
  *
FROM (
  SELECT
    ${commaSeparatedColumns},
    COUNT(1) AS index_row_count
  FROM ${dataset}
  GROUP BY ${commaSeparatedColumns}
  ) AS data
WHERE index_row_count > 1
`;
    }
    rowConditionsAssertion(dataset, rowConditions) {
        return rowConditions
            .map((rowCondition) => `
SELECT
  ${this.sqlString(rowCondition)} AS failing_row_condition,
  *
FROM ${dataset}
WHERE NOT (${rowCondition})
`)
            .join(`UNION ALL`);
    }
    insertInto(target, columns, query) {
        return `	
insert into ${this.resolveTarget(target)}	
(${columns.join(",")})	
select ${columns.join(",")}	
from (${query}) as insertions`;
    }
    oppositeTableType(type) {
        switch (type) {
            case dataform.TableMetadata.Type.TABLE:
                return dataform.TableMetadata.Type.VIEW;
            case dataform.TableMetadata.Type.VIEW:
                return dataform.TableMetadata.Type.TABLE;
            default:
                throw new Error(`Unexpected table type: ${type}`);
        }
    }
    where(query, where) {
        return where
            ? `
  select * from (${query}) as subquery
    where ${where}`
            : query;
    }
    shouldWriteIncrementally(runConfig, tableMetadata) {
        return (!runConfig.fullRefresh &&
            tableMetadata &&
            tableMetadata.type !== dataform.TableMetadata.Type.VIEW);
    }
    preOps(table, runConfig, tableMetadata) {
        let preOps = table.preOps;
        if (semver.gt(this.dataformCoreVersion, "1.4.8") &&
            table.type === "incremental" &&
            this.shouldWriteIncrementally(runConfig, tableMetadata)) {
            preOps = table.incrementalPreOps;
        }
        return (preOps || []).map(pre => Task.statement(pre));
    }
    postOps(table, runConfig, tableMetadata) {
        let postOps = table.postOps;
        if (semver.gt(this.dataformCoreVersion, "1.4.8") &&
            table.type === "incremental" &&
            this.shouldWriteIncrementally(runConfig, tableMetadata)) {
            postOps = table.incrementalPostOps;
        }
        return (postOps || []).map(post => Task.statement(post));
    }
}

class BigQueryAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    resolveTarget(target) {
        return `\`${target.database || this.project.defaultDatabase}.${target.schema ||
            this.project.defaultSchema}.${target.name}\``;
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            if (!this.shouldWriteIncrementally(runConfig, tableMetadata)) {
                tasks.add(Task.statement(this.createOrReplace(table)));
            }
            else {
                tasks.add(Task.statement(table.uniqueKey && table.uniqueKey.length > 0
                    ? this.mergeInto(table.target, tableMetadata === null || tableMetadata === void 0 ? void 0 : tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where), table.uniqueKey, table.bigquery && table.bigquery.updatePartitionFilter)
                    : this.insertInto(table.target, tableMetadata === null || tableMetadata === void 0 ? void 0 : tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where))));
            }
        }
        else {
            tasks.add(Task.statement(this.createOrReplace(table)));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks.concatenate();
    }
    assertTasks(assertion, projectConfig) {
        const tasks = Tasks.create();
        const target = assertion.target ||
            dataform.Target.create({
                schema: projectConfig.assertionSchema,
                name: assertion.name
            });
        tasks.add(Task.statement(this.createOrReplaceView(target, assertion.query)));
        tasks.add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
        return tasks;
    }
    dropIfExists(target, type) {
        return `drop ${this.tableTypeAsSql(type)} if exists ${this.resolveTarget(target)}`;
    }
    createOrReplace(table) {
        return `create or replace ${this.tableTypeAsSql(this.baseTableType(table.type))} ${this.resolveTarget(table.target)} ${table.bigquery && table.bigquery.partitionBy
            ? `partition by ${table.bigquery.partitionBy} `
            : ""}${table.bigquery && table.bigquery.clusterBy && table.bigquery.clusterBy.length > 0
            ? `cluster by ${table.bigquery.clusterBy.join(", ")} `
            : ""}as ${table.query}`;
    }
    createOrReplaceView(target, query) {
        return `
      create or replace view ${this.resolveTarget(target)} as ${query}`;
    }
    mergeInto(target, columns, query, uniqueKey, updatePartitionFilter) {
        return `
merge ${this.resolveTarget(target)} T
using (${query}
) S
on ${uniqueKey.map(uniqueKeyCol => `T.${uniqueKeyCol} = S.${uniqueKeyCol}`).join(` and `)}
  ${updatePartitionFilter ? `and T.${updatePartitionFilter}` : ""}
when matched then
  update set ${columns.map(column => `${column} = S.${column}`).join(",")}
when not matched then
  insert (${columns.join(",")}) values (${columns.join(",")})`;
    }
}

class PrestoAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    resolveTarget(target) {
        return `"${target.database || this.project.defaultDatabase}"."${target.schema ||
            this.project.defaultSchema}"."${target.name}"`;
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            throw new Error("Incremental table types are not currently supported for Presto.");
        }
        else {
            tasks.add(Task.statement(this.createOrReplace(table)));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks.concatenate();
    }
    assertTasks(assertion, projectConfig) {
        const tasks = Tasks.create();
        const target = assertion.target ||
            dataform.Target.create({
                schema: projectConfig.assertionSchema,
                name: assertion.name
            });
        tasks.add(Task.statement(this.createOrReplaceView(target, assertion.query)));
        tasks.add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
        return tasks;
    }
    createOrReplaceView(target, query) {
        return `create or replace view ${this.resolveTarget(target)} as ${query}`;
    }
    createTable(table) {
        var _a, _b;
        return `create table if not exists ${this.resolveTarget(table.target)} as ${table.query} ${((_a = table.presto) === null || _a === void 0 ? void 0 : _a.partitionBy) ? `with (partitioned_by = array[${(_b = table.presto) === null || _b === void 0 ? void 0 : _b.partitionBy.join(", ")}]`
            : ""}`;
    }
    dropTableIfExists(target, type) {
        return `drop ${this.tableTypeAsSql(type)} if exists ${this.resolveTarget(target)}`;
    }
    createOrReplace(table) {
        return this.createTable(table);
    }
    mergeInto() {
        throw new Error("mergeInto unimplemented for Presto.");
    }
}

class RedshiftAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    resolveTarget(target) {
        return `"${target.schema}"."${target.name}"`;
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            if (!this.shouldWriteIncrementally(runConfig, tableMetadata)) {
                tasks.addAll(this.createOrReplace(table));
            }
            else {
                tasks.addAll(table.uniqueKey && table.uniqueKey.length > 0
                    ? this.mergeInto(table.target, this.where(table.incrementalQuery || table.query, table.where), table.uniqueKey)
                    : Tasks.create().add(Task.statement(this.insertInto(table.target, tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where)))));
            }
        }
        else {
            tasks.addAll(this.createOrReplace(table));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks;
    }
    assertTasks(assertion, projectConfig) {
        const target = assertion.target ||
            dataform.Target.create({
                schema: projectConfig.assertionSchema,
                name: assertion.name
            });
        return Tasks.create()
            .add(Task.statement(this.dropIfExists(target, dataform.TableMetadata.Type.VIEW)))
            .add(Task.statement(this.createOrReplaceView(target, assertion.query, false)))
            .add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
    }
    dropIfExists(target, type) {
        const query = `drop ${this.tableTypeAsSql(type)} if exists ${this.resolveTarget(target)}`;
        if (this.project.warehouse === "postgres" || this.isBindSupported()) {
            return `${query} cascade`;
        }
        return query;
    }
    createOrReplaceView(target, query, bind) {
        const createQuery = `create or replace view ${this.resolveTarget(target)} as ${query}`;
        if (bind || this.project.warehouse === "postgres") {
            return createQuery;
        }
        return `${createQuery} with no schema binding`;
    }
    createOrReplace(table) {
        if (table.type === "view") {
            const isBindDefined = table.redshift && table.redshift.hasOwnProperty("bind");
            const bindDefaultValue = semver.gte(this.dataformCoreVersion, "1.4.1") ? false : true;
            const bind = (isBindDefined ? table.redshift.bind : bindDefaultValue) && this.isBindSupported();
            return (Tasks.create()
                .add(Task.statement(this.dropIfExists(table.target, this.baseTableType(table.type))))
                .add(Task.statement(this.createOrReplaceView(table.target, table.query, bind))));
        }
        const tempTableTarget = dataform.Target.create({
            schema: table.target.schema,
            name: table.target.name + "_temp"
        });
        return Tasks.create()
            .add(Task.statement(this.dropIfExists(tempTableTarget, this.baseTableType(table.type))))
            .add(Task.statement(this.createTable(table, tempTableTarget)))
            .add(Task.statement(this.dropIfExists(table.target, dataform.TableMetadata.Type.TABLE)))
            .add(Task.statement(`alter table ${this.resolveTarget(tempTableTarget)} rename to "${table.target.name}"`));
    }
    createTable(table, target) {
        if (table.redshift) {
            let query = `create table ${this.resolveTarget(target)}`;
            if (table.redshift.distStyle && table.redshift.distKey) {
                query = `${query} diststyle ${table.redshift.distStyle} distkey (${table.redshift.distKey})`;
            }
            if (table.redshift.sortStyle && table.redshift.sortKeys) {
                query = `${query} ${table.redshift.sortStyle} sortkey (${table.redshift.sortKeys.join(", ")})`;
            }
            return `${query} as ${table.query}`;
        }
        return `create table ${this.resolveTarget(target)} as ${table.query}`;
    }
    mergeInto(target, query, uniqueKey) {
        const finalTarget = this.resolveTarget(target);
        const tempTarget = `"${target.schema}__${target.name}_incremental_temp"`;
        return Tasks.create()
            .add(Task.statement(`drop table if exists ${tempTarget};`))
            .add(Task.statement(`create temp table ${tempTarget} as select * from (${query}
) as data;`))
            .add(Task.statement(`begin transaction;`))
            .add(Task.statement(`delete from ${finalTarget} using ${tempTarget} where ${uniqueKey
            .map(uniqueKeyCol => `${finalTarget}."${uniqueKeyCol}" = ${tempTarget}."${uniqueKeyCol}"`)
            .join(` and `)};`))
            .add(Task.statement(`insert into ${finalTarget} select * from ${tempTarget};`))
            .add(Task.statement(`end transaction;`))
            .add(Task.statement(`drop table ${tempTarget};`));
    }
    isBindSupported() {
        return semver.lte(this.dataformCoreVersion, "1.10.0");
    }
}

class SnowflakeAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    resolveTarget(target) {
        return `${!!target.database ? `"${target.database}".` : ""}"${target.schema}"."${target.name}"`;
    }
    normalizeIdentifier(identifier) {
        return identifier.toUpperCase();
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            if (!this.shouldWriteIncrementally(runConfig, tableMetadata)) {
                tasks.add(Task.statement(this.createOrReplace(table)));
            }
            else {
                tasks.add(Task.statement(table.uniqueKey && table.uniqueKey.length > 0
                    ? this.mergeInto(table.target, tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where), table.uniqueKey)
                    : this.insertInto(table.target, tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where))));
            }
        }
        else {
            tasks.add(Task.statement(this.createOrReplace(table)));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks;
    }
    assertTasks(assertion, projectConfig) {
        const tasks = Tasks.create();
        const target = assertion.target ||
            dataform.Target.create({
                schema: projectConfig.assertionSchema,
                name: assertion.name
            });
        tasks.add(Task.statement(this.createOrReplaceView(target, assertion.query, false)));
        tasks.add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
        return tasks;
    }
    createOrReplaceView(target, query, secure) {
        return `create or replace ${secure ? "secure " : ""}view ${this.resolveTarget(target)} as ${query}`;
    }
    createOrReplace(table) {
        var _a, _b, _c, _d, _e;
        if (table.type === "view") {
            return this.createOrReplaceView(table.target, table.query, (_a = table.snowflake) === null || _a === void 0 ? void 0 : _a.secure);
        }
        return `create or replace ${((_b = table.snowflake) === null || _b === void 0 ? void 0 : _b.transient) ? "transient " : ""}table ${this.resolveTarget(table.target)} ${((_d = (_c = table.snowflake) === null || _c === void 0 ? void 0 : _c.clusterBy) === null || _d === void 0 ? void 0 : _d.length) > 0
            ? `cluster by (${(_e = table.snowflake) === null || _e === void 0 ? void 0 : _e.clusterBy.join(", ")}) `
            : ""}as ${table.query}`;
    }
    mergeInto(target, columns, query, uniqueKey) {
        return `
merge into ${this.resolveTarget(target)} T
using (${query}
) S
on ${uniqueKey.map(uniqueKeyCol => `T.${uniqueKeyCol} = S.${uniqueKeyCol}`).join(` and `)}
when matched then
  update set ${columns.map(column => `${column} = S.${column}`).join(",")}
when not matched then
  insert (${columns.join(",")}) values (${columns.join(",")})`;
    }
}

class SQLDataWarehouseAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    sqlString(stringContents) {
        return `'${stringContents.replace(/'/g, "''")}'`;
    }
    resolveTarget(target) {
        return `"${target.schema}"."${target.name}"`;
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            if (!this.shouldWriteIncrementally(runConfig, tableMetadata)) {
                tasks.addAll(this.createOrReplace(table, !!tableMetadata));
            }
            else {
                tasks.add(Task.statement(this.insertInto(table.target, tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where))));
            }
        }
        else {
            tasks.addAll(this.createOrReplace(table, !!tableMetadata));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks.concatenate();
    }
    assertTasks(assertion, projectConfig) {
        const target = assertion.target ||
            dataform.Target.create({
                schema: projectConfig.assertionSchema,
                name: assertion.name
            });
        return Tasks.create()
            .add(Task.statement(this.dropIfExists(target, dataform.TableMetadata.Type.VIEW)))
            .add(Task.statement(`
        create view ${this.resolveTarget(target)}
        as ${assertion.query}`))
            .add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
    }
    dropIfExists(target, type) {
        if (type === dataform.TableMetadata.Type.VIEW) {
            return `drop view if exists ${this.resolveTarget(target)} `;
        }
        return `if object_id ('${this.resolveTarget(target)}','U') is not null drop table ${this.resolveTarget(target)}`;
    }
    insertInto(target, columns, query) {
        return `
insert into ${this.resolveTarget(target)}
(${columns.join(",")})
select ${columns.join(",")}
from (${query}
) as insertions`;
    }
    createOrReplace(table, alreadyExists) {
        if (table.type === "view") {
            return Tasks.create().add(Task.statement(`${alreadyExists ? "alter" : "create"} view ${this.resolveTarget(table.target)} as ${table.query}`));
        }
        const tempTableTarget = dataform.Target.create({
            schema: table.target.schema,
            name: table.target.name + "_temp"
        });
        return Tasks.create()
            .add(Task.statement(this.dropIfExists(tempTableTarget, this.baseTableType(table.type))))
            .add(Task.statement(this.createTable(table, tempTableTarget)))
            .add(Task.statement(this.dropIfExists(table.target, dataform.TableMetadata.Type.TABLE)))
            .add(Task.statement(`rename object ${this.resolveTarget(tempTableTarget)} to ${table.target.name} `));
    }
    createTable(table, target) {
        const distribution = table.sqlDataWarehouse && table.sqlDataWarehouse.distribution
            ? table.sqlDataWarehouse.distribution
            : "ROUND_ROBIN";
        return `create table ${this.resolveTarget(target)}
     with(
       distribution = ${distribution}
     ) 
     as ${table.query}`;
    }
}

var WarehouseType;
(function (WarehouseType) {
    WarehouseType["BIGQUERY"] = "bigquery";
    WarehouseType["PRESTO"] = "presto";
    WarehouseType["POSTGRES"] = "postgres";
    WarehouseType["REDSHIFT"] = "redshift";
    WarehouseType["SNOWFLAKE"] = "snowflake";
    WarehouseType["SQLDATAWAREHOUSE"] = "sqldatawarehouse";
})(WarehouseType || (WarehouseType = {}));
const CANCELLATION_SUPPORTED = [WarehouseType.BIGQUERY, WarehouseType.SQLDATAWAREHOUSE];
function supportsCancel(warehouseType) {
    return CANCELLATION_SUPPORTED.some(w => {
        return w === warehouseType;
    });
}
const requiredBigQueryWarehouseProps = [
    "projectId",
    "credentials"
];
const requiredJdbcWarehouseProps = [
    "host",
    "port",
    "username",
    "password",
    "databaseName"
];
const requiredSnowflakeWarehouseProps = [
    "accountId",
    "username",
    "password",
    "role",
    "databaseName",
    "warehouse"
];
const requiredSQLDataWarehouseProps = [
    "server",
    "port",
    "username",
    "password",
    "database"
];
const requiredPrestoWarehouseProps = ["host", "port", "user"];
const requiredWarehouseProps = {
    [WarehouseType.BIGQUERY]: requiredBigQueryWarehouseProps,
    [WarehouseType.POSTGRES]: requiredJdbcWarehouseProps,
    [WarehouseType.REDSHIFT]: requiredJdbcWarehouseProps,
    [WarehouseType.SNOWFLAKE]: requiredSnowflakeWarehouseProps,
    [WarehouseType.SQLDATAWAREHOUSE]: requiredSQLDataWarehouseProps,
    [WarehouseType.PRESTO]: requiredPrestoWarehouseProps
};
const registry = {};
function register(warehouseType, c) {
    registry[warehouseType] = c;
}
function create(projectConfig, dataformCoreVersion) {
    if (!registry[projectConfig.warehouse]) {
        throw new Error(`Unsupported warehouse: ${projectConfig.warehouse}`);
    }
    return new registry[projectConfig.warehouse](projectConfig, dataformCoreVersion);
}
register("bigquery", BigQueryAdapter);
register("presto", PrestoAdapter);
register("postgres", RedshiftAdapter);
register("redshift", RedshiftAdapter);
register("snowflake", SnowflakeAdapter);
register("sqldatawarehouse", SQLDataWarehouseAdapter);
function collectEvaluationQueries(queryOrAction, concatenate, queryModifier = (q) => q) {
    const validationQueries = new Array();
    if (typeof queryOrAction === "string") {
        validationQueries.push({ query: queryModifier(queryOrAction) });
    }
    else {
        try {
            if (queryOrAction instanceof dataform.Table) {
                if (queryOrAction.type === "incremental") {
                    const incrementalTableQueries = queryOrAction.incrementalPreOps.concat(queryOrAction.incrementalQuery, queryOrAction.incrementalPostOps);
                    if (concatenate) {
                        validationQueries.push({
                            query: concatenateQueries(incrementalTableQueries, queryModifier),
                            incremental: true
                        });
                    }
                    else {
                        incrementalTableQueries.forEach(q => validationQueries.push({ query: queryModifier(q), incremental: true }));
                    }
                }
                const tableQueries = queryOrAction.preOps.concat(queryOrAction.query, queryOrAction.postOps);
                if (concatenate) {
                    validationQueries.push({
                        query: concatenateQueries(tableQueries, queryModifier)
                    });
                }
                else {
                    tableQueries.forEach(q => validationQueries.push({ query: queryModifier(q) }));
                }
            }
            else if (queryOrAction instanceof dataform.Operation) {
                if (concatenate) {
                    validationQueries.push({
                        query: concatenateQueries(queryOrAction.queries, queryModifier)
                    });
                }
                else {
                    queryOrAction.queries.forEach(q => validationQueries.push({ query: queryModifier(q) }));
                }
            }
            else if (queryOrAction instanceof dataform.Assertion) {
                validationQueries.push({ query: queryModifier(queryOrAction.query) });
            }
            else {
                throw new Error("Unrecognized evaluate type.");
            }
        }
        catch (e) {
            throw new ErrorWithCause(`Error building tasks for evaluation. ${e.message}`, e);
        }
    }
    return validationQueries
        .map(validationQuery => dataform.ValidationQuery.create(Object.assign({ query: validationQuery.query.trim() }, validationQuery)))
        .filter(validationQuery => !!validationQuery.query);
}

const IAssertionConfigProperties = strictKeysOf()([
    "database",
    "dependencies",
    "description",
    "disabled",
    "hermetic",
    "name",
    "schema",
    "tags",
    "type"
]);
class Assertion {
    constructor() {
        this.proto = dataform.Assertion.create();
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, IAssertionConfigProperties, "assertion config");
        if (config.dependencies) {
            this.dependencies(config.dependencies);
        }
        if (config.hermetic !== undefined) {
            this.hermetic(config.hermetic);
        }
        if (config.disabled) {
            this.disabled();
        }
        if (config.tags) {
            this.tags(config.tags);
        }
        if (config.description) {
            this.description(config.description);
        }
        if (config.database) {
            this.database(config.database);
        }
        if (config.schema) {
            this.schema(config.schema);
        }
        return this;
    }
    query(query) {
        this.contextableQuery = query;
        return this;
    }
    dependencies(value) {
        const newDependencies = Array.isArray(value) ? value : [value];
        newDependencies.forEach(resolvable => {
            this.proto.dependencyTargets.push(resolvableAsTarget(resolvable));
        });
        return this;
    }
    hermetic(hermetic) {
        this.proto.hermeticity = hermetic
            ? dataform.ActionHermeticity.HERMETIC
            : dataform.ActionHermeticity.NON_HERMETIC;
    }
    disabled() {
        this.proto.disabled = true;
        return this;
    }
    tags(value) {
        const newTags = typeof value === "string" ? [value] : value;
        newTags.forEach(t => {
            if (this.proto.tags.indexOf(t) < 0) {
                this.proto.tags.push(t);
            }
        });
        return this;
    }
    description(description) {
        this.proto.actionDescriptor = { description };
        return this;
    }
    database(database) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, this.proto.target.schema, database);
        return this;
    }
    schema(schema) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, schema, this.proto.target.database);
        return this;
    }
    compile() {
        const context = new AssertionContext(this);
        this.proto.query = context.apply(this.contextableQuery);
        validateQueryString(this.session, this.proto.query, this.proto.fileName);
        return this.proto;
    }
}
class AssertionContext {
    constructor(assertion) {
        this.assertion = assertion;
    }
    self() {
        return this.resolve(this.assertion.proto.target);
    }
    name() {
        return this.assertion.proto.target.name;
    }
    ref(ref, ...rest) {
        ref = toResolvable(ref, rest);
        if (!resolvableAsTarget(ref)) {
            const message = `Action name is not specified`;
            this.assertion.session.compileError(new Error(message));
            return "";
        }
        this.assertion.dependencies(ref);
        return this.resolve(ref);
    }
    resolve(ref, ...rest) {
        return this.assertion.session.resolve(toResolvable(ref, rest));
    }
    dependencies(name) {
        this.assertion.dependencies(name);
        return "";
    }
    tags(name) {
        this.assertion.tags(name);
        return "";
    }
    when(cond, trueCase, falseCase = "") {
        return cond ? trueCase : falseCase;
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
}

const IRecordDescriptorProperties = () => strictKeysOf()([
    "description",
    "columns",
    "displayName",
    "dimension",
    "aggregator",
    "expression",
    "tags",
    "bigqueryPolicyTags"
]);

class ColumnDescriptors {
    static mapToColumnProtoArray(columns, reportError) {
        return Object.keys(columns)
            .map(column => ColumnDescriptors.mapColumnDescriptionToProto([column], columns[column], reportError))
            .flat();
    }
    static mapColumnDescriptionToProto(currentPath, description, reportError) {
        if (typeof description === "string") {
            return [
                dataform.ColumnDescriptor.create({
                    description,
                    path: currentPath
                })
            ];
        }
        checkExcessProperties(reportError, description, IRecordDescriptorProperties(), `${currentPath.join(".")} column descriptor`);
        const columnDescriptor = !!description
            ? [
                dataform.ColumnDescriptor.create({
                    path: currentPath,
                    description: description.description,
                    displayName: description.displayName,
                    dimensionType: ColumnDescriptors.mapDimensionType(description.dimension),
                    aggregation: ColumnDescriptors.mapAggregation(description.aggregator),
                    expression: description.expression,
                    tags: typeof description.tags === "string" ? [description.tags] : description.tags,
                    bigqueryPolicyTags: typeof description.bigqueryPolicyTags === "string"
                        ? [description.bigqueryPolicyTags]
                        : description.bigqueryPolicyTags
                })
            ]
            : [];
        const nestedColumns = description.columns ? Object.keys(description.columns) : [];
        return columnDescriptor.concat(nestedColumns
            .map(nestedColumn => ColumnDescriptors.mapColumnDescriptionToProto(currentPath.concat([nestedColumn]), description.columns[nestedColumn], reportError))
            .flat());
    }
    static mapAggregation(aggregation) {
        switch (aggregation) {
            case "sum":
                return dataform.ColumnDescriptor.Aggregation.SUM;
            case "distinct":
                return dataform.ColumnDescriptor.Aggregation.DISTINCT;
            case "derived":
                return dataform.ColumnDescriptor.Aggregation.DERIVED;
            case undefined:
                return undefined;
            default:
                throw new Error(`'${aggregation}' is not a valid aggregation option.`);
        }
    }
    static mapFromAggregation(aggregation) {
        switch (aggregation) {
            case dataform.ColumnDescriptor.Aggregation.SUM:
                return "sum";
            case dataform.ColumnDescriptor.Aggregation.DISTINCT:
                return "distinct";
            case dataform.ColumnDescriptor.Aggregation.DERIVED:
                return "derived";
            case dataform.ColumnDescriptor.Aggregation.UNKNOWN_AGGREGATION:
                return undefined;
            case undefined:
                return undefined;
            default:
                throw new Error(`Aggregation type not recognized: ${aggregation}`);
        }
    }
    static mapDimensionType(dimensionType) {
        switch (dimensionType) {
            case "category":
                return dataform.ColumnDescriptor.DimensionType.CATEGORY;
            case "timestamp":
                return dataform.ColumnDescriptor.DimensionType.TIMESTAMP;
            case "number":
                return dataform.ColumnDescriptor.DimensionType.NUMBER;
            case undefined:
                return undefined;
            default:
                throw new Error(`'${dimensionType}' is not a valid dimension type.`);
        }
    }
    static mapFromDimensionType(dimensionType) {
        switch (dimensionType) {
            case dataform.ColumnDescriptor.DimensionType.CATEGORY:
                return "category";
            case dataform.ColumnDescriptor.DimensionType.TIMESTAMP:
                return "timestamp";
            case dataform.ColumnDescriptor.DimensionType.NUMBER:
                return "number";
            case dataform.ColumnDescriptor.DimensionType.UNKNOWN_DIMENSION:
                return undefined;
            case undefined:
                return undefined;
            default:
                throw new Error(`Dimension type not recognized: ${dimensionType}`);
        }
    }
}

const IIOperationConfigProperties = strictKeysOf()([
    "columns",
    "database",
    "dependencies",
    "description",
    "disabled",
    "hasOutput",
    "hermetic",
    "name",
    "schema",
    "tags",
    "type"
]);
class Operation {
    constructor() {
        this.proto = dataform.Operation.create();
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, IIOperationConfigProperties, "operation config");
        if (config.dependencies) {
            this.dependencies(config.dependencies);
        }
        if (config.hermetic !== undefined) {
            this.hermetic(config.hermetic);
        }
        if (config.disabled) {
            this.disabled();
        }
        if (config.tags) {
            this.tags(config.tags);
        }
        if (config.hasOutput) {
            this.hasOutput(config.hasOutput);
        }
        if (config.description) {
            this.description(config.description);
        }
        if (config.columns) {
            this.columns(config.columns);
        }
        if (config.database) {
            this.database(config.database);
        }
        if (config.schema) {
            this.schema(config.schema);
        }
        return this;
    }
    queries(queries) {
        this.contextableQueries = queries;
        return this;
    }
    dependencies(value) {
        const newDependencies = Array.isArray(value) ? value : [value];
        newDependencies.forEach(resolvable => {
            this.proto.dependencyTargets.push(resolvableAsTarget(resolvable));
        });
        return this;
    }
    hermetic(hermetic) {
        this.proto.hermeticity = hermetic
            ? dataform.ActionHermeticity.HERMETIC
            : dataform.ActionHermeticity.NON_HERMETIC;
    }
    disabled() {
        this.proto.disabled = true;
        return this;
    }
    tags(value) {
        const newTags = typeof value === "string" ? [value] : value;
        newTags.forEach(t => {
            if (this.proto.tags.indexOf(t) < 0) {
                this.proto.tags.push(t);
            }
        });
        return this;
    }
    hasOutput(hasOutput) {
        this.proto.hasOutput = hasOutput;
        return this;
    }
    description(description) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.description = description;
        return this;
    }
    columns(columns) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.columns = ColumnDescriptors.mapToColumnProtoArray(columns, (e) => this.session.compileError(e));
        return this;
    }
    database(database) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, this.proto.target.schema, database);
        return this;
    }
    schema(schema) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, schema, this.proto.target.database);
        return this;
    }
    compile() {
        var _a, _b;
        if (((_b = (_a = this.proto.actionDescriptor) === null || _a === void 0 ? void 0 : _a.columns) === null || _b === void 0 ? void 0 : _b.length) > 0 && !this.proto.hasOutput) {
            this.session.compileError(new Error("Actions of type 'operations' may only describe columns if they specify 'hasOutput: true'."), this.proto.fileName);
        }
        const context = new OperationContext(this);
        const appliedQueries = context.apply(this.contextableQueries);
        this.proto.queries = typeof appliedQueries === "string" ? [appliedQueries] : appliedQueries;
        return this.proto;
    }
}
class OperationContext {
    constructor(operation) {
        this.operation = operation;
    }
    self() {
        return this.resolve(this.operation.proto.target);
    }
    name() {
        return this.operation.proto.target.name;
    }
    ref(ref, ...rest) {
        ref = toResolvable(ref, rest);
        if (!resolvableAsTarget(ref)) {
            const message = `Action name is not specified`;
            this.operation.session.compileError(new Error(message));
            return "";
        }
        this.operation.dependencies(ref);
        return this.resolve(ref);
    }
    resolve(ref, ...rest) {
        return this.operation.session.resolve(toResolvable(ref, rest));
    }
    dependencies(name) {
        this.operation.dependencies(name);
        return "";
    }
    tags(name) {
        this.operation.tags(name);
        return "";
    }
    hasOutput(hasOutput) {
        this.operation.hasOutput(hasOutput);
        return "";
    }
    when(cond, trueCase, falseCase = "") {
        return cond ? trueCase : falseCase;
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
}

const TableType = ["table", "view", "incremental", "inline"];
const DistStyleType = ["even", "key", "all"];
const SortStyleType = ["compound", "interleaved"];
const IRedshiftOptionsProperties = () => strictKeysOf()(["distKey", "distStyle", "sortKeys", "sortStyle"]);
const ISnowflakeOptionsProperties = () => strictKeysOf()(["secure", "transient", "clusterBy"]);
const ISQLDataWarehouseOptionsProperties = () => strictKeysOf()(["distribution"]);
const IBigQueryOptionsProperties = () => strictKeysOf()(["partitionBy", "clusterBy", "updatePartitionFilter", "labels"]);
const IPrestoOptionsProperties = () => strictKeysOf()(["partitionBy"]);
const ITableAssertionsProperties = () => strictKeysOf()(["uniqueKey", "uniqueKeys", "nonNull", "rowConditions"]);
const ITableConfigProperties = () => strictKeysOf()([
    "type",
    "disabled",
    "protected",
    "name",
    "redshift",
    "bigquery",
    "snowflake",
    "sqldatawarehouse",
    "presto",
    "tags",
    "uniqueKey",
    "dependencies",
    "hermetic",
    "schema",
    "assertions",
    "database",
    "columns",
    "description"
]);
class Table {
    constructor() {
        this.proto = dataform.Table.create({
            type: "view",
            disabled: false,
            tags: []
        });
        this.contextablePreOps = [];
        this.contextablePostOps = [];
        this.uniqueKeyAssertions = [];
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, ITableConfigProperties(), "table config");
        if (config.type) {
            this.type(config.type);
        }
        if (config.dependencies) {
            this.dependencies(config.dependencies);
        }
        if (config.hermetic !== undefined) {
            this.hermetic(config.hermetic);
        }
        if (config.disabled) {
            this.disabled();
        }
        if (config.protected) {
            this.protected();
        }
        if (config.redshift) {
            this.redshift(config.redshift);
        }
        if (config.bigquery) {
            this.bigquery(config.bigquery);
        }
        if (config.snowflake) {
            this.snowflake(config.snowflake);
        }
        if (config.sqldatawarehouse) {
            this.sqldatawarehouse(config.sqldatawarehouse);
        }
        if (config.presto) {
            this.presto(config.presto);
        }
        if (config.tags) {
            this.tags(config.tags);
        }
        if (config.description) {
            this.description(config.description);
        }
        if (config.columns) {
            this.columns(config.columns);
        }
        if (config.database) {
            this.database(config.database);
        }
        if (config.schema) {
            this.schema(config.schema);
        }
        if (config.assertions) {
            this.assertions(config.assertions);
        }
        if (config.uniqueKey) {
            this.uniqueKey(config.uniqueKey);
        }
        return this;
    }
    type(type) {
        this.proto.type = type;
        return this;
    }
    query(query) {
        this.contextableQuery = query;
        return this;
    }
    where(where) {
        this.contextableWhere = where;
        return this;
    }
    preOps(pres) {
        this.contextablePreOps.push(pres);
        return this;
    }
    postOps(posts) {
        this.contextablePostOps.push(posts);
        return this;
    }
    disabled() {
        var _a;
        this.proto.disabled = true;
        this.uniqueKeyAssertions.forEach(assertion => assertion.disabled());
        (_a = this.rowConditionsAssertion) === null || _a === void 0 ? void 0 : _a.disabled();
        return this;
    }
    protected() {
        this.proto.protected = true;
        return this;
    }
    uniqueKey(uniqueKey) {
        this.proto.uniqueKey = uniqueKey;
    }
    snowflake(snowflake) {
        checkExcessProperties((e) => this.session.compileError(e), snowflake, ISnowflakeOptionsProperties(), "snowflake config");
        this.proto.snowflake = dataform.SnowflakeOptions.create(snowflake);
        return this;
    }
    sqldatawarehouse(sqlDataWarehouse) {
        checkExcessProperties((e) => this.session.compileError(e), sqlDataWarehouse, ISQLDataWarehouseOptionsProperties(), "sqldatawarehouse config");
        this.proto.sqlDataWarehouse = dataform.SQLDataWarehouseOptions.create(sqlDataWarehouse);
        return this;
    }
    redshift(redshift) {
        checkExcessProperties((e) => this.session.compileError(e), redshift, IRedshiftOptionsProperties(), "redshift config");
        this.proto.redshift = dataform.RedshiftOptions.create(redshift);
        return this;
    }
    bigquery(bigquery) {
        checkExcessProperties((e) => this.session.compileError(e), bigquery, IBigQueryOptionsProperties(), "bigquery config");
        this.proto.bigquery = dataform.BigQueryOptions.create(bigquery);
        if (!!bigquery.labels) {
            if (!this.proto.actionDescriptor) {
                this.proto.actionDescriptor = {};
            }
            this.proto.actionDescriptor.bigqueryLabels = bigquery.labels;
        }
        return this;
    }
    presto(presto) {
        checkExcessProperties((e) => this.session.compileError(e), presto, IPrestoOptionsProperties(), "presto config");
        this.proto.presto = dataform.PrestoOptions.create(presto);
        return this;
    }
    dependencies(value) {
        const newDependencies = Array.isArray(value) ? value : [value];
        newDependencies.forEach(resolvable => {
            this.proto.dependencyTargets.push(resolvableAsTarget(resolvable));
        });
        return this;
    }
    hermetic(hermetic) {
        this.proto.hermeticity = hermetic
            ? dataform.ActionHermeticity.HERMETIC
            : dataform.ActionHermeticity.NON_HERMETIC;
    }
    tags(value) {
        const newTags = typeof value === "string" ? [value] : value;
        newTags.forEach(t => {
            this.proto.tags.push(t);
        });
        return this;
    }
    description(description) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.description = description;
        return this;
    }
    columns(columns) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.columns = ColumnDescriptors.mapToColumnProtoArray(columns, (e) => this.session.compileError(e));
        return this;
    }
    database(database) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, this.proto.target.schema, database);
        return this;
    }
    schema(schema) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, schema, this.proto.target.database);
        return this;
    }
    assertions(assertions) {
        checkExcessProperties((e) => this.session.compileError(e), assertions, ITableAssertionsProperties(), "assertions config");
        if (!!assertions.uniqueKey && !!assertions.uniqueKeys) {
            this.session.compileError(new Error("Specify at most one of 'assertions.uniqueKey' and 'assertions.uniqueKeys'."));
        }
        let uniqueKeys = assertions.uniqueKeys;
        if (!!assertions.uniqueKey) {
            uniqueKeys =
                typeof assertions.uniqueKey === "string"
                    ? [[assertions.uniqueKey]]
                    : [assertions.uniqueKey];
        }
        if (uniqueKeys) {
            uniqueKeys.forEach((uniqueKey, index) => {
                const uniqueKeyAssertion = this.session.assert(`${this.proto.target.schema}_${this.proto.target.name}_assertions_uniqueKey_${index}`, ctx => this.session.adapter().indexAssertion(ctx.ref(this.proto.target), uniqueKey));
                uniqueKeyAssertion.proto.parentAction = this.proto.target;
                if (this.proto.disabled) {
                    uniqueKeyAssertion.disabled();
                }
                this.uniqueKeyAssertions.push(uniqueKeyAssertion);
            });
        }
        const mergedRowConditions = assertions.rowConditions || [];
        if (!!assertions.nonNull) {
            const nonNullCols = typeof assertions.nonNull === "string" ? [assertions.nonNull] : assertions.nonNull;
            nonNullCols.forEach(nonNullCol => mergedRowConditions.push(`${nonNullCol} IS NOT NULL`));
        }
        if (!!mergedRowConditions && mergedRowConditions.length > 0) {
            this.rowConditionsAssertion = this.session.assert(`${this.proto.target.schema}_${this.proto.target.name}_assertions_rowConditions`, ctx => this.session
                .adapter()
                .rowConditionsAssertion(ctx.ref(this.proto.target), mergedRowConditions));
            this.rowConditionsAssertion.proto.parentAction = this.proto.target;
            if (this.proto.disabled) {
                this.rowConditionsAssertion.disabled();
            }
        }
        return this;
    }
    compile() {
        const context = new TableContext(this);
        const incrementalContext = new TableContext(this, true);
        this.proto.query = context.apply(this.contextableQuery);
        if (this.proto.type === "incremental") {
            this.proto.incrementalQuery = incrementalContext.apply(this.contextableQuery);
            this.proto.incrementalPreOps = this.contextifyOps(this.contextablePreOps, incrementalContext);
            this.proto.incrementalPostOps = this.contextifyOps(this.contextablePostOps, incrementalContext);
        }
        if (this.contextableWhere) {
            this.proto.where = context.apply(this.contextableWhere);
        }
        this.proto.preOps = this.contextifyOps(this.contextablePreOps, context).filter(op => !!op.trim());
        this.proto.postOps = this.contextifyOps(this.contextablePostOps, context).filter(op => !!op.trim());
        validateQueryString(this.session, this.proto.query, this.proto.fileName);
        validateQueryString(this.session, this.proto.incrementalQuery, this.proto.fileName);
        return this.proto;
    }
    contextifyOps(contextableOps, currentContext) {
        let protoOps = [];
        contextableOps.forEach(contextableOp => {
            const appliedOps = currentContext.apply(contextableOp);
            protoOps = protoOps.concat(typeof appliedOps === "string" ? [appliedOps] : appliedOps);
        });
        return protoOps;
    }
}
Table.IGNORED_PROPS = {
    inline: [
        "bigquery",
        "redshift",
        "snowflake",
        "sqlDataWarehouse",
        "presto",
        "preOps",
        "postOps",
        "actionDescriptor",
        "disabled",
        "where"
    ]
};
class TableContext {
    constructor(table, isIncremental = false) {
        this.table = table;
        this.isIncremental = isIncremental;
    }
    config(config) {
        this.table.config(config);
        return "";
    }
    self() {
        return this.resolve(this.table.proto.target);
    }
    name() {
        return this.table.proto.target.name;
    }
    ref(ref, ...rest) {
        ref = toResolvable(ref, rest);
        if (!resolvableAsTarget(ref)) {
            const message = `Action name is not specified`;
            this.table.session.compileError(new Error(message));
            return "";
        }
        this.table.dependencies(ref);
        return this.resolve(ref);
    }
    resolve(ref, ...rest) {
        return this.table.session.resolve(toResolvable(ref, rest));
    }
    type(type) {
        this.table.type(type);
        return "";
    }
    where(where) {
        this.table.where(where);
        return "";
    }
    when(cond, trueCase, falseCase = "") {
        return cond ? trueCase : falseCase;
    }
    incremental() {
        return !!this.isIncremental;
    }
    preOps(statement) {
        this.table.preOps(statement);
        return "";
    }
    postOps(statement) {
        this.table.postOps(statement);
        return "";
    }
    disabled() {
        this.table.disabled();
        return "";
    }
    redshift(redshift) {
        this.table.redshift(redshift);
        return "";
    }
    bigquery(bigquery) {
        this.table.bigquery(bigquery);
        return "";
    }
    presto(presto) {
        this.table.presto(presto);
        return "";
    }
    dependencies(res) {
        this.table.dependencies(res);
        return "";
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
    tags(tags) {
        this.table.tags(tags);
        return "";
    }
}

const LEXER_STATE_NAMES = {
    SQL: "sql",
    JS_BLOCK: "jsBlock",
    JS_TEMPLATE_STRING: "jsTemplateString",
    INNER_SQL_BLOCK: "innerSqlBlock",
    SQL_SINGLE_QUOTE_STRING: "innerSingleQuote",
    SQL_DOUBLE_QUOTE_STRING: "innerDoubleQuote"
};
const SQL_LEXER_TOKEN_NAMES = {
    START_CONFIG: LEXER_STATE_NAMES.SQL + "_startConfig",
    START_JS: LEXER_STATE_NAMES.SQL + "_startJs",
    START_INCREMENTAL: LEXER_STATE_NAMES.SQL + "_startIncremental",
    START_PRE_OPERATIONS: LEXER_STATE_NAMES.SQL + "_startPreOperations",
    START_POST_OPERATIONS: LEXER_STATE_NAMES.SQL + "_startPostOperations",
    START_INPUT: LEXER_STATE_NAMES.SQL + "_startInput",
    STATEMENT_SEPERATOR: LEXER_STATE_NAMES.SQL + "_statementSeparator",
    SINGLE_LINE_COMMENT: LEXER_STATE_NAMES.SQL + "_singleLineComment",
    MULTI_LINE_COMMENT: LEXER_STATE_NAMES.SQL + "_multiLineComment",
    START_JS_PLACEHOLDER: LEXER_STATE_NAMES.SQL + "_startJsPlaceholder",
    BACKTICK: LEXER_STATE_NAMES.SQL + "_backtick",
    START_QUOTE_SINGLE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startQuoteSingle",
    START_QUOTE_DOUBLE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startQuoteDouble",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.SQL + "_captureEverythingElse"
};
const JS_BLOCK_LEXER_TOKEN_NAMES = {
    SINGLE_LINE_COMMENT: LEXER_STATE_NAMES.JS_BLOCK + "_singleLineComment",
    MULTI_LINE_COMMENT: LEXER_STATE_NAMES.JS_BLOCK + "_multiLineComment",
    SINGLE_QUOTE_STRING: LEXER_STATE_NAMES.JS_BLOCK + "_singleQuoteString",
    DOUBLE_QUOTE_STRING: LEXER_STATE_NAMES.JS_BLOCK + "_doubleQuoteString",
    START_JS_TEMPLATE_STRING: LEXER_STATE_NAMES.JS_BLOCK + "_startJsTemplateString",
    START_JS_BLOCK: LEXER_STATE_NAMES.JS_BLOCK + "_startJsBlock",
    CLOSE_BLOCK: LEXER_STATE_NAMES.JS_BLOCK + "_closeBlock",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.JS_BLOCK + "_captureEverythingElse"
};
const JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES = {
    ESCAPED_BACKSLASH: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_escapedBackslash",
    ESCAPED_DOLLAR_BRACE: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_escapedDollarBrace",
    START_JS_BLOCK: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_startJsBlock",
    CLOSE_STRING: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_closeString",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_captureEverythingElse"
};
const INNER_SQL_BLOCK_LEXER_TOKEN_NAMES = {
    STATEMENT_SEPERATOR: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_statementSeparator",
    SINGLE_LINE_COMMENT: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_singleLineComment",
    MULTI_LINE_COMMENT: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_multiLineComment",
    START_JS_PLACEHOLDER: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startJsPlaceholder",
    CLOSE_BLOCK: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_closeBlock",
    BACKTICK: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_backtick",
    START_QUOTE_SINGLE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startQuoteSingle",
    START_QUOTE_DOUBLE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startQuoteDouble",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_captureEverythingElse"
};
const SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES = {
    ESCAPED_BACKSLASH: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_escapedBackslash",
    ESCAPED_QUOTE: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_escapedQuoteSingle",
    START_JS_PLACEHOLDER: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_startJsPlaceholder",
    CLOSE_QUOTE: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_closeQuoteSingle",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_captureEverythingElse"
};
const SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES = {
    ESCAPED_BACKSLASH: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_escapedBackslash",
    ESCAPED_QUOTE: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_escapedQuoteDouble",
    START_JS_PLACEHOLDER: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_startJsPlaceholder",
    CLOSE_QUOTE: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_closeQuoteDouble",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_captureEverythingElse"
};
const lexer = moo.states(buildSqlxLexer());
var SyntaxTreeNodeType;
(function (SyntaxTreeNodeType) {
    SyntaxTreeNodeType[SyntaxTreeNodeType["JAVASCRIPT"] = 0] = "JAVASCRIPT";
    SyntaxTreeNodeType[SyntaxTreeNodeType["JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER"] = 1] = "JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER";
    SyntaxTreeNodeType[SyntaxTreeNodeType["SQL"] = 2] = "SQL";
    SyntaxTreeNodeType[SyntaxTreeNodeType["SQL_COMMENT"] = 3] = "SQL_COMMENT";
    SyntaxTreeNodeType[SyntaxTreeNodeType["SQL_LITERAL_STRING"] = 4] = "SQL_LITERAL_STRING";
    SyntaxTreeNodeType[SyntaxTreeNodeType["SQL_STATEMENT_SEPARATOR"] = 5] = "SQL_STATEMENT_SEPARATOR";
})(SyntaxTreeNodeType || (SyntaxTreeNodeType = {}));
const START_TOKEN_NODE_MAPPINGS = new Map([
    [SQL_LEXER_TOKEN_NAMES.START_CONFIG, SyntaxTreeNodeType.JAVASCRIPT],
    [SQL_LEXER_TOKEN_NAMES.START_INCREMENTAL, SyntaxTreeNodeType.SQL],
    [SQL_LEXER_TOKEN_NAMES.START_INPUT, SyntaxTreeNodeType.SQL],
    [SQL_LEXER_TOKEN_NAMES.START_JS, SyntaxTreeNodeType.JAVASCRIPT],
    [
        SQL_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER,
        SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER
    ],
    [SQL_LEXER_TOKEN_NAMES.START_POST_OPERATIONS, SyntaxTreeNodeType.SQL],
    [SQL_LEXER_TOKEN_NAMES.START_PRE_OPERATIONS, SyntaxTreeNodeType.SQL],
    [SQL_LEXER_TOKEN_NAMES.START_QUOTE_SINGLE, SyntaxTreeNodeType.SQL_LITERAL_STRING],
    [SQL_LEXER_TOKEN_NAMES.START_QUOTE_DOUBLE, SyntaxTreeNodeType.SQL_LITERAL_STRING],
    [JS_BLOCK_LEXER_TOKEN_NAMES.START_JS_BLOCK, SyntaxTreeNodeType.JAVASCRIPT],
    [JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.START_JS_BLOCK, SyntaxTreeNodeType.JAVASCRIPT],
    [
        INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER,
        SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER
    ],
    [INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_QUOTE_SINGLE, SyntaxTreeNodeType.SQL_LITERAL_STRING],
    [INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_QUOTE_DOUBLE, SyntaxTreeNodeType.SQL_LITERAL_STRING],
    [
        SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER,
        SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER
    ],
    [
        SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER,
        SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER
    ]
]);
const CLOSE_TOKEN_TYPES = new Set([
    JS_BLOCK_LEXER_TOKEN_NAMES.CLOSE_BLOCK,
    INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.CLOSE_BLOCK,
    SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CLOSE_QUOTE,
    SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CLOSE_QUOTE
]);
const WHOLE_TOKEN_NODE_MAPPINGS = new Map([
    [SQL_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT, SyntaxTreeNodeType.SQL_COMMENT],
    [SQL_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT, SyntaxTreeNodeType.SQL_COMMENT],
    [SQL_LEXER_TOKEN_NAMES.STATEMENT_SEPERATOR, SyntaxTreeNodeType.SQL_STATEMENT_SEPARATOR],
    [INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT, SyntaxTreeNodeType.SQL_COMMENT],
    [INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT, SyntaxTreeNodeType.SQL_COMMENT],
    [
        INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.STATEMENT_SEPERATOR,
        SyntaxTreeNodeType.SQL_STATEMENT_SEPARATOR
    ]
]);
class SyntaxTreeNode {
    constructor(type, allChildren = []) {
        this.type = type;
        this.allChildren = allChildren;
    }
    static create(code) {
        const parentNode = new SyntaxTreeNode(SyntaxTreeNodeType.SQL);
        let currentNode = parentNode;
        const nodeStack = [currentNode];
        lexer.reset(code);
        for (const token of lexer) {
            if (START_TOKEN_NODE_MAPPINGS.has(token.type)) {
                const childType = START_TOKEN_NODE_MAPPINGS.get(token.type);
                if (childType === SyntaxTreeNodeType.SQL && currentNode.type !== SyntaxTreeNodeType.SQL) {
                    throw new Error("SQL syntax tree nodes may only be children of other SQL nodes.");
                }
                const newCurrentNode = new SyntaxTreeNode(childType, [token.value]);
                nodeStack.push(newCurrentNode);
                currentNode.push(newCurrentNode);
                currentNode = newCurrentNode;
            }
            else if (CLOSE_TOKEN_TYPES.has(token.type)) {
                currentNode.push(token.value);
                nodeStack.pop();
                currentNode = nodeStack[nodeStack.length - 1];
            }
            else if (WHOLE_TOKEN_NODE_MAPPINGS.has(token.type)) {
                currentNode.push(new SyntaxTreeNode(WHOLE_TOKEN_NODE_MAPPINGS.get(token.type)).push(token.value));
            }
            else {
                currentNode.push(token.value);
            }
        }
        return parentNode;
    }
    static isSyntaxTreeNode(node) {
        return typeof node !== "string";
    }
    children() {
        return this.allChildren.slice();
    }
    concatenate(mutators) {
        const mutator = (mutators === null || mutators === void 0 ? void 0 : mutators.has(this.type)) ? mutators.get(this.type) : (str) => str;
        return this.allChildren
            .map(child => {
            if (typeof child === "string") {
                return mutator(child);
            }
            return child.concatenate();
        })
            .join("");
    }
    push(child) {
        if (this.allChildren.length > 0 &&
            typeof child === "string" &&
            typeof this.allChildren[this.allChildren.length - 1] === "string") {
            this.allChildren[this.allChildren.length - 1] =
                this.allChildren[this.allChildren.length - 1] + child;
            return;
        }
        this.allChildren.push(child);
        return this;
    }
    equals(other) {
        if (this.type !== other.type) {
            return false;
        }
        if (this.allChildren.length !== other.children().length) {
            return false;
        }
        const areEqual = (first, second) => {
            if (typeof first !== typeof second) {
                return false;
            }
            if (typeof first === "string" || typeof second === "string") {
                return first === second;
            }
            return first.equals(second);
        };
        if (this.allChildren.some((child, index) => !areEqual(child, other.children()[index]))) {
            return false;
        }
        return true;
    }
}
function buildSqlxLexer() {
    const sqlLexer = {};
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_CONFIG] = {
        match: "config {",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_JS] = {
        match: "js {",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_INCREMENTAL] = {
        match: "incremental_where {",
        push: LEXER_STATE_NAMES.INNER_SQL_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_PRE_OPERATIONS] = {
        match: "pre_operations {",
        push: LEXER_STATE_NAMES.INNER_SQL_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_POST_OPERATIONS] = {
        match: "post_operations {",
        push: LEXER_STATE_NAMES.INNER_SQL_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_INPUT] = {
        match: /input "[a-zA-Z0-9_-]+"(?:,\s*"[a-zA-Z0-9_-]+")* {/,
        push: LEXER_STATE_NAMES.INNER_SQL_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.STATEMENT_SEPERATOR] = /[^\S\r\n]*---[^\S\r\n]*$/;
    sqlLexer[SQL_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT] = /--.*?$/;
    sqlLexer[SQL_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT] = /\/\*[\s\S]*?\*\//;
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.BACKTICK] = "`";
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_QUOTE_SINGLE] = {
        match: "'",
        push: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_QUOTE_DOUBLE] = {
        match: '"',
        push: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const jsBlockLexer = {};
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT] = /\/\/.*?$/;
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT] = /\/\*[\s\S]*?\*\//;
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.SINGLE_QUOTE_STRING] = /'(?:\\['\\]|[^\n'\\])*'/;
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.DOUBLE_QUOTE_STRING] = /"(?:\\["\\]|[^\n"\\])*"/;
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.START_JS_TEMPLATE_STRING] = {
        match: "`",
        push: LEXER_STATE_NAMES.JS_TEMPLATE_STRING
    };
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.START_JS_BLOCK] = {
        match: "{",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.CLOSE_BLOCK] = { match: "}", pop: 1 };
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const jsTemplateStringLexer = {};
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.ESCAPED_BACKSLASH] = /\\\\/;
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.ESCAPED_DOLLAR_BRACE] = /\\\${`/;
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.START_JS_BLOCK] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.CLOSE_STRING] = { match: "`", pop: 1 };
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const innerSqlBlockLexer = {};
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.STATEMENT_SEPERATOR] = /[^\S\r\n]*---[^\S\r\n]*$/;
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT] = /--.*?$/;
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT] = /\/\*[\s\S]*?\*\//;
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.CLOSE_BLOCK] = {
        match: "}",
        pop: 1
    };
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.BACKTICK] = "`";
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_QUOTE_SINGLE] = {
        match: "'",
        push: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING
    };
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_QUOTE_DOUBLE] = {
        match: '"',
        push: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING
    };
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const innerSingleQuoteLexer = {};
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.ESCAPED_BACKSLASH] = "\\\\";
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.ESCAPED_QUOTE] = "\\'";
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CLOSE_QUOTE] = {
        match: "'",
        pop: 1
    };
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const innerDoubleQuoteLexer = {};
    innerDoubleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.ESCAPED_BACKSLASH] = "\\\\";
    innerDoubleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.ESCAPED_QUOTE] = {
        match: '\\"'
    };
    innerSingleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    innerDoubleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CLOSE_QUOTE] = {
        match: '"',
        pop: 1
    };
    innerDoubleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const lexerStates = {};
    lexerStates[LEXER_STATE_NAMES.SQL] = sqlLexer;
    lexerStates[LEXER_STATE_NAMES.JS_BLOCK] = jsBlockLexer;
    lexerStates[LEXER_STATE_NAMES.JS_TEMPLATE_STRING] = jsTemplateStringLexer;
    lexerStates[LEXER_STATE_NAMES.INNER_SQL_BLOCK] = innerSqlBlockLexer;
    lexerStates[LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING] = innerSingleQuoteLexer;
    lexerStates[LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING] = innerDoubleQuoteLexer;
    return lexerStates;
}

const SQL_STATEMENT_ESCAPERS = new Map([
    [
        SyntaxTreeNodeType.SQL_COMMENT,
        (str) => str.replace(/`/g, "\\`").replace(/\${/g, "\\${")
    ],
    [
        SyntaxTreeNodeType.SQL_LITERAL_STRING,
        (str) => str.replace(/\\/g, "\\\\").replace(/\`/g, "\\`")
    ]
]);

function encode(protoType, value = {}) {
    return toBase64(protoType.encode(protoType.create(value)).finish());
}
function decode(protoType, encodedValue) {
    if (!encodedValue) {
        return protoType.create();
    }
    return protoType.decode(fromBase64(encodedValue));
}
function equals(protoType, valueA, valueB) {
    return encode(protoType, valueA) === encode(protoType, valueB);
}
function deepClone(protoType, value) {
    return protoType.fromObject(protoType.toObject(protoType.create(value)));
}
function toBase64(value) {
    return protobufjs.util.base64.encode(value, 0, value.length);
}
function fromBase64(value) {
    const buf = new Uint8Array(protobufjs.util.base64.length(value));
    protobufjs.util.base64.decode(value, buf, 0);
    return buf;
}

const IDeclarationConfigProperties = strictKeysOf()([
    "columns",
    "database",
    "description",
    "name",
    "schema",
    "type"
]);
class Declaration {
    constructor() {
        this.proto = dataform.Declaration.create();
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, IDeclarationConfigProperties, "declaration config");
        if (config.description) {
            this.description(config.description);
        }
        if (config.columns) {
            this.columns(config.columns);
        }
        return this;
    }
    description(description) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.description = description;
        return this;
    }
    columns(columns) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.columns = ColumnDescriptors.mapToColumnProtoArray(columns, (e) => this.session.compileError(e));
        return this;
    }
    compile() {
        return this.proto;
    }
}

const ITestConfigProperties = strictKeysOf()(["type", "dataset", "name"]);
class Test {
    constructor() {
        this.proto = dataform.Test.create();
        this.contextableInputs = new StringifiedMap(JSONObjectStringifier.create());
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, ITestConfigProperties, "test config");
        if (config.dataset) {
            this.dataset(config.dataset);
        }
        return this;
    }
    dataset(ref) {
        this.datasetToTest = ref;
        return this;
    }
    input(refName, contextableQuery) {
        this.contextableInputs.set(resolvableAsTarget(toResolvable(refName)), contextableQuery);
        return this;
    }
    expect(contextableQuery) {
        this.contextableQuery = contextableQuery;
        return this;
    }
    compile() {
        const testContext = new TestContext(this);
        if (!this.datasetToTest) {
            this.session.compileError(new Error("Tests must operate upon a specified dataset."), this.proto.fileName);
        }
        else {
            const allResolved = this.session.findActions(resolvableAsTarget(this.datasetToTest));
            if (allResolved.length > 1) {
                this.session.compileError(new Error(ambiguousActionNameMsg(this.datasetToTest, allResolved)), this.proto.fileName);
            }
            const dataset = allResolved.length > 0 ? allResolved[0] : undefined;
            if (!(dataset && dataset instanceof Table)) {
                this.session.compileError(new Error(`Dataset ${stringifyResolvable(this.datasetToTest)} could not be found.`), this.proto.fileName);
            }
            else if (dataset.proto.type === "incremental") {
                this.session.compileError(new Error("Running tests on incremental datasets is not yet supported."), this.proto.fileName);
            }
            else {
                const refReplacingContext = new RefReplacingContext(testContext);
                this.proto.testQuery = refReplacingContext.apply(dataset.contextableQuery);
            }
        }
        this.proto.expectedOutputQuery = testContext.apply(this.contextableQuery);
        return this.proto;
    }
}
class TestContext {
    constructor(test) {
        this.test = test;
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
}
class RefReplacingContext {
    constructor(testContext) {
        this.testContext = testContext;
    }
    ref(ref, ...rest) {
        return this.resolve(ref, ...rest);
    }
    resolve(ref, ...rest) {
        const target = resolvableAsTarget(toResolvable(ref, rest));
        if (!this.testContext.test.contextableInputs.has(target)) {
            this.testContext.test.session.compileError(new Error(`Input for dataset "${JSON.stringify(target)}" has not been provided. Provided inputs: ${Array.from(this.testContext.test.contextableInputs.keys()).map(providedTarget => JSON.stringify(providedTarget))}`));
            return "";
        }
        return `(${this.testContext.apply(this.testContext.test.contextableInputs.get(target))})`;
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
    config(config) {
        return "";
    }
    self() {
        return "";
    }
    name() {
        return "";
    }
    type(type) {
        return "";
    }
    where(where) {
        return "";
    }
    when(cond, trueCase, falseCase = "") {
        return cond ? trueCase : falseCase;
    }
    incremental() {
        return false;
    }
    preOps(statement) {
        return "";
    }
    postOps(statement) {
        return "";
    }
    disabled() {
        return "";
    }
    redshift(redshift) {
        return "";
    }
    bigquery(bigquery) {
        return "";
    }
    dependencies(name) {
        return "";
    }
    tags(tags) {
        return "";
    }
}

const version = "1.17.2";

const SQL_DATA_WAREHOUSE_DIST_HASH_REGEXP = new RegExp("HASH\\s*\\(\\s*\\w*\\s*\\)\\s*");
const DEFAULT_CONFIG = {
    defaultSchema: "dataform",
    assertionSchema: "dataform_assertions"
};
class Session {
    constructor(rootDir, projectConfig, originalProjectConfig) {
        this.init(rootDir, projectConfig, originalProjectConfig);
    }
    init(rootDir, projectConfig, originalProjectConfig) {
        this.rootDir = rootDir;
        this.config = projectConfig || DEFAULT_CONFIG;
        this.canonicalConfig = getCanonicalProjectConfig(originalProjectConfig || projectConfig || DEFAULT_CONFIG);
        this.actions = [];
        this.tests = {};
        this.graphErrors = { compilationErrors: [] };
    }
    get projectConfig() {
        return Object.freeze({
            warehouse: this.config.warehouse,
            defaultDatabase: this.config.defaultDatabase,
            defaultSchema: this.config.defaultSchema,
            assertionSchema: this.config.assertionSchema,
            databaseSuffix: this.config.databaseSuffix,
            schemaSuffix: this.config.schemaSuffix,
            tablePrefix: this.config.tablePrefix,
            vars: Object.freeze(Object.assign({}, this.config.vars))
        });
    }
    adapter() {
        return create(this.config, version);
    }
    sqlxAction(actionOptions) {
        const { sqlxConfig } = actionOptions;
        if (actionOptions.sqlStatementCount > 1 && sqlxConfig.type !== "operations") {
            this.compileError("Actions may only contain more than one SQL statement if they are of type 'operations'.");
        }
        if (sqlxConfig.hasOwnProperty("protected") && sqlxConfig.type !== "incremental") {
            this.compileError("Actions may only specify 'protected: true' if they are of type 'incremental'.");
        }
        if (actionOptions.incrementalWhereContextable && sqlxConfig.type !== "incremental") {
            this.compileError("Actions may only include incremental_where if they are of type 'incremental'.");
        }
        if (!sqlxConfig.hasOwnProperty("schema") && sqlxConfig.type === "declaration") {
            this.compileError("Actions of type 'declaration' must specify a value for 'schema'.");
        }
        if (actionOptions.inputContextables.length > 0 && sqlxConfig.type !== "test") {
            this.compileError("Actions may only include input blocks if they are of type 'test'.");
        }
        if (actionOptions.preOperationsContextable && !definesDataset(sqlxConfig.type)) {
            this.compileError("Actions may only include pre_operations if they create a dataset.");
        }
        if (actionOptions.postOperationsContextable && !definesDataset(sqlxConfig.type)) {
            this.compileError("Actions may only include post_operations if they create a dataset.");
        }
        if (!!sqlxConfig.hasOwnProperty("sqldatawarehouse") &&
            !["bigquery", "snowflake"].includes(this.config.warehouse)) {
            this.compileError("Actions may only specify 'database' in projects whose warehouse is 'BigQuery' or 'Snowflake'.");
        }
        switch (sqlxConfig.type) {
            case "view":
            case "table":
            case "inline":
            case "incremental":
                const table = this.publish(sqlxConfig.name)
                    .config(sqlxConfig)
                    .query(ctx => actionOptions.sqlContextable(ctx)[0]);
                if (actionOptions.incrementalWhereContextable) {
                    table.where(actionOptions.incrementalWhereContextable);
                }
                if (actionOptions.preOperationsContextable) {
                    table.preOps(actionOptions.preOperationsContextable);
                }
                if (actionOptions.postOperationsContextable) {
                    table.postOps(actionOptions.postOperationsContextable);
                }
                break;
            case "assertion":
                this.assert(sqlxConfig.name)
                    .config(sqlxConfig)
                    .query(ctx => actionOptions.sqlContextable(ctx)[0]);
                break;
            case "operations":
                this.operate(sqlxConfig.name)
                    .config(sqlxConfig)
                    .queries(actionOptions.sqlContextable);
                break;
            case "declaration":
                this.declare({
                    database: sqlxConfig.database,
                    schema: sqlxConfig.schema,
                    name: sqlxConfig.name
                }).config(sqlxConfig);
                break;
            case "test":
                const testCase = this.test(sqlxConfig.name)
                    .config(sqlxConfig)
                    .expect(ctx => actionOptions.sqlContextable(ctx)[0]);
                actionOptions.inputContextables.forEach(({ refName, contextable }) => {
                    testCase.input(refName, contextable);
                });
                break;
            default:
                throw new Error(`Unrecognized action type: ${sqlxConfig.type}`);
        }
    }
    resolve(ref, ...rest) {
        ref = toResolvable(ref, rest);
        const allResolved = this.findActions(resolvableAsTarget(ref));
        if (allResolved.length > 1) {
            this.compileError(new Error(ambiguousActionNameMsg(ref, allResolved)));
        }
        const resolved = allResolved.length > 0 ? allResolved[0] : undefined;
        if (resolved && resolved instanceof Table && resolved.proto.type === "inline") {
            return `(${resolved.proto.query})`;
        }
        if (resolved && resolved instanceof Operation && !resolved.proto.hasOutput) {
            this.compileError(new Error("Actions cannot resolve operations which do not produce output."));
        }
        if (resolved) {
            if (resolved instanceof Declaration) {
                return this.adapter().resolveTarget(resolved.proto.target);
            }
            return this.adapter().resolveTarget(Object.assign(Object.assign({}, resolved.proto.target), { database: resolved.proto.target.database &&
                    this.adapter().normalizeIdentifier(`${resolved.proto.target.database}${this.getDatabaseSuffixWithUnderscore()}`), schema: this.adapter().normalizeIdentifier(`${resolved.proto.target.schema}${this.getSchemaSuffixWithUnderscore()}`), name: this.adapter().normalizeIdentifier(`${this.getTablePrefixWithUnderscore()}${resolved.proto.target.name}`) }));
        }
        if (typeof ref === "string") {
            return this.adapter().resolveTarget(target(this.adapter(), this.config, this.adapter().normalizeIdentifier(`${this.getTablePrefixWithUnderscore()}${ref}`), this.adapter().normalizeIdentifier(`${this.config.defaultSchema}${this.getSchemaSuffixWithUnderscore()}`), this.config.defaultDatabase &&
                this.adapter().normalizeIdentifier(`${this.config.defaultDatabase}${this.getDatabaseSuffixWithUnderscore()}`)));
        }
        return this.adapter().resolveTarget(target(this.adapter(), this.config, this.adapter().normalizeIdentifier(`${this.getTablePrefixWithUnderscore()}${ref.name}`), this.adapter().normalizeIdentifier(`${ref.schema}${this.getSchemaSuffixWithUnderscore()}`), ref.database &&
            this.adapter().normalizeIdentifier(`${ref.database}${this.getDatabaseSuffixWithUnderscore()}`)));
    }
    operate(name, queries) {
        const operation = new Operation();
        operation.session = this;
        setNameAndTarget(this, operation.proto, name);
        if (queries) {
            operation.queries(queries);
        }
        operation.proto.fileName = getCallerFile(this.rootDir);
        this.actions.push(operation);
        return operation;
    }
    publish(name, queryOrConfig) {
        const newTable = new Table();
        newTable.session = this;
        setNameAndTarget(this, newTable.proto, name);
        if (!!queryOrConfig) {
            if (typeof queryOrConfig === "object") {
                newTable.config(queryOrConfig);
            }
            else {
                newTable.query(queryOrConfig);
            }
        }
        newTable.proto.fileName = getCallerFile(this.rootDir);
        this.actions.push(newTable);
        return newTable;
    }
    assert(name, query) {
        const assertion = new Assertion();
        assertion.session = this;
        setNameAndTarget(this, assertion.proto, name, this.config.assertionSchema);
        if (query) {
            assertion.query(query);
        }
        assertion.proto.fileName = getCallerFile(this.rootDir);
        this.actions.push(assertion);
        return assertion;
    }
    declare(dataset) {
        const declaration = new Declaration();
        declaration.session = this;
        setNameAndTarget(this, declaration.proto, dataset.name, dataset.schema, dataset.database);
        declaration.proto.fileName = getCallerFile(this.rootDir);
        this.actions.push(declaration);
        return declaration;
    }
    test(name) {
        const newTest = new Test();
        newTest.session = this;
        newTest.proto.name = name;
        newTest.proto.fileName = getCallerFile(this.rootDir);
        this.tests[name] = newTest;
        return newTest;
    }
    compileError(err, path, actionName) {
        const fileName = path || getCallerFile(this.rootDir) || __filename;
        const compileError = dataform.CompilationError.create({
            fileName,
            actionName
        });
        if (typeof err === "string") {
            compileError.message = err;
        }
        else {
            compileError.message = err.message;
            compileError.stack = err.stack;
        }
        this.graphErrors.compilationErrors.push(compileError);
    }
    compile() {
        const compiledGraph = dataform.CompiledGraph.create({
            projectConfig: this.config,
            tables: this.compileGraphChunk(this.actions.filter(action => action instanceof Table)),
            operations: this.compileGraphChunk(this.actions.filter(action => action instanceof Operation)),
            assertions: this.compileGraphChunk(this.actions.filter(action => action instanceof Assertion)),
            declarations: this.compileGraphChunk(this.actions.filter(action => action instanceof Declaration)),
            tests: this.compileGraphChunk(Object.values(this.tests)),
            graphErrors: this.graphErrors,
            dataformCoreVersion: version,
            targets: this.actions.map(action => action.proto.target)
        });
        this.fullyQualifyDependencies([].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations));
        this.alterActionName([].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations), [].concat(compiledGraph.declarations.map(declaration => declaration.target)));
        const standardActions = [].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations, compiledGraph.declarations);
        this.checkActionNameUniqueness(standardActions);
        this.checkTestNameUniqueness(compiledGraph.tests);
        this.checkCanonicalTargetUniqueness(standardActions);
        this.checkTableConfigValidity(compiledGraph.tables);
        this.checkCircularity([].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations));
        if (this.config.useRunCache) {
            this.checkRunCachingCorrectness([].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations.filter(operation => operation.hasOutput)));
        }
        return compiledGraph;
    }
    compileToBase64() {
        return encode(dataform.CompiledGraph, this.compile());
    }
    findActions(target) {
        const adapter = this.adapter();
        return this.actions.filter(action => {
            if (!!target.database &&
                action.proto.target.database !== adapter.normalizeIdentifier(target.database)) {
                return false;
            }
            if (!!target.schema &&
                action.proto.target.schema !== adapter.normalizeIdentifier(target.schema)) {
                return false;
            }
            return action.proto.target.name === adapter.normalizeIdentifier(target.name);
        });
    }
    getDatabaseSuffixWithUnderscore() {
        return !!this.config.databaseSuffix ? `_${this.config.databaseSuffix}` : "";
    }
    getSchemaSuffixWithUnderscore() {
        return !!this.config.schemaSuffix ? `_${this.config.schemaSuffix}` : "";
    }
    getTablePrefixWithUnderscore() {
        return !!this.config.tablePrefix ? `${this.config.tablePrefix}_` : "";
    }
    compileGraphChunk(actions) {
        const compiledChunks = [];
        actions.forEach(action => {
            try {
                const compiledChunk = action.compile();
                compiledChunks.push(compiledChunk);
            }
            catch (e) {
                this.compileError(e, action.proto.fileName, action.proto.name);
            }
        });
        return compiledChunks;
    }
    fullyQualifyDependencies(actions) {
        actions.forEach(action => {
            const fullyQualifiedDependencies = {};
            for (const dependency of action.dependencyTargets) {
                const possibleDeps = this.findActions(dependency);
                if (possibleDeps.length === 0) {
                    this.compileError(new Error(`Missing dependency detected: Action "${action.name}" depends on "${stringifyResolvable(dependency)}" which does not exist`), action.fileName, action.name);
                }
                else if (possibleDeps.length === 1) {
                    const protoDep = possibleDeps[0].proto;
                    if (protoDep instanceof dataform.Table && protoDep.type === "inline") {
                        protoDep.dependencyTargets.forEach(inlineDep => action.dependencyTargets.push(inlineDep));
                    }
                    else {
                        fullyQualifiedDependencies[protoDep.name] = protoDep.target;
                    }
                }
                else {
                    this.compileError(new Error(ambiguousActionNameMsg(dependency, possibleDeps)), action.fileName, action.name);
                }
            }
            action.dependencies = Object.keys(fullyQualifiedDependencies);
            action.dependencyTargets = Object.values(fullyQualifiedDependencies);
        });
    }
    alterActionName(actions, declarationTargets) {
        const { tablePrefix, schemaSuffix, databaseSuffix } = this.config;
        if (!tablePrefix && !schemaSuffix && !databaseSuffix) {
            return;
        }
        const newTargetByOriginalTarget = new StringifiedMap(JSONObjectStringifier.create());
        declarationTargets.forEach(declarationTarget => newTargetByOriginalTarget.set(declarationTarget, declarationTarget));
        actions.forEach(action => {
            newTargetByOriginalTarget.set(action.target, Object.assign(Object.assign({}, action.target), { database: action.target.database &&
                    this.adapter().normalizeIdentifier(`${action.target.database}${this.getDatabaseSuffixWithUnderscore()}`), schema: this.adapter().normalizeIdentifier(`${action.target.schema}${this.getSchemaSuffixWithUnderscore()}`), name: this.adapter().normalizeIdentifier(`${this.getTablePrefixWithUnderscore()}${action.target.name}`) }));
            action.target = newTargetByOriginalTarget.get(action.target);
            action.name = targetToName(action.target);
        });
        actions.forEach(action => {
            action.dependencyTargets = (action.dependencyTargets || []).map(dependencyTarget => newTargetByOriginalTarget.get(dependencyTarget));
            action.dependencies = (action.dependencyTargets || []).map(dependencyTarget => targetToName(dependencyTarget));
            if (!!action.parentAction) {
                action.parentAction = newTargetByOriginalTarget.get(action.parentAction);
            }
        });
    }
    checkActionNameUniqueness(actions) {
        const allNames = [];
        actions.forEach(action => {
            if (allNames.includes(action.name)) {
                this.compileError(new Error(`Duplicate action name detected. Names within a schema must be unique across tables, declarations, assertions, and operations`), action.fileName, action.name);
            }
            allNames.push(action.name);
        });
    }
    checkCanonicalTargetUniqueness(actions) {
        const allCanonicalTargets = new StringifiedMap(JSONObjectStringifier.create());
        actions.forEach(action => {
            if (allCanonicalTargets.has(action.canonicalTarget)) {
                this.compileError(new Error(`Duplicate canonical target detected. Canonical targets must be unique across tables, declarations, assertions, and operations:\n"${JSON.stringify(action.canonicalTarget)}"`), action.fileName, action.name);
            }
            allCanonicalTargets.set(action.canonicalTarget, true);
        });
    }
    checkTableConfigValidity(tables) {
        tables.forEach(table => {
            var _a, _b;
            if (!!table.type && !TableType.includes(table.type)) {
                this.compileError(`Wrong type of table detected. Should only use predefined types: ${joinQuoted(TableType)}`, table.fileName, table.name);
            }
            if (!!table.snowflake) {
                if (table.snowflake.secure && table.type !== "view") {
                    this.compileError(new Error(`The 'secure' option is only valid for Snowflake views`), table.fileName, table.name);
                }
                if (table.snowflake.transient && table.type !== "table") {
                    this.compileError(new Error(`The 'transient' option is only valid for Snowflake tables`), table.fileName, table.name);
                }
                if (((_a = table.snowflake.clusterBy) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
                    table.type !== "table" &&
                    table.type !== "incremental") {
                    this.compileError(new Error(`The 'clusterBy' option is only valid for Snowflake tables`), table.fileName, table.name);
                }
            }
            if (!!table.sqlDataWarehouse) {
                if (!!table.uniqueKey && table.uniqueKey.length > 0) {
                    this.compileError(new Error(`Merging using unique keys for SQLDataWarehouse has not yet been implemented`), table.fileName, table.name);
                }
                if (table.sqlDataWarehouse.distribution) {
                    const distribution = table.sqlDataWarehouse.distribution.toUpperCase();
                    if (distribution !== "REPLICATE" &&
                        distribution !== "ROUND_ROBIN" &&
                        !SQL_DATA_WAREHOUSE_DIST_HASH_REGEXP.test(distribution)) {
                        this.compileError(new Error(`Invalid value for sqldatawarehouse distribution: ${distribution}`), table.fileName, table.name);
                    }
                }
            }
            if (!!table.redshift) {
                const validatePropertyDefined = (opts, prop) => {
                    const value = opts[prop];
                    if (!opts.hasOwnProperty(prop)) {
                        this.compileError(`Property "${prop}" is not defined`, table.fileName, table.name);
                    }
                    else if (value instanceof Array) {
                        if (value.length === 0) {
                            this.compileError(`Property "${prop}" is not defined`, table.fileName, table.name);
                        }
                    }
                };
                const validatePropertiesDefined = (opts, props) => props.forEach(prop => validatePropertyDefined(opts, prop));
                const validatePropertyValueInValues = (opts, prop, values) => {
                    if (!!opts[prop] && !values.includes(opts[prop])) {
                        this.compileError(`Wrong value of "${prop}" property. Should only use predefined values: ${joinQuoted(values)}`, table.fileName, table.name);
                    }
                };
                if (table.redshift.distStyle || table.redshift.distKey) {
                    validatePropertiesDefined(table.redshift, ["distStyle", "distKey"]);
                    validatePropertyValueInValues(table.redshift, "distStyle", DistStyleType);
                }
                if (table.redshift.sortStyle ||
                    (table.redshift.sortKeys && table.redshift.sortKeys.length)) {
                    validatePropertiesDefined(table.redshift, ["sortStyle", "sortKeys"]);
                    validatePropertyValueInValues(table.redshift, "sortStyle", SortStyleType);
                }
            }
            if (!!table.bigquery) {
                if ((table.bigquery.partitionBy || ((_b = table.bigquery.clusterBy) === null || _b === void 0 ? void 0 : _b.length)) &&
                    table.type === "view") {
                    this.compileError(`partitionBy/clusterBy are not valid for BigQuery views; they are only valid for tables`, table.fileName, table.name);
                }
            }
            if (!!Table.IGNORED_PROPS[table.type]) {
                Table.IGNORED_PROPS[table.type].forEach(ignoredProp => {
                    if (objectExistsOrIsNonEmpty(table[ignoredProp])) {
                        this.compileError(`Unused property was detected: "${ignoredProp}". This property is not used for tables with type "${table.type}" and will be ignored`, table.fileName, table.name);
                    }
                });
            }
        });
    }
    checkTestNameUniqueness(tests) {
        const allNames = [];
        tests.forEach(testProto => {
            if (allNames.includes(testProto.name)) {
                this.compileError(new Error(`Duplicate test name detected: "${testProto.name}"`), testProto.fileName, testProto.name);
            }
            allNames.push(testProto.name);
        });
    }
    checkCircularity(actions) {
        const allActionsByName = keyByName(actions);
        const tarjanGraph = new TarjanGraphConstructor();
        actions.forEach(action => {
            const cleanedDependencies = (action.dependencies || []).filter(dependency => !!allActionsByName[dependency]);
            tarjanGraph.add(action.name, cleanedDependencies);
        });
        const cycles = tarjanGraph.getCycles();
        cycles.forEach(cycle => {
            const firstActionInCycle = allActionsByName[cycle[0].name];
            const message = `Circular dependency detected in chain: [${cycle
                .map(vertex => vertex.name)
                .join(" > ")} > ${firstActionInCycle.name}]`;
            this.compileError(new Error(message), firstActionInCycle.fileName);
        });
    }
    checkRunCachingCorrectness(actionsWithOutput) {
        actionsWithOutput.forEach(action => {
            var _a;
            if (((_a = action.dependencies) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                return;
            }
            if ([dataform.ActionHermeticity.HERMETIC, dataform.ActionHermeticity.NON_HERMETIC].includes(action.hermeticity)) {
                return;
            }
            this.compileError(new Error("Zero-dependency actions which create datasets are required to explicitly declare 'hermetic: (true|false)' when run caching is turned on."), action.fileName, action.name);
        });
    }
}
function definesDataset(type) {
    return type === "view" || type === "table" || type === "inline" || type === "incremental";
}
function keyByName(actions) {
    const actionsByName = {};
    actions.forEach(action => (actionsByName[action.name] = action));
    return actionsByName;
}
function getCanonicalProjectConfig(originalProjectConfig) {
    return {
        warehouse: originalProjectConfig.warehouse,
        defaultSchema: originalProjectConfig.defaultSchema,
        defaultDatabase: originalProjectConfig.defaultDatabase,
        assertionSchema: originalProjectConfig.assertionSchema
    };
}
function joinQuoted(values) {
    return values.map((value) => `"${value}"`).join(" | ");
}
function objectExistsOrIsNonEmpty(prop) {
    if (!prop) {
        return false;
    }
    return ((Array.isArray(prop) && !!prop.length) ||
        (!Array.isArray(prop) && typeof prop === "object" && !!Object.keys(prop).length) ||
        typeof prop !== "object");
}

function globalSession() {
    if (!global._DF_SESSION) {
        global._DF_SESSION = new Session(process.cwd());
    }
    return global._DF_SESSION;
}
const session = globalSession();

async function build(compiledGraph, runConfig, dbadapter) {
    runConfig = Object.assign(Object.assign({}, runConfig), { useRunCache: runConfig.hasOwnProperty("useRunCache") && typeof runConfig.useRunCache !== "undefined"
            ? runConfig.useRunCache
            : compiledGraph.projectConfig.useRunCache });
    const prunedGraph = prune(compiledGraph, runConfig);
    const transitiveInputsByTarget = computeAllTransitiveInputs(compiledGraph);
    const allInvolvedTargets = new StringifiedSet(JSONObjectStringifier.create(), prunedGraph.tables.map(table => table.target));
    if (runConfig.useRunCache) {
        for (const includedAction of [
            ...prunedGraph.tables,
            ...prunedGraph.operations,
            ...prunedGraph.assertions
        ]) {
            allInvolvedTargets.add(includedAction.target);
            if (versionValidForTransitiveInputs(compiledGraph)) {
                transitiveInputsByTarget
                    .get(includedAction.target)
                    .forEach(transitiveInputTarget => allInvolvedTargets.add(transitiveInputTarget));
            }
        }
    }
    return new Builder(prunedGraph, runConfig, await state(dbadapter, Array.from(allInvolvedTargets)), transitiveInputsByTarget).build();
}
class Builder {
    constructor(prunedGraph, runConfig, warehouseState, transitiveInputsByTarget) {
        this.prunedGraph = prunedGraph;
        this.runConfig = runConfig;
        this.warehouseState = warehouseState;
        this.transitiveInputsByTarget = transitiveInputsByTarget;
        this.adapter = create(prunedGraph.projectConfig, prunedGraph.dataformCoreVersion || "1.0.0");
    }
    build() {
        if (graphHasErrors(this.prunedGraph)) {
            throw new Error(`Project has unresolved compilation or validation errors.`);
        }
        const tableMetadataByTarget = new StringifiedMap(JSONObjectStringifier.create());
        this.warehouseState.tables.forEach(tableState => {
            tableMetadataByTarget.set(tableState.target, tableState);
        });
        const actions = [].concat(this.prunedGraph.tables.map(t => this.buildTable(t, tableMetadataByTarget.get(t.target), this.runConfig)), this.prunedGraph.operations.map(o => this.buildOperation(o)), this.prunedGraph.assertions.map(a => this.buildAssertion(a)));
        return dataform.ExecutionGraph.create({
            projectConfig: this.prunedGraph.projectConfig,
            runConfig: this.runConfig,
            warehouseState: this.warehouseState,
            declarationTargets: this.prunedGraph.declarations.map(declaration => declaration.target),
            actions
        });
    }
    buildTable(table, tableMetadata, runConfig) {
        if (table.protected && this.runConfig.fullRefresh) {
            throw new Error("Protected datasets cannot be fully refreshed.");
        }
        return Object.assign(Object.assign({}, this.toPartialExecutionAction(table)), { type: "table", tableType: table.type, tasks: table.disabled
                ? []
                : this.adapter.publishTasks(table, runConfig, tableMetadata).build(), hermeticity: table.hermeticity || dataform.ActionHermeticity.HERMETIC });
    }
    buildOperation(operation) {
        return Object.assign(Object.assign({}, this.toPartialExecutionAction(operation)), { type: "operation", tasks: operation.disabled
                ? []
                : operation.queries.map(statement => ({ type: "statement", statement })), hermeticity: operation.hermeticity || dataform.ActionHermeticity.NON_HERMETIC });
    }
    buildAssertion(assertion) {
        return Object.assign(Object.assign({}, this.toPartialExecutionAction(assertion)), { type: "assertion", tasks: assertion.disabled
                ? []
                : this.adapter.assertTasks(assertion, this.prunedGraph.projectConfig).build(), hermeticity: assertion.hermeticity || dataform.ActionHermeticity.HERMETIC });
    }
    toPartialExecutionAction(action) {
        return dataform.ExecutionAction.create({
            name: action.name,
            target: action.target,
            fileName: action.fileName,
            dependencies: action.dependencies,
            transitiveInputs: versionValidForTransitiveInputs(this.prunedGraph)
                ? Array.from(this.transitiveInputsByTarget.get(action.target))
                : [],
            actionDescriptor: action.actionDescriptor
        });
    }
}
function versionValidForTransitiveInputs(compiledGraph) {
    return (compiledGraph.dataformCoreVersion && semver.gte(compiledGraph.dataformCoreVersion, "1.6.11"));
}
function computeAllTransitiveInputs(compiledGraph) {
    const transitiveInputsByTarget = new StringifiedMap(JSONObjectStringifier.create());
    if (!versionValidForTransitiveInputs(compiledGraph)) {
        return transitiveInputsByTarget;
    }
    const actionsByTargetMap = actionsByTarget(compiledGraph);
    for (const action of [
        ...compiledGraph.tables,
        ...compiledGraph.operations,
        ...compiledGraph.assertions
    ]) {
        if (!transitiveInputsByTarget.has(action.target)) {
            transitiveInputsByTarget.set(action.target, computeTransitiveInputsForAction(action, actionsByTargetMap, transitiveInputsByTarget));
        }
    }
    return transitiveInputsByTarget;
}
function computeTransitiveInputsForAction(action, actionByTarget, transitiveInputsByTarget) {
    const transitiveInputTargets = new StringifiedSet(JSONObjectStringifier.create());
    if (!transitiveInputsByTarget.has(action.target)) {
        for (const transitiveInputTarget of action.dependencyTargets || []) {
            transitiveInputTargets.add(transitiveInputTarget);
            const transitiveInputAction = actionByTarget.get(transitiveInputTarget);
            if (!((transitiveInputAction instanceof dataform.Table &&
                ["table", "incremental"].includes(transitiveInputAction.type)) ||
                transitiveInputAction instanceof dataform.Declaration)) {
                computeTransitiveInputsForAction(transitiveInputAction, actionByTarget, transitiveInputsByTarget).forEach(target => transitiveInputTargets.add(target));
            }
        }
        transitiveInputsByTarget.set(action.target, transitiveInputTargets);
    }
    return transitiveInputsByTarget.get(action.target);
}

function parseAzureEvaluationError(error) {
    const evalError = dataform.QueryEvaluationError.create({
        message: String(error)
    });
    try {
        if (error.originalError && error.originalError.info && error.originalError.info.message) {
            const message = error.originalError.info.message;
            evalError.message = message;
            const [_, lineNumber, columnNumber] = message.match(/[^0-9]*([0-9]*)[^0-9]*([0-9]*).*/);
            evalError.errorLocation = { line: Number(lineNumber), column: Number(columnNumber) };
            return evalError;
        }
    }
    catch (_) {
    }
    return evalError;
}
function parseRedshiftEvalError(statement, error) {
    const evalError = dataform.QueryEvaluationError.create({
        message: String(error)
    });
    try {
        if (!error.position) {
            return evalError;
        }
        const statementBeforeError = statement.substring(0, Number(error.position));
        const lineNumber = statementBeforeError.split("\n").length;
        const lineIncludingError = statementBeforeError.split("\n").slice(-1)[0];
        const colNumber = lineIncludingError.length + 1;
        evalError.errorLocation = { line: lineNumber, column: colNumber };
    }
    catch (_) {
    }
    return evalError;
}
function parseBigqueryEvalError(error) {
    const evalError = dataform.QueryEvaluationError.create({
        message: String(error)
    });
    try {
        if (!error.message) {
            return evalError;
        }
        const bracketsString = error.message.split("[").slice(-1)[0];
        const [_, lineNumber, columnNumber] = bracketsString.match(/([0-9]*)[^0-9]*([0-9]*).*/);
        const line = Number(lineNumber);
        const column = Number(columnNumber);
        if (line || line === 0) {
            evalError.errorLocation = { line, column };
        }
    }
    catch (_) {
    }
    return evalError;
}
function parseSnowflakeEvalError(error) {
    const evalError = dataform.QueryEvaluationError.create({
        message: error
    });
    try {
        const regex = /line ([0-9]+) at position ([0-9]+)/;
        const match = error.match(regex);
        if (!match) {
        }
        evalError.errorLocation = {
            line: Number(match[1]),
            column: Number(match[2]) + 1
        };
    }
    catch (e) {
    }
    return evalError;
}

class LimitedResultSet {
    constructor(options) {
        this.options = options;
        this.results = [];
        this.currentBytes = 0;
    }
    push(row) {
        var _a, _b, _c, _d;
        this.currentBytes += sizeof(row);
        if ((((_a = this.options) === null || _a === void 0 ? void 0 : _a.rowLimit) && this.results.length >= ((_b = this.options) === null || _b === void 0 ? void 0 : _b.rowLimit)) ||
            (((_c = this.options) === null || _c === void 0 ? void 0 : _c.byteLimit) && this.currentBytes >= ((_d = this.options) === null || _d === void 0 ? void 0 : _d.byteLimit))) {
            return false;
        }
        this.results.push(row);
        return true;
    }
    get rows() {
        return this.results;
    }
}

async function retry(fn, maxAttempts = 1, matchesRetriableError = () => true) {
    let lastErr;
    for (let i = 0; i < maxAttempts; i++) {
        try {
            return await fn();
        }
        catch (e) {
            if (!matchesRetriableError(e)) {
                throw e;
            }
            lastErr = e;
        }
    }
    throw lastErr;
}

const EXTRA_GOOGLE_SCOPES = ["https://www.googleapis.com/auth/drive"];
const BIGQUERY_DATE_RELATED_FIELDS = [
    "BigQueryDate",
    "BigQueryTime",
    "BigQueryTimestamp",
    "BigQueryDatetime"
];
const BIGQUERY_INTERNAL_ERROR_JOB_MAX_ATTEMPTS = 3;
class BigQueryDbAdapter {
    constructor(credentials, options) {
        this.clients = new Map();
        this.bigQueryCredentials = credentials;
        this.pool = new PromisePool.PromisePoolExecutor({
            concurrencyLimit: (options === null || options === void 0 ? void 0 : options.concurrencyLimit) || 16,
            frequencyWindow: 1000,
            frequencyLimit: 30
        });
    }
    static async create(credentials, options) {
        return new BigQueryDbAdapter(credentials, options);
    }
    async execute(statement, options = { interactive: false, rowLimit: 1000, byteLimit: 1024 * 1024 }) {
        var _a;
        if ((options === null || options === void 0 ? void 0 : options.interactive) && ((_a = options === null || options === void 0 ? void 0 : options.bigquery) === null || _a === void 0 ? void 0 : _a.labels)) {
            throw new Error("BigQuery job labels may not be set for interactive queries.");
        }
        return this.pool
            .addSingleTask({
            generator: () => {
                var _a;
                return (options === null || options === void 0 ? void 0 : options.interactive) ? this.runQuery(statement, options === null || options === void 0 ? void 0 : options.params, options === null || options === void 0 ? void 0 : options.rowLimit, options === null || options === void 0 ? void 0 : options.byteLimit)
                    : this.createQueryJob(statement, options === null || options === void 0 ? void 0 : options.params, options === null || options === void 0 ? void 0 : options.rowLimit, options === null || options === void 0 ? void 0 : options.byteLimit, options === null || options === void 0 ? void 0 : options.onCancel, (_a = options === null || options === void 0 ? void 0 : options.bigquery) === null || _a === void 0 ? void 0 : _a.labels);
            }
        })
            .promise();
    }
    async withClientLock(callback) {
        return await callback(this);
    }
    async evaluate(queryOrAction, projectConfig) {
        const validationQueries = collectEvaluationQueries(queryOrAction, true);
        return await Promise.all(validationQueries.map(async ({ query, incremental }) => {
            try {
                await this.pool
                    .addSingleTask({
                    generator: () => this.getClient().query({
                        useLegacySql: false,
                        query,
                        dryRun: true
                    })
                })
                    .promise();
                return dataform.QueryEvaluation.create({
                    status: dataform.QueryEvaluation.QueryEvaluationStatus.SUCCESS,
                    incremental,
                    query
                });
            }
            catch (e) {
                return {
                    status: dataform.QueryEvaluation.QueryEvaluationStatus.FAILURE,
                    error: parseBigqueryEvalError(e),
                    incremental,
                    query
                };
            }
        }));
    }
    async tables() {
        const datasets = await this.getClient().getDatasets({ autoPaginate: true, maxResults: 1000 });
        const tables = await Promise.all(datasets[0].map(dataset => dataset.getTables({ autoPaginate: true, maxResults: 1000 })));
        const allTables = [];
        tables.forEach((tablesResult) => tablesResult[0].forEach(table => allTables.push({
            database: table.bigQuery.projectId,
            schema: table.dataset.id,
            name: table.id
        })));
        return allTables;
    }
    async search(searchText, options = { limit: 1000 }) {
        const results = await this.execute(`select table_catalog, table_schema, table_name
       from region-${this.bigQueryCredentials.location}.INFORMATION_SCHEMA.COLUMN_FIELD_PATHS
       where regexp_contains(table_schema, @searchText) or regexp_contains(table_name, @searchText) or regexp_contains(field_path, @searchText)
       group by 1, 2, 3`, {
            params: {
                searchText: `(?i)${searchText}`
            },
            interactive: true,
            rowLimit: options.limit
        });
        return await Promise.all(results.rows.map(row => this.table({
            database: row.table_catalog,
            schema: row.table_schema,
            name: row.table_name
        })));
    }
    async table(target) {
        var _a;
        const metadata = await this.getMetadata(target);
        if (!metadata) {
            return null;
        }
        const metadataTarget = {
            database: metadata.tableReference.projectId,
            schema: metadata.tableReference.datasetId,
            name: metadata.tableReference.tableId
        };
        if (metadata.tableReference.datasetId !== target.schema ||
            metadata.tableReference.tableId !== target.name) {
            throw new Error(`Target ${JSON.stringify(metadataTarget)} does not match requested target ${JSON.stringify(target)}.`);
        }
        return dataform.TableMetadata.create({
            typeDeprecated: String(metadata.type).toLowerCase(),
            type: metadata.type === "TABLE"
                ? dataform.TableMetadata.Type.TABLE
                : metadata.type === "VIEW"
                    ? dataform.TableMetadata.Type.VIEW
                    : dataform.TableMetadata.Type.UNKNOWN,
            target: metadataTarget,
            fields: (_a = metadata.schema.fields) === null || _a === void 0 ? void 0 : _a.map(field => convertField(field)),
            lastUpdatedMillis: Long.fromString(metadata.lastModifiedTime),
            description: metadata.description,
            labels: metadata.labels,
            bigquery: {
                hasStreamingBuffer: !!metadata.streamingBuffer
            }
        });
    }
    async preview(target, limitRows = 10) {
        const metadata = await this.getMetadata(target);
        if (metadata.type === "TABLE") {
            const rowsResult = await this.getClient(target.database)
                .dataset(target.schema)
                .table(target.name)
                .getRows({
                maxResults: limitRows
            });
            return cleanRows(rowsResult[0]);
        }
        const { rows } = await this.execute(`SELECT * FROM \`${metadata.tableReference.projectId}.${metadata.tableReference.datasetId}.${metadata.tableReference.tableId}\``, { rowLimit: limitRows });
        return rows;
    }
    async schemas(database) {
        const data = await this.getClient(database).getDatasets();
        return data[0].map(dataset => dataset.id);
    }
    async createSchema(database, schema) {
        const location = this.bigQueryCredentials.location || "US";
        const client = this.getClient(database);
        let metadata;
        try {
            const data = await client.dataset(schema).getMetadata();
            metadata = data[0];
        }
        catch (e) {
            await client.createDataset(schema, { location });
            return;
        }
        if (metadata.location.toUpperCase() !== location.toUpperCase()) {
            throw new Error(`Cannot create dataset "${schema}" in location "${location}". It already exists in location "${metadata.location}". Change your default dataset location or delete the existing dataset.`);
        }
    }
    async dropSchema(database, schema) {
        const client = this.getClient(database);
        try {
            await client.dataset(schema).getMetadata();
        }
        catch (e) {
            return;
        }
        await client.dataset(schema).delete({ force: true });
    }
    async close() {
    }
    async setMetadata(action) {
        const { target, actionDescriptor } = action;
        const metadata = await this.getMetadata(target);
        const schemaWithDescription = addDescriptionToMetadata(actionDescriptor.columns, metadata.schema.fields);
        await this.getClient(target.database)
            .dataset(target.schema)
            .table(target.name)
            .setMetadata({
            description: actionDescriptor.description,
            schema: schemaWithDescription,
            labels: actionDescriptor.bigqueryLabels
        });
    }
    async getMetadata(target) {
        var _a, _b;
        try {
            const table = await this.getClient(target.database)
                .dataset(target.schema)
                .table(target.name)
                .getMetadata();
            return table === null || table === void 0 ? void 0 : table[0];
        }
        catch (e) {
            if (((_b = (_a = e === null || e === void 0 ? void 0 : e.errors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.reason) === "notFound") {
                return null;
            }
            throw coerceAsError(e);
        }
    }
    getClient(projectId) {
        projectId = projectId || this.bigQueryCredentials.projectId;
        if (!this.clients.has(projectId)) {
            this.clients.set(projectId, new bigquery.BigQuery({
                projectId,
                credentials: JSON.parse(this.bigQueryCredentials.credentials),
                scopes: EXTRA_GOOGLE_SCOPES,
                location: this.bigQueryCredentials.location
            }));
        }
        return this.clients.get(projectId);
    }
    async runQuery(query, params, rowLimit, byteLimit) {
        const results = await new Promise((resolve, reject) => {
            const allRows = new LimitedResultSet({
                rowLimit,
                byteLimit
            });
            const stream = this.getClient().createQueryStream({
                query,
                params
            });
            stream
                .on("error", e => reject(coerceAsError(e)))
                .on("data", row => {
                if (!allRows.push(row)) {
                    stream.end();
                }
            })
                .on("end", () => {
                resolve(allRows.rows);
            });
        });
        return { rows: cleanRows(results), metadata: {} };
    }
    async createQueryJob(query, params, rowLimit, byteLimit, onCancel, labels) {
        let isCancelled = false;
        onCancel === null || onCancel === void 0 ? void 0 : onCancel(() => (isCancelled = true));
        return retry(async () => {
            try {
                const job = await this.getClient().createQueryJob({
                    useLegacySql: false,
                    jobPrefix: "dataform-",
                    query,
                    params,
                    labels
                });
                const resultStream = job[0].getQueryResultsStream();
                return new Promise((resolve, reject) => {
                    if (isCancelled) {
                        resultStream.end();
                        reject(new Error("Query cancelled."));
                        return;
                    }
                    onCancel === null || onCancel === void 0 ? void 0 : onCancel(() => {
                        resultStream.end();
                        reject(new Error("Query cancelled."));
                    });
                    const results = new LimitedResultSet({
                        rowLimit,
                        byteLimit
                    });
                    resultStream
                        .on("error", e => reject(e))
                        .on("data", row => {
                        if (!results.push(row)) {
                            resultStream.end();
                        }
                    })
                        .on("end", async () => {
                        var _a;
                        try {
                            const [jobMetadata] = await job[0].getMetadata();
                            if (!!((_a = jobMetadata.status) === null || _a === void 0 ? void 0 : _a.errorResult)) {
                                reject(new Error(jobMetadata.status.errorResult.message));
                                return;
                            }
                            resolve({
                                rows: results.rows,
                                metadata: {
                                    bigquery: {
                                        jobId: jobMetadata.jobReference.jobId,
                                        totalBytesBilled: jobMetadata.statistics.query.totalBytesBilled
                                            ? Long.fromString(jobMetadata.statistics.query.totalBytesBilled)
                                            : Long.ZERO,
                                        totalBytesProcessed: jobMetadata.statistics.query.totalBytesProcessed
                                            ? Long.fromString(jobMetadata.statistics.query.totalBytesProcessed)
                                            : Long.ZERO
                                    }
                                }
                            });
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                });
            }
            catch (e) {
                throw coerceAsError(e);
            }
        }, BIGQUERY_INTERNAL_ERROR_JOB_MAX_ATTEMPTS, e => { var _a; return (_a = e.message) === null || _a === void 0 ? void 0 : _a.includes("Retrying the job may solve the problem"); });
    }
}
function cleanRows(rows) {
    if (rows.length === 0) {
        return rows;
    }
    const sampleData = rows[0];
    const fieldsWithBigQueryDates = Object.keys(sampleData).filter(key => sampleData[key] &&
        sampleData[key].constructor &&
        BIGQUERY_DATE_RELATED_FIELDS.includes(sampleData[key].constructor.name));
    fieldsWithBigQueryDates.forEach(dateField => {
        rows.forEach(row => (row[dateField] = row[dateField] ? row[dateField].value : row[dateField]));
    });
    return rows;
}
function convertField(field) {
    const result = {
        name: field.name,
        flagsDeprecated: !!field.mode ? [field.mode] : [],
        flags: field.mode === "REPEATED" ? [dataform.Field.Flag.REPEATED] : [],
        description: field.description
    };
    if (field.type === "RECORD" || field.type === "STRUCT") {
        result.struct = dataform.Fields.create({
            fields: field.fields.map(innerField => convertField(innerField))
        });
    }
    else {
        result.primitive = convertFieldType(field.type);
    }
    return dataform.Field.create(result);
}
function convertFieldType(type) {
    switch (String(type).toUpperCase()) {
        case "FLOAT":
        case "FLOAT64":
            return dataform.Field.Primitive.FLOAT;
        case "INTEGER":
        case "INT64":
            return dataform.Field.Primitive.INTEGER;
        case "NUMERIC":
            return dataform.Field.Primitive.NUMERIC;
        case "BOOL":
        case "BOOLEAN":
            return dataform.Field.Primitive.BOOLEAN;
        case "STRING":
            return dataform.Field.Primitive.STRING;
        case "DATE":
            return dataform.Field.Primitive.DATE;
        case "DATETIME":
            return dataform.Field.Primitive.DATETIME;
        case "TIMESTAMP":
            return dataform.Field.Primitive.TIMESTAMP;
        case "TIME":
            return dataform.Field.Primitive.TIME;
        case "BYTES":
            return dataform.Field.Primitive.BYTES;
        case "GEOGRAPHY":
            return dataform.Field.Primitive.GEOGRAPHY;
        default:
            return dataform.Field.Primitive.UNKNOWN;
    }
}
function addDescriptionToMetadata(columnDescriptions, metadataArray) {
    const findDescription = (path) => columnDescriptions.find(column => column.path.join("") === path.join(""));
    const mapDescriptionToMetadata = (metadata, path) => {
        var _a;
        const description = findDescription(path);
        if (description) {
            metadata.description = description.description;
            if (((_a = description.bigqueryPolicyTags) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                metadata.policyTags = {
                    names: description.bigqueryPolicyTags
                };
            }
        }
        if (metadata.fields) {
            metadata.fields = metadata.fields.map(nestedMetadata => mapDescriptionToMetadata(nestedMetadata, [...path, nestedMetadata.name]));
        }
        return metadata;
    };
    const newMetadata = metadataArray.map(metaItem => mapDescriptionToMetadata(metaItem, [metaItem.name]));
    return newMetadata;
}

class SSHTunnelProxy {
    constructor(sshClient, proxy, localPort) {
        this.sshClient = sshClient;
        this.proxy = proxy;
        this.localPort = localPort;
        this.connections = new Set();
        proxy.on("connection", socket => {
            this.connections.add(socket);
            socket.once("close", () => this.connections.delete(socket));
        });
    }
    static async create(tunnel, destination) {
        const localPort = await getPort();
        const sshClient = new ssh2.Client();
        const proxy = net.createServer(sock => {
            sshClient.forwardOut(sock.remoteAddress, sock.remotePort, destination.host, destination.port, (err, stream) => {
                if (err) {
                    return sock.destroy(err);
                }
                sock.pipe(stream);
                stream.pipe(sock);
            });
        });
        proxy.listen(localPort, "127.0.0.1");
        sshClient.connect({
            host: tunnel.host,
            port: tunnel.port,
            username: tunnel.username,
            privateKey: tunnel.privateKey
        });
        await new Promise((resolve, reject) => {
            sshClient.on("error", (err) => reject(err));
            sshClient.on("ready", () => resolve());
        });
        return new SSHTunnelProxy(sshClient, proxy, localPort);
    }
    async close() {
        this.sshClient.destroy();
        this.connections.forEach(socket => socket.destroy());
        await new Promise(resolve => this.proxy.close(() => resolve()));
    }
}

const maybeInitializePg = (() => {
    let initialized = false;
    return () => {
        if (!initialized) {
            initialized = true;
            pg.types.setTypeParser(20, Number);
        }
    };
})();
class PgPoolExecutor {
    constructor(clientConfig, options) {
        maybeInitializePg();
        this.pool = new pg.Pool(Object.assign(Object.assign({}, clientConfig), { max: options === null || options === void 0 ? void 0 : options.concurrencyLimit }));
        this.pool.on("error", err => {
            console.error("pg.Pool idle client error", err.message, err.stack);
        });
    }
    async withClientLock(callback) {
        const client = await this.pool.connect();
        try {
            client.on("error", err => {
                console.error("pg.Client client error", err.message, err.stack);
                try {
                    client.release(err);
                }
                catch (e) {
                    console.error("Error thrown when releasing errored pg.Client", e.message, e.stack);
                }
            });
            return await callback({
                execute: async (statement, options = { rowLimit: 1000, byteLimit: 1024 * 1024 }) => {
                    return await new Promise((resolve, reject) => {
                        var _a;
                        const query = client.query(new QueryStream(statement, options === null || options === void 0 ? void 0 : options.params));
                        const results = new LimitedResultSet({
                            rowLimit: options === null || options === void 0 ? void 0 : options.rowLimit,
                            byteLimit: options === null || options === void 0 ? void 0 : options.byteLimit
                        });
                        (_a = options === null || options === void 0 ? void 0 : options.onCancel) === null || _a === void 0 ? void 0 : _a.call(options, () => query.destroy(new Error("Query cancelled.")));
                        query.on("data", (row) => {
                            try {
                                verifyUniqueColumnNames(query.cursor._result.fields);
                            }
                            catch (e) {
                                query.destroy(e);
                                return;
                            }
                            if (!results.push(row)) {
                                query.cursor.close();
                            }
                        });
                        query.on("error", err => {
                            try {
                                client.release(err);
                            }
                            catch (e) {
                                console.error("Error thrown when releasing errored pg.Query", e.message, e.stack);
                            }
                            reject(err);
                        });
                        query.on("end", () => {
                            resolve(results.rows);
                        });
                    });
                }
            });
        }
        finally {
            try {
                client.release();
            }
            catch (e) {
                console.error("Error thrown when releasing ended pg.Client", e.message, e.stack);
            }
        }
    }
    async close() {
        await this.pool.end();
    }
}
function verifyUniqueColumnNames(fields) {
    const colNames = new Set();
    fields.forEach(field => {
        if (colNames.has(field.name)) {
            throw new Error(`Ambiguous column name: ${field.name}`);
        }
        colNames.add(field.name);
    });
}
function convertFieldType$1(type) {
    switch (String(type).toUpperCase()) {
        case "FLOAT":
        case "FLOAT4":
        case "FLOAT8":
        case "DOUBLE PRECISION":
        case "REAL":
            return dataform.Field.Primitive.FLOAT;
        case "INTEGER":
        case "INT":
        case "INT2":
        case "INT4":
        case "INT8":
        case "BIGINT":
        case "SMALLINT":
            return dataform.Field.Primitive.INTEGER;
        case "DECIMAL":
        case "NUMERIC":
            return dataform.Field.Primitive.NUMERIC;
        case "BOOLEAN":
        case "BOOL":
            return dataform.Field.Primitive.BOOLEAN;
        case "STRING":
        case "VARCHAR":
        case "CHAR":
        case "CHARACTER":
        case "CHARACTER VARYING":
        case "NVARCHAR":
        case "TEXT":
        case "NCHAR":
        case "BPCHAR":
            return dataform.Field.Primitive.STRING;
        case "DATE":
            return dataform.Field.Primitive.DATE;
        case "TIMESTAMP":
        case "TIMESTAMPZ":
        case "TIMESTAMP WITHOUT TIME ZONE":
        case "TIMESTAMP WITH TIME ZONE":
            return dataform.Field.Primitive.TIMESTAMP;
        default:
            return dataform.Field.Primitive.UNKNOWN;
    }
}

class PostgresDbAdapter {
    constructor(queryExecutor, options) {
        this.queryExecutor = queryExecutor;
        this.options = options;
    }
    static async create(credentials, options) {
        var _a, _b, _c;
        const jdbcCredentials = credentials;
        const baseClientConfig = {
            user: jdbcCredentials.username,
            password: jdbcCredentials.password,
            database: jdbcCredentials.databaseName,
            ssl: (options === null || options === void 0 ? void 0 : options.disableSslForTestsOnly) ? false
                : {
                    rejectUnauthorized: false,
                    ca: (_a = jdbcCredentials.ssl) === null || _a === void 0 ? void 0 : _a.serverCertificate,
                    cert: (_b = jdbcCredentials.ssl) === null || _b === void 0 ? void 0 : _b.clientCertificate,
                    key: (_c = jdbcCredentials.ssl) === null || _c === void 0 ? void 0 : _c.clientPrivateKey
                }
        };
        if (jdbcCredentials.sshTunnel) {
            const sshTunnel = await SSHTunnelProxy.create(jdbcCredentials.sshTunnel, {
                host: jdbcCredentials.host,
                port: jdbcCredentials.port
            });
            const queryExecutor = new PgPoolExecutor(Object.assign(Object.assign({}, baseClientConfig), { host: "127.0.0.1", port: sshTunnel.localPort }), options);
            return new PostgresDbAdapter(queryExecutor, { sshTunnel });
        }
        else {
            const clientConfig = Object.assign(Object.assign({}, baseClientConfig), { host: jdbcCredentials.host, port: jdbcCredentials.port });
            const queryExecutor = new PgPoolExecutor(clientConfig, options);
            return new PostgresDbAdapter(queryExecutor, {});
        }
    }
    async execute(statement, options = { rowLimit: 1000, byteLimit: 1024 * 1024 }) {
        return await this.withClientLock(executor => executor.execute(statement, options));
    }
    async withClientLock(callback) {
        return await this.queryExecutor.withClientLock(client => callback({
            execute: async (statement, options = { rowLimit: 1000, byteLimit: 1024 * 1024 }) => {
                try {
                    const rows = await client.execute(statement, options);
                    return { rows, metadata: {} };
                }
                catch (e) {
                    if (options.includeQueryInError) {
                        throw new Error(`Error encountered while running "${statement}": ${e.message}`);
                    }
                    throw new ErrorWithCause(`Error executing postgres query: ${e.message}`, e);
                }
            }
        }));
    }
    async evaluate(queryOrAction, projectConfig) {
        const validationQueries = collectEvaluationQueries(queryOrAction, false, (query) => !!query ? `explain ${query}` : "").map((validationQuery, index) => ({ index, validationQuery }));
        const validationQueriesWithoutWrappers = collectEvaluationQueries(queryOrAction, false);
        const queryEvaluations = new Array();
        for (const { index, validationQuery } of validationQueries) {
            let evaluationResponse = {
                status: dataform.QueryEvaluation.QueryEvaluationStatus.SUCCESS
            };
            try {
                await this.execute(validationQuery.query);
            }
            catch (e) {
                evaluationResponse = {
                    status: dataform.QueryEvaluation.QueryEvaluationStatus.FAILURE,
                    error: parseRedshiftEvalError(validationQuery.query, e)
                };
            }
            queryEvaluations.push(dataform.QueryEvaluation.create(Object.assign(Object.assign({}, evaluationResponse), { incremental: validationQuery.incremental, query: validationQueriesWithoutWrappers[index].query })));
        }
        return queryEvaluations;
    }
    async tables() {
        const queryResult = await this.execute(`select table_name, table_schema
     from information_schema.tables
     where table_schema != 'information_schema'
       and table_schema != 'pg_catalog'
       and table_schema != 'pg_internal'`, { rowLimit: 10000, includeQueryInError: true });
        const { rows } = queryResult;
        return rows.map(row => ({
            schema: row.table_schema,
            name: row.table_name
        }));
    }
    async search(searchText, options = { limit: 1000 }) {
        const results = await this.execute(`select tables.table_schema as table_schema, tables.table_name as table_name
       from information_schema.tables as tables
       left join information_schema.columns columns on tables.table_schema = columns.table_schema and tables.table_name = columns.table_name
       where tables.table_schema ilike $1 or tables.table_name ilike $1 or columns.column_name ilike $1
       group by 1, 2`, {
            params: [`%${searchText}%`],
            rowLimit: options.limit
        });
        return await Promise.all(results.rows.map(row => this.table({
            schema: row.table_schema,
            name: row.table_name
        })));
    }
    async table(target) {
        var _a;
        const params = [target.schema, target.name];
        const [tableResults, columnResults, descriptionResults] = await Promise.all([
            this.execute(`select table_type from information_schema.tables where table_schema = $1 and table_name = $2`, { params, includeQueryInError: true }),
            this.execute(`select column_name, data_type, is_nullable, ordinal_position
         from information_schema.columns
         where table_schema = $1 and table_name = $2`, { params, includeQueryInError: true }),
            this.execute(`
      select objsubid as column_number, description from pg_description
      where objoid = (
        select oid from pg_class where relname = $2 and relnamespace = (
          select oid from pg_namespace where nspname = $1
        )
      )`, { params, includeQueryInError: true })
        ]);
        if (tableResults.rows.length === 0) {
            return null;
        }
        return dataform.TableMetadata.create({
            target,
            typeDeprecated: tableResults.rows[0].table_type === "VIEW" ? "view" : "table",
            type: tableResults.rows[0].table_type === "VIEW"
                ? dataform.TableMetadata.Type.VIEW
                : dataform.TableMetadata.Type.TABLE,
            fields: columnResults.rows.map(row => {
                var _a;
                return dataform.Field.create({
                    name: row.column_name,
                    primitive: convertFieldType$1(row.data_type),
                    flagsDeprecated: row.is_nullable && row.is_nullable === "YES" ? ["nullable"] : [],
                    description: (_a = descriptionResults.rows.find(descriptionRow => descriptionRow.column_number === row.ordinal_position)) === null || _a === void 0 ? void 0 : _a.description
                });
            }),
            description: (_a = descriptionResults.rows.find(descriptionRow => descriptionRow.column_number === 0)) === null || _a === void 0 ? void 0 : _a.description
        });
    }
    async preview(target, limitRows = 10) {
        const { rows } = await this.execute(`SELECT * FROM "${target.schema}"."${target.name}" LIMIT ${limitRows}`);
        return rows;
    }
    async schemas() {
        const schemas = await this.execute(`select nspname from pg_namespace`, {
            includeQueryInError: true
        });
        return schemas.rows.map(row => row.nspname);
    }
    async createSchema(_, schema) {
        await this.execute(`create schema if not exists "${schema}"`, { includeQueryInError: true });
    }
    async close() {
        await this.queryExecutor.close();
        if (this.options.sshTunnel) {
            await this.options.sshTunnel.close();
        }
    }
    async setMetadata(action) {
        var _a;
        const { target, actionDescriptor, tableType } = action;
        const actualMetadata = await this.table(target);
        const queries = [];
        if (actionDescriptor.description) {
            queries.push(this.execute(`comment on ${tableType === "view" ? "view" : "table"} "${target.schema}"."${target.name}" is '${actionDescriptor.description.replace(/'/g, "''")}'`));
        }
        if (((_a = actionDescriptor.columns) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            actionDescriptor.columns
                .filter(column => column.path.length === 1 &&
                actualMetadata.fields.some(field => field.name === column.path[0]))
                .forEach(column => {
                queries.push(this.execute(`comment on column "${target.schema}"."${target.name}"."${column.path[0]}" is '${column.description.replace(/'/g, "''")}'`));
            });
        }
        await Promise.all(queries);
    }
}

function resolveTarget(target) {
    return `${target.database ? `${target.database}.` : ""}${target.schema ? `${target.schema}.` : ""}${target.name}`;
}
class PrestoDbAdapter {
    constructor(credentials, options) {
        this.client = new Presto.Client(credentials);
        this.pool = new PromisePool.PromisePoolExecutor({
            concurrencyLimit: (options === null || options === void 0 ? void 0 : options.concurrencyLimit) || 10,
            frequencyWindow: 1000,
            frequencyLimit: 10
        });
    }
    static async create(credentials, options) {
        return new PrestoDbAdapter(credentials, options);
    }
    async execute(statement, options = { rowLimit: 1000, byteLimit: 1024 * 1024 }) {
        var _a;
        let isCancelled = false;
        (_a = options.onCancel) === null || _a === void 0 ? void 0 : _a.call(options, () => (isCancelled = true));
        const rows = await this.pool
            .addSingleTask({
            generator: () => new Promise((resolve, reject) => {
                const allRows = new LimitedResultSet({
                    rowLimit: options.rowLimit,
                    byteLimit: options.byteLimit
                });
                const rejectIfError = (error) => {
                    if (!!error) {
                        reject(error);
                        return true;
                    }
                };
                this.client.execute({
                    query: statement,
                    cancel: () => {
                        return isCancelled;
                    },
                    data: (error, data, columns, stats) => {
                        if (rejectIfError(error)) {
                            return;
                        }
                        if (!allRows.push(data)) {
                            isCancelled = true;
                        }
                        resolve(allRows.rows);
                    },
                    success: (error, stats) => {
                        if (rejectIfError(error)) {
                            return;
                        }
                        resolve(allRows.rows);
                    },
                    error: rejectIfError
                });
            })
        })
            .promise();
        return { rows, metadata: {} };
    }
    async withClientLock(callback) {
        return await callback(this);
    }
    async evaluate(queryOrAction, projectConfig) {
        var _a, _b;
        const validationQueries = collectEvaluationQueries(queryOrAction, true, (query) => !!query ? `explain ${query}` : "").map((validationQuery, index) => ({ index, validationQuery }));
        const validationQueriesWithoutWrappers = collectEvaluationQueries(queryOrAction, true);
        const queryEvaluations = new Array();
        for (const { index, validationQuery } of validationQueries) {
            let evaluationResponse = {
                status: dataform.QueryEvaluation.QueryEvaluationStatus.SUCCESS
            };
            try {
                await this.execute(validationQuery.query);
            }
            catch (e) {
                evaluationResponse = {
                    status: dataform.QueryEvaluation.QueryEvaluationStatus.FAILURE,
                    error: {
                        message: e.message,
                        errorLocation: {
                            line: (_a = e.errorLocation) === null || _a === void 0 ? void 0 : _a.lineNumber,
                            column: (_b = e.errorLocation) === null || _b === void 0 ? void 0 : _b.columnNumber
                        }
                    }
                };
            }
            queryEvaluations.push(dataform.QueryEvaluation.create(Object.assign(Object.assign({}, evaluationResponse), { incremental: validationQuery.incremental, query: validationQueriesWithoutWrappers[index].query })));
        }
        return queryEvaluations;
    }
    async schemas(database) {
        const result = await this.execute(`show schemas from ${database}`);
        return result.rows.flat();
    }
    async createSchema(database, schema) {
        await this.execute(`create schema if not exists ${database}.${schema}`);
    }
    async tables() {
        const databases = await this.databases();
        const targets = [];
        await Promise.all(databases.map(async (database) => await Promise.all((await this.schemas(database)).map(async (schema) => {
            const result = await this.execute(`show tables from ${database}.${schema}`);
            targets.push(...result.rows.flat().map(table => dataform.Target.create({
                database,
                schema,
                name: table
            })));
        }))));
        return targets;
    }
    async table(target) {
        let columnsResult;
        try {
            columnsResult = await this.execute(`describe ${resolveTarget(target)}`);
        }
        catch (e) {
            if (e.errorName === "TABLE_NOT_FOUND") {
                return null;
            }
            throw e;
        }
        const fields = (columnsResult === null || columnsResult === void 0 ? void 0 : columnsResult.rows.map(column => dataform.Field.create({ name: column[0], description: column[3] }))) || [];
        return dataform.TableMetadata.create({
            target,
            fields
        });
    }
    async preview(target, limitRows = 10) {
        const { rows } = await this.execute(`select * from ${resolveTarget(target)} limit ${limitRows}`);
        return rows;
    }
    async setMetadata(action) {
    }
    async close() {
    }
    async search(searchText, options) {
        return [];
    }
    async databases() {
        const result = await this.execute("show catalogs");
        return result.rows.flat();
    }
}

class RedshiftDbAdapter {
    constructor(queryExecutor, options) {
        this.queryExecutor = queryExecutor;
        this.options = options;
    }
    static async create(credentials, options) {
        const jdbcCredentials = credentials;
        const baseClientConfig = {
            user: jdbcCredentials.username,
            password: jdbcCredentials.password,
            database: jdbcCredentials.databaseName,
            ssl: (options === null || options === void 0 ? void 0 : options.disableSslForTestsOnly) ? false : { rejectUnauthorized: false }
        };
        if (jdbcCredentials.sshTunnel) {
            const sshTunnel = await SSHTunnelProxy.create(jdbcCredentials.sshTunnel, {
                host: jdbcCredentials.host,
                port: jdbcCredentials.port
            });
            const queryExecutor = new PgPoolExecutor(Object.assign(Object.assign({}, baseClientConfig), { host: "127.0.0.1", port: sshTunnel.localPort }), options);
            return new RedshiftDbAdapter(queryExecutor, { sshTunnel });
        }
        else {
            const clientConfig = Object.assign(Object.assign({}, baseClientConfig), { host: jdbcCredentials.host, port: jdbcCredentials.port });
            const queryExecutor = new PgPoolExecutor(clientConfig, options);
            return new RedshiftDbAdapter(queryExecutor, {});
        }
    }
    async execute(statement, options = { rowLimit: 1000, byteLimit: 1024 * 1024 }) {
        return await this.withClientLock(executor => executor.execute(statement, options));
    }
    async withClientLock(callback) {
        return await this.queryExecutor.withClientLock(client => callback({
            execute: async (statement, options = { rowLimit: 1000, byteLimit: 1024 * 1024 }) => {
                try {
                    const rows = await client.execute(statement, options);
                    return { rows, metadata: {} };
                }
                catch (e) {
                    if (options.includeQueryInError) {
                        throw new Error(`Error encountered while running "${statement}": ${e.message}`);
                    }
                    throw new ErrorWithCause(`Error executing redshift query: ${e.message}`, e);
                }
            }
        }));
    }
    async evaluate(queryOrAction, projectConfig) {
        const validationQueries = collectEvaluationQueries(queryOrAction, false, (query) => !!query ? `explain ${query}` : "").map((validationQuery, index) => ({ index, validationQuery }));
        const validationQueriesWithoutWrappers = collectEvaluationQueries(queryOrAction, false);
        const queryEvaluations = new Array();
        for (const { index, validationQuery } of validationQueries) {
            let evaluationResponse = {
                status: dataform.QueryEvaluation.QueryEvaluationStatus.SUCCESS
            };
            try {
                await this.execute(validationQuery.query);
            }
            catch (e) {
                evaluationResponse = {
                    status: dataform.QueryEvaluation.QueryEvaluationStatus.FAILURE,
                    error: parseRedshiftEvalError(validationQuery.query, e)
                };
            }
            queryEvaluations.push(dataform.QueryEvaluation.create(Object.assign(Object.assign({}, evaluationResponse), { incremental: validationQuery.incremental, query: validationQueriesWithoutWrappers[index].query })));
        }
        return queryEvaluations;
    }
    async tables() {
        const queryResult = await this.execute(`select table_name, table_schema
     from svv_tables
     where table_schema != 'information_schema'
       and table_schema != 'pg_catalog'
       and table_schema != 'pg_internal'`, { rowLimit: 10000, includeQueryInError: true });
        const { rows } = queryResult;
        return rows.map(row => ({
            schema: row.table_schema,
            name: row.table_name
        }));
    }
    async search(searchText, options = { limit: 1000 }) {
        const results = await this.execute(`select tables.table_schema as table_schema, tables.table_name as table_name
       from svv_tables as tables
       left join svv_columns as columns on tables.table_schema = columns.table_schema and tables.table_name = columns.table_name
       where tables.table_schema ilike $1 or tables.table_name ilike $1 or tables.remarks ilike $1
         or columns.column_name ilike $1 or columns.remarks ilike $1
       group by 1, 2`, {
            params: [`%${searchText}%`],
            rowLimit: options.limit
        });
        return await Promise.all(results.rows.map(row => this.table({
            schema: row.table_schema,
            name: row.table_name
        })));
    }
    async table(target) {
        const params = [target.schema, target.name];
        const [tableResults, columnResults] = await Promise.all([
            this.execute(`select table_type, remarks from svv_tables where table_schema = $1 and table_name = $2`, { params, includeQueryInError: true }),
            this.execute(`select column_name, data_type, is_nullable, remarks
         from svv_columns
         where table_schema = $1 and table_name = $2`, { params, includeQueryInError: true })
        ]);
        if (tableResults.rows.length === 0) {
            return null;
        }
        return dataform.TableMetadata.create({
            target,
            typeDeprecated: tableResults.rows[0].table_type === "VIEW" ? "view" : "table",
            type: tableResults.rows[0].table_type === "VIEW"
                ? dataform.TableMetadata.Type.VIEW
                : dataform.TableMetadata.Type.TABLE,
            fields: columnResults.rows.map(row => dataform.Field.create({
                name: row.column_name,
                primitive: convertFieldType$1(row.data_type),
                flagsDeprecated: row.is_nullable && row.is_nullable === "YES" ? ["nullable"] : [],
                description: row.remarks
            })),
            description: tableResults.rows[0].remarks
        });
    }
    async preview(target, limitRows = 10) {
        const { rows } = await this.execute(`SELECT * FROM "${target.schema}"."${target.name}" LIMIT ${limitRows}`);
        return rows;
    }
    async schemas() {
        const schemas = await this.execute(`select nspname from pg_namespace`, {
            includeQueryInError: true
        });
        return schemas.rows.map(row => row.nspname);
    }
    async createSchema(_, schema) {
        await this.execute(`create schema if not exists "${schema}"`, { includeQueryInError: true });
    }
    async close() {
        await this.queryExecutor.close();
        if (this.options.sshTunnel) {
            await this.options.sshTunnel.close();
        }
    }
    async setMetadata(action) {
        var _a;
        const { target, actionDescriptor, tableType } = action;
        const actualMetadata = await this.table(target);
        const queries = [];
        if (actionDescriptor.description) {
            queries.push(this.execute(`comment on ${tableType === "view" ? "view" : "table"} "${target.schema}"."${target.name}" is '${actionDescriptor.description.replace(/'/g, "\\'")}'`));
        }
        if (tableType !== "view" && ((_a = actionDescriptor.columns) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            actionDescriptor.columns
                .filter(column => column.path.length === 1 &&
                actualMetadata.fields.some(field => field.name === column.path[0]))
                .forEach(column => {
                queries.push(this.execute(`comment on column "${target.schema}"."${target.name}"."${column.path[0]}" is '${column.description.replace(/'/g, "\\'")}'`));
            });
        }
        await Promise.all(queries);
    }
}

class Flags {
    static boolean(name, defaultValue = false) {
        return new SingleValueFlag(name, defaultValue, (stringValue) => {
            if (stringValue === "" || stringValue === "true") {
                return true;
            }
            if (stringValue === "false") {
                return false;
            }
            throw Flags.invalidFlagValueError(name);
        });
    }
    static string(name, defaultValue = "") {
        return new SingleValueFlag(name, defaultValue, (stringValue) => stringValue);
    }
    static number(name, defaultValue = 0) {
        return new SingleValueFlag(name, defaultValue, (stringValue) => parseFloat(stringValue));
    }
    static long(name, defaultValue = Long.ZERO) {
        return new SingleValueFlag(name, defaultValue, Long.fromString);
    }
    static stringSet(name, defaultValue = new Set()) {
        return new SetFlag(name, defaultValue, (singleValue) => singleValue);
    }
    static getRawFlagValue(flagName) {
        return Flags.parsedArgv[flagName];
    }
    static setRawFlagValueForTesting(flagName, value) {
        Flags.parsedArgv[flagName] = value;
    }
    static invalidFlagValueError(flagName) {
        return new Error(`Invalid flag value: ${Flags.getRawFlagValue(flagName)} [${flagName}]`);
    }
}
Flags.parsedArgv = (() => {
    const parsedArgv = {};
    const splitArgv = [];
    for (let arg of process.argv) {
        if (arg.startsWith("--no-")) {
            arg = `--${arg.slice(5)}=false`;
        }
        if (arg.startsWith("--") && arg.includes("=")) {
            splitArgv.push(arg.slice(0, arg.indexOf("=")));
            splitArgv.push(arg.slice(arg.indexOf("=") + 1));
        }
        else {
            splitArgv.push(arg);
        }
    }
    let flagsStarted = false;
    let currentFlagName = "";
    for (const splitArg of splitArgv) {
        if (splitArg.startsWith("--")) {
            flagsStarted = true;
            currentFlagName = splitArg.slice(2);
            parsedArgv[currentFlagName] = "";
        }
        else if (currentFlagName) {
            parsedArgv[currentFlagName] = splitArg;
            currentFlagName = "";
        }
        else if (flagsStarted) {
            throw new Error(`Arg neither flag name nor flag value: ${splitArg}`);
        }
    }
    return parsedArgv;
})();
class AbstractFlag {
    constructor(name, defaultValue) {
        this.name = name;
        this.defaultValue = defaultValue;
        this.parsed = {};
    }
    get() {
        if (Flags.getRawFlagValue(this.name) === undefined) {
            return this.defaultValue;
        }
        const stringValue = Flags.getRawFlagValue(this.name);
        if (!(stringValue in this.parsed)) {
            this.parsed[stringValue] = this.parse(stringValue);
        }
        return this.parsed[stringValue];
    }
}
class SingleValueFlag extends AbstractFlag {
    constructor(name, defaultValue, parser) {
        super(name, defaultValue);
        this.parser = parser;
    }
    parse(stringValue) {
        return this.parser(stringValue);
    }
}
class SetFlag extends AbstractFlag {
    constructor(name, defaultValue, parser) {
        super(name, defaultValue);
        this.parser = parser;
    }
    parse(stringValue) {
        return new Set(stringValue
            .split(",")
            .filter(singleValue => singleValue.length > 0)
            .map(this.parser));
    }
}

const HEARTBEAT_INTERVAL_SECONDS = 30;
const flags = {
    snowflakeLogLevel: Flags.string("snowflake-log-level", "info"),
    snowflakeUseOcsp: Flags.boolean("snowflake-use-ocsp", true)
};
const snowflake = require("snowflake-sdk/lib/core")({
    httpClientClass: require("snowflake-sdk/lib/http/node"),
    loggerClass: require("snowflake-sdk/lib/logger/node"),
    client: {
        version: require("snowflake-sdk/lib/util").driverVersion,
        environment: Object.assign(Object.assign({}, process.versions), { APPLICATION: "Dataform" })
    }
});
snowflake.configure({
    logLevel: flags.snowflakeLogLevel.get(),
    insecureConnect: !flags.snowflakeUseOcsp.get()
});
class SnowflakeDbAdapter {
    constructor(connection, options) {
        this.connection = connection;
        this.pool = new PromisePool.PromisePoolExecutor({
            concurrencyLimit: (options === null || options === void 0 ? void 0 : options.concurrencyLimit) || 10,
            frequencyWindow: 1000,
            frequencyLimit: 10
        });
    }
    static async create(credentials, options) {
        const connection = await connect(credentials);
        return new SnowflakeDbAdapter(connection, options);
    }
    async execute(sqlText, options = { rowLimit: 1000, byteLimit: 1024 * 1024 }) {
        return {
            rows: await this.pool
                .addSingleTask({
                generator: () => new Promise((resolve, reject) => {
                    var _a;
                    const statement = this.connection.execute({
                        sqlText,
                        binds: options === null || options === void 0 ? void 0 : options.binds,
                        streamResult: true,
                        complete(err, stmt) {
                            if (err) {
                                let message = `Snowflake SQL query failed: ${err.message}.`;
                                if (err.cause) {
                                    message += ` Root cause: ${err.cause}`;
                                }
                                reject(new ErrorWithCause(message, err));
                                return;
                            }
                            const results = new LimitedResultSet({
                                rowLimit: options === null || options === void 0 ? void 0 : options.rowLimit,
                                byteLimit: options === null || options === void 0 ? void 0 : options.byteLimit
                            });
                            const stream = stmt.streamRows();
                            stream
                                .on("error", e => reject(e))
                                .on("data", row => {
                                if (!results.push(row)) {
                                    stream.destroy();
                                }
                            })
                                .on("end", () => resolve(results.rows))
                                .on("close", () => resolve(results.rows));
                        }
                    });
                    (_a = options === null || options === void 0 ? void 0 : options.onCancel) === null || _a === void 0 ? void 0 : _a.call(options, () => {
                        statement.cancel((e) => {
                            if (e) {
                                reject(e);
                            }
                        });
                    });
                })
            })
                .promise(),
            metadata: {}
        };
    }
    async withClientLock(callback) {
        return await callback(this);
    }
    async evaluate(queryOrAction, projectConfig) {
        const validationQueries = collectEvaluationQueries(queryOrAction, false, (query) => !!query ? `select system$explain_plan_json($$${query}$$)` : "").map((validationQuery, index) => ({ index, validationQuery }));
        const validationQueriesWithoutWrappers = collectEvaluationQueries(queryOrAction, false);
        const queryEvaluations = new Array();
        for (const { index, validationQuery } of validationQueries) {
            let evaluationResponse = {
                status: dataform.QueryEvaluation.QueryEvaluationStatus.SUCCESS
            };
            try {
                await this.execute(validationQuery.query);
            }
            catch (e) {
                evaluationResponse = {
                    status: dataform.QueryEvaluation.QueryEvaluationStatus.FAILURE,
                    error: parseSnowflakeEvalError(e.message)
                };
            }
            queryEvaluations.push(dataform.QueryEvaluation.create(Object.assign(Object.assign({}, evaluationResponse), { incremental: validationQuery.incremental, query: validationQueriesWithoutWrappers[index].query })));
        }
        return queryEvaluations;
    }
    async tables() {
        const { rows } = await this.execute(`
select table_name, table_schema, table_catalog
from information_schema.tables
where LOWER(table_schema) != 'information_schema'`, { rowLimit: 10000 });
        return rows.map(row => ({
            database: row.TABLE_CATALOG,
            schema: row.TABLE_SCHEMA,
            name: row.TABLE_NAME
        }));
    }
    async search(searchText, options = { limit: 1000 }) {
        const results = await this.execute(`select * from (
        select tables.table_catalog as table_catalog, tables.table_schema as table_schema, tables.table_name as table_name
        from information_schema.tables as tables
        left join information_schema.columns as columns on tables.table_catalog = columns.table_catalog and tables.table_schema = columns.table_schema
          and tables.table_name = columns.table_name
        where tables.table_catalog ilike :1 or tables.table_schema ilike :1 or tables.table_name ilike :1 or tables.comment ilike :1
          or columns.column_name ilike :1 or columns.comment ilike :1
        group by 1, 2, 3
      ) where LOWER(table_schema) != 'information_schema'
       `, {
            binds: [`%${searchText}%`],
            rowLimit: options.limit
        });
        return await Promise.all(results.rows.map(row => this.table({
            database: row.TABLE_CATALOG,
            schema: row.TABLE_SCHEMA,
            name: row.TABLE_NAME
        })));
    }
    async table(target) {
        const binds = [target.schema, target.name];
        const [tableResults, columnResults] = await Promise.all([
            this.execute(`
select table_type, last_altered, comment
from ${target.database ? `"${target.database}".` : ""}information_schema.tables
where table_schema = :1
  and table_name = :2`, { binds }),
            this.execute(`
select column_name, data_type, is_nullable, comment
from ${target.database ? `"${target.database}".` : ""}information_schema.columns
where table_schema = :1 
  and table_name = :2`, { binds })
        ]);
        if (tableResults.rows.length === 0) {
            return null;
        }
        return dataform.TableMetadata.create({
            target,
            typeDeprecated: tableResults.rows[0].TABLE_TYPE === "VIEW" ? "view" : "table",
            type: tableResults.rows[0].TABLE_TYPE === "VIEW"
                ? dataform.TableMetadata.Type.VIEW
                : dataform.TableMetadata.Type.TABLE,
            fields: columnResults.rows.map(row => dataform.Field.create({
                name: row.COLUMN_NAME,
                primitive: convertFieldType$2(row.DATA_TYPE),
                flagsDeprecated: row.IS_NULLABLE && row.IS_NULLABLE === "YES" ? ["nullable"] : [],
                flags: row.DATA_TYPE === "ARRAY" ? [dataform.Field.Flag.REPEATED] : [],
                description: row.COMMENT
            })),
            lastUpdatedMillis: Long.fromNumber(tableResults.rows[0].LAST_ALTERED),
            description: tableResults.rows[0].COMMENT
        });
    }
    async preview(target, limitRows = 10) {
        const { rows } = await this.execute(`SELECT * FROM "${target.schema}"."${target.name}" LIMIT ${limitRows}`);
        return rows;
    }
    async schemas(database) {
        const { rows } = await this.execute(`select SCHEMA_NAME from ${database ? `"${database}".` : ""}information_schema.schemata`);
        return rows.map(row => row.SCHEMA_NAME);
    }
    async createSchema(database, schema) {
        await this.execute(`create schema if not exists ${database ? `"${database}".` : ""}"${schema}"`);
    }
    async close() {
        await new Promise((resolve, reject) => {
            this.connection.destroy((err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    }
    async setMetadata(action) {
        var _a;
        const { target, actionDescriptor, tableType } = action;
        const queries = [];
        if (actionDescriptor.description) {
            queries.push(this.execute(`comment on ${tableType === "view" ? "view" : "table"} ${target.database ? `"${target.database}".` : ""}"${target.schema}"."${target.name}" is '${actionDescriptor.description.replace(/'/g, "\\'")}'`));
        }
        if (tableType !== "view" && ((_a = actionDescriptor.columns) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            actionDescriptor.columns
                .filter(column => column.path.length === 1)
                .forEach(column => {
                queries.push(this.execute(`comment if exists on column ${target.database ? `"${target.database}".` : ""}"${target.schema}"."${target.name}"."${column.path[0]}" is '${column.description.replace(/'/g, "\\'")}'`));
            });
        }
        await Promise.all(queries);
    }
}
async function connect(snowflakeCredentials) {
    await testHttpsConnection(`https://${snowflakeCredentials.accountId}.snowflakecomputing.com`);
    try {
        return await new Promise((resolve, reject) => {
            snowflake
                .createConnection({
                account: snowflakeCredentials.accountId,
                username: snowflakeCredentials.username,
                password: snowflakeCredentials.password,
                database: snowflakeCredentials.databaseName,
                warehouse: snowflakeCredentials.warehouse,
                role: snowflakeCredentials.role,
                clientSessionKeepAlive: true,
                clientSessionKeepAliveHeartbeatFrequency: HEARTBEAT_INTERVAL_SECONDS
            })
                .connect((err, conn) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(conn);
                }
            });
        });
    }
    catch (e) {
        throw new ErrorWithCause(`Could not connect to Snowflake: ${e.message}`, e);
    }
}
async function testHttpsConnection(url) {
    try {
        await new Promise((resolve, reject) => {
            const req = https.request(url);
            req.on("error", e => {
                reject(e);
            });
            req.end(() => {
                resolve();
            });
        });
    }
    catch (e) {
        throw new ErrorWithCause(`Could not open HTTPS connection to ${url}.`, e);
    }
}
function convertFieldType$2(type) {
    switch (String(type).toUpperCase()) {
        case "FLOAT":
        case "FLOAT4":
        case "FLOAT8":
        case "DOUBLE":
        case "DOUBLE PRECISION":
        case "REAL":
            return dataform.Field.Primitive.FLOAT;
        case "INTEGER":
        case "INT":
        case "BIGINT":
        case "SMALLINT":
            return dataform.Field.Primitive.INTEGER;
        case "NUMBER":
        case "DECIMAL":
        case "NUMERIC":
            return dataform.Field.Primitive.NUMERIC;
        case "BOOLEAN":
            return dataform.Field.Primitive.BOOLEAN;
        case "STRING":
        case "VARCHAR":
        case "CHAR":
        case "CHARACTER":
        case "TEXT":
            return dataform.Field.Primitive.STRING;
        case "DATE":
            return dataform.Field.Primitive.DATE;
        case "DATETIME":
            return dataform.Field.Primitive.DATETIME;
        case "TIMESTAMP":
        case "TIMESTAMP_LTZ":
        case "TIMESTAMP_NTZ":
        case "TIMESTAMP_TZ":
            return dataform.Field.Primitive.TIMESTAMP;
        case "TIME":
            return dataform.Field.Primitive.TIME;
        case "BINARY":
        case "VARBINARY":
            return dataform.Field.Primitive.BYTES;
        case "VARIANT":
        case "ARRAY":
        case "OBJECT":
            return dataform.Field.Primitive.ANY;
        case "GEOGRAPHY":
            return dataform.Field.Primitive.GEOGRAPHY;
        default:
            return dataform.Field.Primitive.UNKNOWN;
    }
}

const DB_CONNECTION_TIMEOUT_MILLIS = 5 * 60 * 1000;
const DB_REQUEST_TIMEOUT_MILLIS = 1 * 60 * 60 * 1000;
const DB_CON_LIMIT = 10;
class SQLDataWarehouseDBAdapter {
    constructor(credentials, options) {
        const sqlDataWarehouseCredentials = credentials;
        this.pool = new Promise((resolve, reject) => {
            const conn = new mssql.ConnectionPool({
                server: sqlDataWarehouseCredentials.server,
                port: sqlDataWarehouseCredentials.port,
                user: sqlDataWarehouseCredentials.username,
                password: sqlDataWarehouseCredentials.password,
                database: sqlDataWarehouseCredentials.database,
                connectionTimeout: DB_CONNECTION_TIMEOUT_MILLIS,
                requestTimeout: DB_REQUEST_TIMEOUT_MILLIS,
                pool: {
                    min: 0,
                    max: (options === null || options === void 0 ? void 0 : options.concurrencyLimit) || DB_CON_LIMIT
                },
                options: {
                    encrypt: true
                }
            }).connect();
            conn
                .then(pool => {
                pool.on("error", err => {
                    throw new Error(err);
                });
                resolve(conn);
            })
                .catch(e => reject(e));
        });
    }
    static async create(credentials, options) {
        return new SQLDataWarehouseDBAdapter(credentials, options);
    }
    async execute(statement, options = { rowLimit: 1000, byteLimit: 1024 * 1024 }) {
        var _a;
        const request = (await this.pool).request();
        (_a = options === null || options === void 0 ? void 0 : options.onCancel) === null || _a === void 0 ? void 0 : _a.call(options, () => request.cancel());
        return await new Promise((resolve, reject) => {
            request.stream = true;
            const results = new LimitedResultSet({
                rowLimit: options === null || options === void 0 ? void 0 : options.rowLimit,
                byteLimit: options === null || options === void 0 ? void 0 : options.byteLimit
            });
            request
                .on("row", row => {
                if (!results.push(row)) {
                    request.cancel();
                    resolve({ rows: results.rows, metadata: {} });
                }
            })
                .on("error", err => reject(err))
                .on("done", () => resolve({ rows: results.rows, metadata: {} }));
            for (const [name, value] of Object.entries((options === null || options === void 0 ? void 0 : options.params) || {})) {
                request.input(name, value);
            }
            request.query(statement);
        });
    }
    async withClientLock(callback) {
        return await callback(this);
    }
    async evaluate(queryOrAction, projectConfig) {
        const validationQueries = collectEvaluationQueries(queryOrAction, true, (query) => !!query ? `explain ${query}` : "").map((validationQuery, index) => ({ index, validationQuery }));
        const validationQueriesWithoutWrappers = collectEvaluationQueries(queryOrAction, false);
        const queryEvaluations = new Array();
        for (const { index, validationQuery } of validationQueries) {
            let evaluationResponse = {
                status: dataform.QueryEvaluation.QueryEvaluationStatus.SUCCESS
            };
            try {
                await this.execute(validationQuery.query);
            }
            catch (e) {
                evaluationResponse = {
                    status: dataform.QueryEvaluation.QueryEvaluationStatus.FAILURE,
                    error: parseAzureEvaluationError(e)
                };
            }
            queryEvaluations.push(dataform.QueryEvaluation.create(Object.assign(Object.assign({}, evaluationResponse), { incremental: validationQuery.incremental, query: validationQueriesWithoutWrappers[index].query })));
        }
        return queryEvaluations;
    }
    async tables() {
        const { rows } = await this.execute(`select table_schema, table_name from information_schema.tables`, {
            rowLimit: 10000
        });
        return rows.map(row => ({
            schema: row.table_schema,
            name: row.table_name
        }));
    }
    async search(searchText, options = { limit: 1000 }) {
        const results = await this.execute(`select tables.table_schema as table_schema, tables.table_name as table_name
       from information_schema.tables as tables
       left join information_schema.columns as columns on tables.table_schema = columns.table_schema and tables.table_name = columns.table_name
       where tables.table_schema like @searchText or tables.table_name like @searchText or columns.column_name like @searchText
       group by tables.table_schema, tables.table_name`, {
            params: {
                searchText: `%${searchText}%`
            },
            rowLimit: options.limit
        });
        return await Promise.all(results.rows.map(row => this.table({
            schema: row.table_schema,
            name: row.table_name
        })));
    }
    async table(target) {
        const queryParams = {
            schema: target.schema,
            name: target.name
        };
        const [tableData, columnData] = await Promise.all([
            this.execute(`select table_type from information_schema.tables
         where table_schema = @schema AND table_name = @name`, {
                params: queryParams
            }),
            this.execute(`select column_name, data_type, is_nullable
         from information_schema.columns
         where table_schema = @schema AND table_name = @name`, {
                params: queryParams
            })
        ]);
        if (tableData.rows.length === 0) {
            return null;
        }
        return {
            target,
            typeDeprecated: tableData.rows[0].table_type === "VIEW" ? "view" : "table",
            type: tableData.rows[0].table_type === "VIEW"
                ? dataform.TableMetadata.Type.VIEW
                : dataform.TableMetadata.Type.TABLE,
            fields: columnData.rows.map(row => ({
                name: row.column_name,
                primitive: convertFieldType$3(row.data_type),
                flagsDeprecated: row.is_nullable && row.is_nullable === "YES" ? ["nullable"] : []
            }))
        };
    }
    async preview(target, limitRows = 10) {
        const { rows } = await this.execute(`SELECT TOP ${limitRows} * FROM "${target.schema}"."${target.name}"`);
        return rows;
    }
    async schemas() {
        const schemas = await this.execute(`select schema_name from information_schema.schemata`);
        return schemas.rows.map(row => row.schema_name);
    }
    async createSchema(_, schema) {
        await this.execute(`if not exists ( select schema_name from information_schema.schemata where schema_name = '${schema}' )
            begin
              exec sp_executesql N'create schema ${schema}'
            end `);
    }
    async close() {
        await (await this.pool).close();
    }
    async setMetadata() {
    }
}
function convertFieldType$3(type) {
    switch (String(type).toUpperCase()) {
        case "FLOAT":
        case "REAL":
            return dataform.Field.Primitive.FLOAT;
        case "INT":
        case "BIGINT":
        case "SMALLINT":
        case "TINYINT":
            return dataform.Field.Primitive.INTEGER;
        case "DECIMAL":
        case "NUMERIC":
            return dataform.Field.Primitive.NUMERIC;
        case "BIT":
            return dataform.Field.Primitive.BOOLEAN;
        case "VARCHAR":
        case "CHAR":
        case "TEXT":
        case "NVARCHAR":
        case "NCHAR":
        case "NTEXT":
            return dataform.Field.Primitive.STRING;
        case "DATE":
            return dataform.Field.Primitive.DATE;
        case "DATETIME":
        case "DATETIME2":
        case "DATETIMEOFFSET":
        case "SMALLDATETIME":
            return dataform.Field.Primitive.DATETIME;
        case "TIME":
            return dataform.Field.Primitive.TIME;
        case "BINARY":
        case "VARBINARY":
        case "IMAGE":
            return dataform.Field.Primitive.BYTES;
        default:
            return dataform.Field.Primitive.UNKNOWN;
    }
}

const registry$1 = {};
function register$1(warehouseType, c) {
    registry$1[warehouseType] = c;
}
const validWarehouses = [
    "bigquery",
    "postgres",
    "redshift",
    "sqldatawarehouse",
    "snowflake",
    "presto"
];
async function create$1(credentials, warehouseType, options) {
    if (!registry$1[warehouseType]) {
        throw new Error(`Unsupported warehouse: ${warehouseType}`);
    }
    return await registry$1[warehouseType].create(credentials, options);
}
register$1("bigquery", BigQueryDbAdapter);
register$1("postgres", PostgresDbAdapter);
register$1("redshift", RedshiftDbAdapter);
register$1("snowflake", SnowflakeDbAdapter);
register$1("sqldatawarehouse", SQLDataWarehouseDBAdapter);
register$1("presto", PrestoDbAdapter);

const mandatoryProps = ["warehouse", "defaultSchema"];
const simpleCheckProps = [
    "assertionSchema",
    "databaseSuffix",
    "schemaSuffix",
    "tablePrefix",
    "defaultSchema"
];
class CompilationTimeoutError extends Error {
}
async function compile(compileConfig = {}) {
    var _a;
    path.resolve(compileConfig.projectDir);
    compileConfig = Object.assign({ projectConfigOverride: {} }, compileConfig);
    if (compileConfig.schemaSuffixOverride) {
        compileConfig.projectConfigOverride = Object.assign({ schemaSuffix: compileConfig.schemaSuffixOverride }, compileConfig.projectConfigOverride);
    }
    try {
        const dataformJson = fs.readFileSync(`${compileConfig.projectDir}/dataform.json`, "utf8");
        const projectConfig = JSON.parse(dataformJson);
        checkDataformJsonValidity(Object.assign(Object.assign(Object.assign({}, projectConfig), compileConfig.projectConfigOverride), { vars: Object.assign(Object.assign({}, projectConfig.vars), (_a = compileConfig.projectConfigOverride) === null || _a === void 0 ? void 0 : _a.vars) }));
    }
    catch (e) {
        throw new ErrorWithCause(`Compilation failed. ProjectConfig ('dataform.json') is invalid: ${e.message}`, e);
    }
    return decode(dataform.CompiledGraph, await CompileChildProcess.forkProcess().compile(compileConfig));
}
class CompileChildProcess {
    constructor(childProcess) {
        this.childProcess = childProcess;
    }
    static forkProcess() {
        let workerBundle;
        try {
            workerBundle = require.resolve("./worker_bundle");
        }
        catch (e) {
            workerBundle = require.resolve("df/sandbox/vm/worker_bundle");
        }
        return new CompileChildProcess(childProcess.fork(workerBundle, [], {
            stdio: [0, 1, 2, "ipc", "pipe"]
        }));
    }
    async compile(compileConfig) {
        const compileInChildProcess = new Promise(async (resolve, reject) => {
            this.childProcess.on("error", (e) => reject(coerceAsError(e)));
            this.childProcess.on("message", (messageOrError) => {
                if (typeof messageOrError === "string") {
                    resolve(messageOrError);
                    return;
                }
                reject(coerceAsError(messageOrError));
            });
            this.childProcess.on("close", exitCode => {
                if (exitCode !== 0) {
                    reject(new Error(`Compilation child process exited with exit code ${exitCode}.`));
                }
            });
            this.childProcess.send(compileConfig);
        });
        let timer;
        const timeout = new Promise((resolve, reject) => (timer = setTimeout(() => reject(new CompilationTimeoutError("Compilation timed out")), compileConfig.timeoutMillis || 5000)));
        try {
            await Promise.race([timeout, compileInChildProcess]);
            return await compileInChildProcess;
        }
        finally {
            if (!this.childProcess.killed) {
                this.childProcess.kill("SIGKILL");
            }
            if (timer) {
                clearTimeout(timer);
            }
        }
    }
}
const checkDataformJsonValidity = (dataformJsonParsed) => {
    const invalidWarehouseProp = () => {
        return dataformJsonParsed.warehouse && !validWarehouses.includes(dataformJsonParsed.warehouse)
            ? `Invalid value on property warehouse: ${dataformJsonParsed.warehouse}. Should be one of: ${validWarehouses.join(", ")}.`
            : null;
    };
    const invalidProp = () => {
        const invProp = simpleCheckProps.find(prop => {
            return prop in dataformJsonParsed && !/^[a-zA-Z_0-9\-]*$/.test(dataformJsonParsed[prop]);
        });
        return invProp
            ? `Invalid value on property ${invProp}: ${dataformJsonParsed[invProp]}. Should only contain alphanumeric characters, underscores and/or hyphens.`
            : null;
    };
    const missingMandatoryProp = () => {
        const missMandatoryProp = mandatoryProps.find(prop => {
            return !(prop in dataformJsonParsed);
        });
        return missMandatoryProp ? `Missing mandatory property: ${missMandatoryProp}.` : null;
    };
    const message = invalidWarehouseProp() || invalidProp() || missingMandatoryProp();
    if (message) {
        throw new Error(message);
    }
};

const CREDENTIALS_FILENAME = ".df-credentials.json";
function read(warehouse, credentialsPath) {
    if (!fs.existsSync(credentialsPath)) {
        throw new Error("Missing credentials JSON file.");
    }
    return coerce(warehouse, JSON.parse(fs.readFileSync(credentialsPath, "utf8")));
}
function coerce(warehouse, credentials) {
    switch (warehouse) {
        case WarehouseType.BIGQUERY: {
            return validateAnyAsCredentials(credentials, dataform.BigQuery.verify, dataform.BigQuery.create, requiredWarehouseProps[warehouse]);
        }
        case WarehouseType.POSTGRES:
        case WarehouseType.REDSHIFT: {
            return validateAnyAsCredentials(credentials, dataform.JDBC.verify, dataform.JDBC.create, requiredWarehouseProps[warehouse]);
        }
        case WarehouseType.PRESTO: {
            return validateAnyAsCredentials(credentials, dataform.Presto.verify, dataform.Presto.create, requiredWarehouseProps[warehouse]);
        }
        case WarehouseType.SNOWFLAKE: {
            return validateAnyAsCredentials(credentials, dataform.Snowflake.verify, dataform.Snowflake.create, requiredWarehouseProps[warehouse]);
        }
        case WarehouseType.SQLDATAWAREHOUSE: {
            return validateAnyAsCredentials(credentials, dataform.SQLDataWarehouse.verify, dataform.SQLDataWarehouse.create, requiredWarehouseProps[warehouse]);
        }
        default:
            throw new Error(`Unrecognized warehouse: ${warehouse}`);
    }
}
var TestResultStatus;
(function (TestResultStatus) {
    TestResultStatus[TestResultStatus["SUCCESSFUL"] = 0] = "SUCCESSFUL";
    TestResultStatus[TestResultStatus["TIMED_OUT"] = 1] = "TIMED_OUT";
    TestResultStatus[TestResultStatus["OTHER_ERROR"] = 2] = "OTHER_ERROR";
})(TestResultStatus || (TestResultStatus = {}));
async function test(dbadapter, timeoutMs = 10000) {
    let timer;
    try {
        const timeout = new Promise(resolve => (timer = setTimeout(() => resolve(TestResultStatus.TIMED_OUT), timeoutMs)));
        const executeQuery = dbadapter.execute("SELECT 1 AS x").then(() => TestResultStatus.SUCCESSFUL);
        return {
            status: await Promise.race([executeQuery, timeout])
        };
    }
    catch (e) {
        return {
            status: TestResultStatus.OTHER_ERROR,
            error: e
        };
    }
    finally {
        if (timer) {
            clearTimeout(timer);
        }
    }
}
function validateAnyAsCredentials(credentials, verify, create, requiredProps) {
    const errMsg = verify(credentials);
    if (errMsg) {
        throw new Error(`Credentials JSON object does not conform to protobuf requirements: ${errMsg}`);
    }
    const protobuf = create(credentials);
    const missingProps = requiredProps.filter(key => Object.keys(protobuf).indexOf(key) === -1);
    if (missingProps.length > 0) {
        throw new Error(`Missing required properties: ${missingProps.join(", ")}`);
    }
    return protobuf;
}

async function install(projectDir, skipInstall) {
    if (skipInstall) {
        return;
    }
    await util.promisify(childProcess.exec)("npm i --ignore-scripts", { cwd: path.resolve(projectDir) });
}

function prettyJsonStringify(obj) {
    return JSON.stringify(obj, null, 4) + "\n";
}

const gitIgnoreContents = `
${CREDENTIALS_FILENAME}
node_modules/
`;
async function init(projectDir, projectConfig, options = {}) {
    const dataformJsonPath = path.join(projectDir, "dataform.json");
    const packageJsonPath = path.join(projectDir, "package.json");
    const gitignorePath = path.join(projectDir, ".gitignore");
    const schedulesJsonPath = path.join(projectDir, "schedules.json");
    const environmentsJsonPath = path.join(projectDir, "environments.json");
    if (fs.existsSync(dataformJsonPath) || fs.existsSync(packageJsonPath)) {
        throw new Error("Cannot init dataform project, this already appears to be an NPM or Dataform directory.");
    }
    const filesWritten = [];
    const dirsCreated = [];
    if (!fs.existsSync(projectDir)) {
        fs.mkdirSync(projectDir);
        dirsCreated.push(projectDir);
    }
    fs.writeFileSync(dataformJsonPath, prettyJsonStringify(dataform.ProjectConfig.create(Object.assign({ defaultSchema: "dataform", assertionSchema: "dataform_assertions" }, projectConfig))));
    filesWritten.push(dataformJsonPath);
    fs.writeFileSync(packageJsonPath, prettyJsonStringify({
        dependencies: {
            "@dataform/core": version
        }
    }));
    filesWritten.push(packageJsonPath);
    fs.writeFileSync(gitignorePath, gitIgnoreContents);
    filesWritten.push(gitignorePath);
    if (options.includeSchedules) {
        fs.writeFileSync(schedulesJsonPath, prettyJsonStringify(dataform.schedules.SchedulesJSON.create({})));
        filesWritten.push(schedulesJsonPath);
    }
    if (options.includeEnvironments) {
        fs.writeFileSync(environmentsJsonPath, prettyJsonStringify(dataform.Environments.create({})));
    }
    const definitionsDir = path.join(projectDir, "definitions");
    fs.mkdirSync(definitionsDir);
    dirsCreated.push(definitionsDir);
    const includesDir = path.join(projectDir, "includes");
    fs.mkdirSync(includesDir);
    dirsCreated.push(includesDir);
    await install(projectDir, options.skipInstall);
    return {
        filesWritten,
        dirsCreated,
        installedNpmPackages: !options.skipInstall
    };
}

const CANCEL_EVENT = "jobCancel";
const flags$1 = {
    runnerNotificationPeriodMillis: Flags.number("runner-notification-period-millis", 5000)
};
const isSuccessfulAction = (actionResult) => actionResult.status === dataform.ActionResult.ExecutionStatus.SUCCESSFUL ||
    actionResult.status === dataform.ActionResult.ExecutionStatus.CACHE_SKIPPED ||
    actionResult.status === dataform.ActionResult.ExecutionStatus.DISABLED;
function run(dbadapter, graph, partiallyExecutedRunResult = {}, previouslyExecutedActions = []) {
    return new Runner(dbadapter, graph, partiallyExecutedRunResult, previouslyExecutedActions).execute();
}
class Runner {
    constructor(dbadapter, graph, partiallyExecutedRunResult = {}, previouslyExecutedActions = []) {
        var _a;
        this.dbadapter = dbadapter;
        this.graph = graph;
        this.changeListeners = [];
        this.lastNotificationTimestampMillis = 0;
        this.stopped = false;
        this.cancelled = false;
        this.timedOut = false;
        this.allActionNames = new Set(graph.actions.map(action => action.name));
        this.runResult = Object.assign({ actions: [] }, partiallyExecutedRunResult);
        this.warehouseStateByTarget = new StringifiedMap(JSONObjectStringifier.create(), (_a = graph.warehouseState.tables) === null || _a === void 0 ? void 0 : _a.map(tableMetadata => [tableMetadata.target, tableMetadata]));
        this.nonTableDeclarationTargets = new StringifiedSet(JSONObjectStringifier.create(), graph.declarationTargets.filter(declarationTarget => {
            var _a;
            return ((_a = this.warehouseStateByTarget.get(declarationTarget)) === null || _a === void 0 ? void 0 : _a.type) !==
                dataform.TableMetadata.Type.TABLE;
        }));
        this.previouslyExecutedActions = new StringifiedMap(JSONObjectStringifier.create(), previouslyExecutedActions.map(executedAction => [
            executedAction.executionAction.target,
            executedAction
        ]));
        this.executedActionNames = new Set(this.runResult.actions
            .filter(action => action.status !== dataform.ActionResult.ExecutionStatus.RUNNING)
            .map(action => action.name));
        this.successfullyExecutedActionNames = new Set(this.runResult.actions.filter(isSuccessfulAction).map(action => action.name));
        this.pendingActions = graph.actions.filter(action => !this.executedActionNames.has(action.name));
        this.eEmitter = new EventEmitter__default();
        this.eEmitter.setMaxListeners(0);
    }
    onChange(listener) {
        this.changeListeners.push(listener);
        return this;
    }
    execute() {
        var _a, _b, _c;
        if (!!this.executionTask) {
            throw new Error("Executor already started.");
        }
        this.executionTask = this.executeGraph();
        if (!!this.graph.runConfig && !!this.graph.runConfig.timeoutMillis) {
            const now = Date.now();
            const runStartMillis = ((_c = (_b = (_a = this.runResult.timing) === null || _a === void 0 ? void 0 : _a.startTimeMillis) === null || _b === void 0 ? void 0 : _b.toNumber) === null || _c === void 0 ? void 0 : _c.call(_b)) || now;
            const elapsedTimeMillis = now - runStartMillis;
            const timeoutMillis = this.graph.runConfig.timeoutMillis - elapsedTimeMillis;
            this.timeout = setTimeout(() => {
                this.timedOut = true;
                this.cancel();
            }, timeoutMillis);
        }
        return this;
    }
    stop() {
        this.stopped = true;
    }
    cancel() {
        this.cancelled = true;
        this.eEmitter.emit(CANCEL_EVENT);
    }
    async result() {
        try {
            return await this.executionTask;
        }
        finally {
            if (!!this.timeout) {
                clearTimeout(this.timeout);
            }
        }
    }
    notifyListeners() {
        if (Date.now() - flags$1.runnerNotificationPeriodMillis.get() <
            this.lastNotificationTimestampMillis) {
            return;
        }
        const runResultClone = deepClone(dataform.RunResult, this.runResult);
        this.lastNotificationTimestampMillis = Date.now();
        this.changeListeners.forEach(listener => listener(runResultClone));
    }
    async executeGraph() {
        const timer = Timer.start(this.runResult.timing);
        this.runResult.status = dataform.RunResult.ExecutionStatus.RUNNING;
        this.runResult.timing = timer.current();
        this.notifyListeners();
        if (this.runResult.actions.length === 0) {
            await this.prepareAllSchemas();
        }
        await this.executeAllActionsReadyForExecution();
        if (this.stopped) {
            return this.runResult;
        }
        this.runResult.timing = timer.end();
        this.runResult.status = dataform.RunResult.ExecutionStatus.SUCCESSFUL;
        if (this.timedOut) {
            this.runResult.status = dataform.RunResult.ExecutionStatus.TIMED_OUT;
        }
        else if (this.cancelled) {
            this.runResult.status = dataform.RunResult.ExecutionStatus.CANCELLED;
        }
        else if (this.runResult.actions.some(action => action.status === dataform.ActionResult.ExecutionStatus.FAILED)) {
            this.runResult.status = dataform.RunResult.ExecutionStatus.FAILED;
        }
        return this.runResult;
    }
    async prepareAllSchemas() {
        const databaseSchemas = new Map();
        this.graph.actions
            .filter(action => !!action.target && !!action.target.schema)
            .forEach(({ target }) => {
            const trueDatabase = target.database || this.graph.projectConfig.defaultDatabase;
            if (!databaseSchemas.has(trueDatabase)) {
                databaseSchemas.set(trueDatabase, new Set());
            }
            databaseSchemas.get(trueDatabase).add(target.schema);
        });
        await Promise.all(Array.from(databaseSchemas.entries()).map(async ([database, schemas]) => {
            const existingSchemas = new Set(await this.dbadapter.schemas(database));
            await Promise.all(Array.from(schemas)
                .filter(schema => !existingSchemas.has(schema))
                .map(schema => this.dbadapter.createSchema(database, schema)));
        }));
    }
    async executeAllActionsReadyForExecution() {
        if (this.stopped) {
            return;
        }
        if (this.cancelled) {
            const allPendingActions = this.pendingActions;
            this.pendingActions = [];
            allPendingActions.forEach(pendingAction => this.runResult.actions.push({
                name: pendingAction.name,
                target: pendingAction.target,
                status: dataform.ActionResult.ExecutionStatus.SKIPPED,
                tasks: pendingAction.tasks.map(() => ({
                    status: dataform.TaskResult.ExecutionStatus.SKIPPED
                }))
            }));
            this.notifyListeners();
            return;
        }
        const executableActions = [];
        const skippableActions = [];
        const stillPendingActions = [];
        for (const pendingAction of this.pendingActions) {
            if (pendingAction.dependencies.every(dependency => !this.allActionNames.has(dependency) ||
                this.successfullyExecutedActionNames.has(dependency))) {
                executableActions.push(pendingAction);
            }
            else if (pendingAction.dependencies.every(dependency => !this.allActionNames.has(dependency) || this.executedActionNames.has(dependency))) {
                skippableActions.push(pendingAction);
            }
            else {
                stillPendingActions.push(pendingAction);
            }
        }
        this.pendingActions = stillPendingActions;
        await Promise.all([
            (async () => {
                skippableActions.forEach(skippableAction => {
                    this.runResult.actions.push({
                        name: skippableAction.name,
                        target: skippableAction.target,
                        status: dataform.ActionResult.ExecutionStatus.SKIPPED,
                        tasks: skippableAction.tasks.map(() => ({
                            status: dataform.TaskResult.ExecutionStatus.SKIPPED
                        }))
                    });
                });
                if (skippableActions.length > 0) {
                    this.notifyListeners();
                    await this.executeAllActionsReadyForExecution();
                }
            })(),
            Promise.all(executableActions.map(async (executableAction) => {
                const actionResult = await this.executeAction(executableAction);
                this.executedActionNames.add(executableAction.name);
                if (isSuccessfulAction(actionResult)) {
                    this.successfullyExecutedActionNames.add(executableAction.name);
                }
                await this.executeAllActionsReadyForExecution();
            }))
        ]);
    }
    async executeAction(action) {
        let actionResult = {
            name: action.name,
            target: action.target,
            tasks: [],
            inputs: action.transitiveInputs.map(target => ({
                target,
                metadata: this.warehouseStateByTarget.has(target)
                    ? {
                        lastModifiedTimestampMillis: this.warehouseStateByTarget.get(target).lastUpdatedMillis
                    }
                    : null
            }))
        };
        if (action.tasks.length === 0) {
            actionResult.status = dataform.ActionResult.ExecutionStatus.DISABLED;
            this.runResult.actions.push(actionResult);
            this.notifyListeners();
            return actionResult;
        }
        if (this.shouldCacheSkip(action)) {
            actionResult.status = dataform.ActionResult.ExecutionStatus.CACHE_SKIPPED;
            this.runResult.actions.push(actionResult);
            this.notifyListeners();
            return actionResult;
        }
        const resumedActionResult = this.runResult.actions.find(existingActionResult => existingActionResult.name === action.name);
        if (resumedActionResult) {
            actionResult = resumedActionResult;
        }
        else {
            this.runResult.actions.push(actionResult);
        }
        actionResult.status = dataform.ActionResult.ExecutionStatus.RUNNING;
        const timer = Timer.start(resumedActionResult === null || resumedActionResult === void 0 ? void 0 : resumedActionResult.timing);
        actionResult.timing = timer.current();
        this.notifyListeners();
        await this.dbadapter.withClientLock(async (client) => {
            var _a;
            for (const task of action.tasks.slice(actionResult.tasks.length)) {
                if (this.stopped) {
                    return actionResult;
                }
                if (actionResult.status === dataform.ActionResult.ExecutionStatus.RUNNING &&
                    !this.cancelled) {
                    const taskStatus = await this.executeTask(client, task, actionResult, {
                        bigquery: { labels: (_a = action.actionDescriptor) === null || _a === void 0 ? void 0 : _a.bigqueryLabels }
                    });
                    if (taskStatus === dataform.TaskResult.ExecutionStatus.FAILED) {
                        actionResult.status = dataform.ActionResult.ExecutionStatus.FAILED;
                    }
                    else if (taskStatus === dataform.TaskResult.ExecutionStatus.CANCELLED) {
                        actionResult.status = dataform.ActionResult.ExecutionStatus.CANCELLED;
                    }
                }
                else {
                    actionResult.tasks.push({
                        status: dataform.TaskResult.ExecutionStatus.SKIPPED
                    });
                }
            }
        });
        if (this.stopped) {
            return actionResult;
        }
        if (action.actionDescriptor &&
            actionResult.status === dataform.ActionResult.ExecutionStatus.RUNNING &&
            !(this.graph.runConfig && this.graph.runConfig.disableSetMetadata) &&
            action.type === "table" &&
            action.tableType !== "inline") {
            await this.dbadapter.setMetadata(action);
        }
        let newMetadata;
        if (this.graph.projectConfig.useRunCache) {
            try {
                newMetadata = await this.dbadapter.table(action.target);
            }
            catch (e) {
            }
        }
        if (newMetadata) {
            this.warehouseStateByTarget.set(action.target, newMetadata);
            actionResult.postExecutionTimestampMillis = newMetadata.lastUpdatedMillis;
            this.notifyListeners();
        }
        else {
            this.warehouseStateByTarget.delete(action.target);
        }
        if (actionResult.status === dataform.ActionResult.ExecutionStatus.RUNNING) {
            actionResult.status = dataform.ActionResult.ExecutionStatus.SUCCESSFUL;
        }
        actionResult.timing = timer.end();
        this.notifyListeners();
        return actionResult;
    }
    async executeTask(client, task, parentAction, options) {
        const timer = Timer.start();
        const taskResult = {
            status: dataform.TaskResult.ExecutionStatus.RUNNING,
            timing: timer.current(),
            metadata: {}
        };
        parentAction.tasks.push(taskResult);
        this.notifyListeners();
        try {
            const { rows, metadata } = await retry(() => client.execute(task.statement, {
                onCancel: handleCancel => this.eEmitter.on(CANCEL_EVENT, handleCancel),
                rowLimit: 1,
                bigquery: options.bigquery
            }), task.type === "operation" ? 1 : this.graph.projectConfig.idempotentActionRetries + 1 || 1);
            taskResult.metadata = metadata;
            if (task.type === "assertion") {
                const rowCount = rows[0][Object.keys(rows[0])[0]];
                if (rowCount > 0) {
                    throw new Error(`Assertion failed: query returned ${rowCount} row(s).`);
                }
            }
            taskResult.status = dataform.TaskResult.ExecutionStatus.SUCCESSFUL;
        }
        catch (e) {
            taskResult.status = this.cancelled
                ? dataform.TaskResult.ExecutionStatus.CANCELLED
                : dataform.TaskResult.ExecutionStatus.FAILED;
            taskResult.errorMessage = `${this.graph.projectConfig.warehouse} error: ${e.message}`;
        }
        taskResult.timing = timer.end();
        this.notifyListeners();
        return taskResult.status;
    }
    shouldCacheSkip(executionAction) {
        var _a, _b;
        if (!((_a = this.graph.runConfig) === null || _a === void 0 ? void 0 : _a.useRunCache)) {
            return false;
        }
        if (executionAction.hermeticity === dataform.ActionHermeticity.NON_HERMETIC) {
            return false;
        }
        if (!this.previouslyExecutedActions.has(executionAction.target)) {
            return false;
        }
        const previouslyExecutedAction = this.previouslyExecutedActions.get(executionAction.target);
        if (previouslyExecutedAction.actionResult.status !==
            dataform.ActionResult.ExecutionStatus.SUCCESSFUL) {
            return false;
        }
        if (!equals(dataform.ExecutionAction, previouslyExecutedAction.executionAction, executionAction)) {
            return false;
        }
        if (!this.warehouseStateByTarget.has(executionAction.target)) {
            return false;
        }
        if (this.warehouseStateByTarget.get(executionAction.target).lastUpdatedMillis.equals(0) ||
            previouslyExecutedAction.actionResult.postExecutionTimestampMillis.equals(0) ||
            this.warehouseStateByTarget
                .get(executionAction.target)
                .lastUpdatedMillis.notEquals(previouslyExecutedAction.actionResult.postExecutionTimestampMillis)) {
            return false;
        }
        const previousInputTimestamps = new StringifiedMap(JSONObjectStringifier.create(), previouslyExecutedAction.actionResult.inputs
            .filter(input => !!input.metadata)
            .map(input => [input.target, input.metadata.lastModifiedTimestampMillis]));
        for (const transitiveInput of executionAction.transitiveInputs) {
            if (this.nonTableDeclarationTargets.has(transitiveInput)) {
                return false;
            }
            if (!previousInputTimestamps.has(transitiveInput)) {
                return false;
            }
            if (!this.warehouseStateByTarget.has(transitiveInput)) {
                return false;
            }
            const inputWarehouseState = this.warehouseStateByTarget.get(transitiveInput);
            if (this.warehouseStateByTarget.get(transitiveInput).lastUpdatedMillis.equals(0) ||
                previousInputTimestamps.get(transitiveInput).equals(0) ||
                inputWarehouseState.lastUpdatedMillis.notEquals(previousInputTimestamps.get(transitiveInput)) || ((_b = inputWarehouseState.bigquery) === null || _b === void 0 ? void 0 : _b.hasStreamingBuffer)) {
                return false;
            }
        }
        return true;
    }
}
class Timer {
    constructor(startTimeMillis) {
        this.startTimeMillis = startTimeMillis;
    }
    static start(existingTiming) {
        return new Timer((existingTiming === null || existingTiming === void 0 ? void 0 : existingTiming.startTimeMillis.toNumber()) || new Date().valueOf());
    }
    current() {
        return {
            startTimeMillis: Long.fromNumber(this.startTimeMillis)
        };
    }
    end() {
        return {
            startTimeMillis: Long.fromNumber(this.startTimeMillis),
            endTimeMillis: Long.fromNumber(new Date().valueOf())
        };
    }
}

async function list(dbadapter) {
    return await dbadapter.tables();
}
async function get(dbadapter, target) {
    return await dbadapter.table(target);
}

async function test$1(dbadapter, tests) {
    return await Promise.all(tests.map(testCase => runTest(dbadapter, testCase)));
}
async function runTest(dbadapter, testCase) {
    let actualResults;
    let expectedResults;
    try {
        [actualResults, expectedResults] = await Promise.all([
            dbadapter.execute(testCase.testQuery, { byteLimit: 1024 * 1024 }),
            dbadapter.execute(testCase.expectedOutputQuery, { byteLimit: 1024 * 1024 })
        ]);
    }
    catch (e) {
        return {
            name: testCase.name,
            successful: false,
            messages: [`Error thrown: ${e.message}.`]
        };
    }
    if (actualResults.rows.length !== expectedResults.rows.length) {
        return {
            name: testCase.name,
            successful: false,
            messages: [
                `Expected ${expectedResults.rows.length} rows, but saw ${actualResults.rows.length} rows.`
            ]
        };
    }
    if (actualResults.rows.length === 0) {
        return {
            name: testCase.name,
            successful: true
        };
    }
    const actualColumns = Object.keys(actualResults.rows[0]);
    const expectedColumns = Object.keys(expectedResults.rows[0]);
    if (actualColumns.length !== expectedColumns.length) {
        return {
            name: testCase.name,
            successful: false,
            messages: [`Expected columns "${expectedColumns}", but saw "${actualColumns}".`]
        };
    }
    for (const expectedColumn of expectedColumns) {
        if (!actualColumns.some(actualColumn => normalizeColumnName(actualColumn) === normalizeColumnName(expectedColumn))) {
            return {
                name: testCase.name,
                successful: false,
                messages: [`Expected columns "${expectedColumns}", but saw "${actualColumns}".`]
            };
        }
    }
    const rowMessages = [];
    for (let i = 0; i < actualResults.rows.length; i++) {
        const actualResultRow = normalizeRow(actualResults.rows[i]);
        const expectedResultRow = normalizeRow(expectedResults.rows[i]);
        for (const column of actualColumns) {
            const normalizedColumn = normalizeColumnName(column);
            const expectedValue = expectedResultRow[normalizedColumn];
            const actualValue = actualResultRow[normalizedColumn];
            if (typeof expectedValue !== typeof actualValue) {
                rowMessages.push(`For row ${i} and column "${column}": expected type "${typeof expectedValue}", but saw type "${typeof actualValue}".`);
                break;
            }
            const comparableExpectedValue = typeof expectedValue === "object" ? JSON.stringify(expectedValue) : expectedValue;
            const comparableActualValue = typeof actualValue === "object" ? JSON.stringify(actualValue) : actualValue;
            if (comparableExpectedValue !== comparableActualValue) {
                rowMessages.push(`For row ${i} and column "${column}": expected "${comparableExpectedValue}", but saw "${comparableActualValue}".`);
            }
        }
    }
    if (rowMessages.length > 0) {
        return {
            name: testCase.name,
            successful: false,
            messages: rowMessages
        };
    }
    return {
        name: testCase.name,
        successful: true
    };
}
function normalizeColumnName(name) {
    return name.toUpperCase();
}
function normalizeRow(row) {
    const newRow = {};
    Object.keys(row).forEach(colName => {
        newRow[normalizeColumnName(colName)] = row[colName];
    });
    return newRow;
}

function getConfigDirPath() {
    return path.join(os.homedir(), ".dataform");
}
function getConfigSettingsPath() {
    return path.join(getConfigDirPath(), "settings.json");
}
async function getConfigSettings() {
    try {
        if (await util.promisify(fs.exists)(getConfigSettingsPath())) {
            return JSON.parse(await util.promisify(fs.readFile)(getConfigSettingsPath(), "utf8"));
        }
    }
    catch (e) {
    }
    return {};
}
async function upsertConfigSettings(config) {
    try {
        const existingConfig = await getConfigSettings();
        const newConfig = Object.assign(Object.assign({}, existingConfig), config);
        if (!(await util.promisify(fs.exists)(getConfigDirPath()))) {
            await util.promisify(fs.mkdir)(getConfigDirPath());
        }
        await util.promisify(fs.writeFile)(getConfigSettingsPath(), `${JSON.stringify(newConfig, null, 4)}\n`);
    }
    catch (e) {
    }
}

const coloredOutput = (output, ansiColorCode) => `\x1b[${ansiColorCode}m${output}\x1b[0m`;
const successOutput = (output) => coloredOutput(output, 32);
const warningOutput = (output) => coloredOutput(output, 93);
const errorOutput = (output) => coloredOutput(output, 91);
const calloutOutput = (output) => coloredOutput(output, 36);
const write = (stream, output, indentCount) => stream.write(`${"  ".repeat(indentCount)}${output}\n`);
const writeStdOut = (output, indentCount = 0) => write(process.stdout, output, indentCount);
const writeStdErr = (output, indentCount = 0) => write(process.stderr, output, indentCount);
const DEFAULT_PROMPT = "> ";
function question(questionText) {
    return prompt(questionText);
}
function passwordQuestion(questionText) {
    return prompt(questionText, {
        hideEchoBack: true,
        mask: ""
    });
}
function ynQuestion(questionText, defaultValue = false) {
    const response = readlineSync.keyInYN(questionText);
    if (typeof response === "string") {
        return defaultValue;
    }
    return response;
}
function intQuestion(questionText, defaultValue) {
    return parseInt(prompt(questionText, {
        limit: value => {
            const intValue = parseInt(value, 10);
            return !isNaN(intValue);
        },
        limitMessage: errorOutput("Entered value must be an integer."),
        prompt: `[${defaultValue}] `,
        defaultInput: `${defaultValue}`
    }), 10);
}
function selectionQuestion(questionText, options) {
    return readlineSync.keyInSelect(options, `${questionText}\n`, {
        cancel: false
    });
}
function prompt(questionText, options) {
    writeStdOut(questionText);
    return readlineSync.prompt(Object.assign(Object.assign({}, options), { prompt: (options && options.prompt && options.prompt + DEFAULT_PROMPT) || DEFAULT_PROMPT }));
}
function print(text) {
    writeStdOut(text);
}
function printSuccess(text) {
    writeStdOut(successOutput(text));
}
function printError(errorText, indentCount = 0) {
    writeStdErr(errorOutput(errorText), indentCount);
}
function printInitResult(result) {
    if (result.dirsCreated && result.dirsCreated.length) {
        writeStdOut(successOutput("Directories successfully created:"));
        result.dirsCreated.forEach(dir => writeStdOut(dir, 1));
    }
    if (result.filesWritten && result.filesWritten.length) {
        writeStdOut(successOutput("Files successfully written:"));
        result.filesWritten.forEach(file => writeStdOut(file, 1));
    }
    if (result.installedNpmPackages) {
        writeStdOut(successOutput("NPM packages successfully installed."));
    }
}
function printInitCredsResult(writtenFilePath) {
    writeStdOut(successOutput("Credentials file successfully written:"));
    writeStdOut(writtenFilePath, 1);
    writeStdOut("To change connection settings, edit this file directly.");
}
function printCompiledGraph(graph, verbose) {
    if (verbose) {
        writeStdOut(prettyJsonStringify(graph));
    }
    else {
        const actionCount = 0 +
            (graph.tables ? graph.tables.length : 0) +
            (graph.assertions ? graph.assertions.length : 0) +
            (graph.operations ? graph.operations.length : 0);
        writeStdOut(successOutput(`Compiled ${actionCount} action(s).`));
        if (graph.tables && graph.tables.length) {
            writeStdOut(`${graph.tables.length} dataset(s):`);
            graph.tables.forEach(compiledTable => {
                writeStdOut(`${datasetString(compiledTable.target, compiledTable.type, compiledTable.disabled)}`, 1);
            });
        }
        if (graph.assertions && graph.assertions.length) {
            writeStdOut(`${graph.assertions.length} assertion(s):`);
            graph.assertions.forEach(assertion => {
                writeStdOut(assertionString(assertion.target, assertion.disabled), 1);
            });
        }
        if (graph.operations && graph.operations.length) {
            writeStdOut(`${graph.operations.length} operation(s):`);
            graph.operations.forEach(operation => {
                writeStdOut(operationString(operation.target, operation.disabled), 1);
            });
        }
    }
}
function printCompiledGraphErrors(graphErrors) {
    if (graphErrors.compilationErrors && graphErrors.compilationErrors.length > 0) {
        printError("Compilation errors:", 1);
        graphErrors.compilationErrors.forEach(compileError => {
            writeStdErr(`${calloutOutput(compileError.fileName)}: ${errorOutput(compileError.stack || compileError.message)}`, 1);
        });
    }
}
function printTestResult(testResult) {
    writeStdOut(`${testResult.name}: ${testResult.successful ? successOutput("passed") : errorOutput("failed")}`);
    if (!testResult.successful) {
        testResult.messages.forEach(message => writeStdErr(message, 1));
    }
}
function printExecutionGraph(executionGraph, verbose) {
    if (verbose) {
        writeStdOut(prettyJsonStringify(executionGraph.toJSON()));
    }
    else {
        const actionsByType = {
            table: [],
            assertion: [],
            operation: []
        };
        executionGraph.actions.forEach(action => {
            if (!(action.type === "table" || action.type === "assertion" || action.type === "operation")) {
                throw new Error(`Unrecognized action type: ${action.type}`);
            }
            actionsByType[action.type].push(action);
        });
        const datasetActions = actionsByType.table;
        if (datasetActions && datasetActions.length) {
            writeStdOut(`${datasetActions.length} dataset(s):`);
            datasetActions.forEach(datasetAction => writeStdOut(datasetString(datasetAction.target, datasetAction.type, datasetAction.tasks.length === 0), 1));
        }
        const assertionActions = actionsByType.assertion;
        if (assertionActions && assertionActions.length) {
            writeStdOut(`${assertionActions.length} assertion(s):`);
            assertionActions.forEach(assertionAction => writeStdOut(assertionString(assertionAction.target, assertionAction.tasks.length === 0), 1));
        }
        const operationActions = actionsByType.operation;
        if (operationActions && operationActions.length) {
            writeStdOut(`${operationActions.length} operation(s):`);
            operationActions.forEach(operationAction => writeStdOut(operationString(operationAction.target, operationAction.tasks.length === 0), 1));
        }
    }
}
function printExecutedAction(executedAction, executionAction) {
    switch (executedAction.status) {
        case dataform.ActionResult.ExecutionStatus.SUCCESSFUL: {
            switch (executionAction.type) {
                case "table": {
                    writeStdOut(`${successOutput("Dataset created: ")} ${datasetString(executionAction.target, executionAction.tableType, executionAction.tasks.length === 0)}`);
                    return;
                }
                case "assertion": {
                    writeStdOut(`${successOutput("Assertion passed: ")} ${assertionString(executionAction.target, executionAction.tasks.length === 0)}`);
                    return;
                }
                case "operation": {
                    writeStdOut(`${successOutput("Operation completed successfully: ")} ${operationString(executionAction.target, executionAction.tasks.length === 0)}`);
                    return;
                }
            }
        }
        case dataform.ActionResult.ExecutionStatus.FAILED: {
            switch (executionAction.type) {
                case "table": {
                    writeStdErr(`${errorOutput("Dataset creation failed: ")} ${datasetString(executionAction.target, executionAction.tableType, executionAction.tasks.length === 0)}`);
                    break;
                }
                case "assertion": {
                    writeStdErr(`${errorOutput("Assertion failed: ")} ${assertionString(executionAction.target, executionAction.tasks.length === 0)}`);
                    break;
                }
                case "operation": {
                    writeStdErr(`${errorOutput("Operation failed: ")} ${operationString(executionAction.target, executionAction.tasks.length === 0)}`);
                    break;
                }
            }
            printExecutedActionErrors(executedAction, executionAction);
            return;
        }
        case dataform.ActionResult.ExecutionStatus.SKIPPED: {
            switch (executionAction.type) {
                case "table": {
                    writeStdOut(`${warningOutput("Skipping dataset creation: ")} ${datasetString(executionAction.target, executionAction.tableType, executionAction.tasks.length === 0)}`);
                    return;
                }
                case "assertion": {
                    writeStdOut(`${warningOutput("Skipping assertion execution: ")} ${assertionString(executionAction.target, executionAction.tasks.length === 0)}`);
                    return;
                }
                case "operation": {
                    writeStdOut(`${warningOutput("Skipping operation execution: ")} ${operationString(executionAction.target, executionAction.tasks.length === 0)}`);
                    return;
                }
            }
            return;
        }
        case dataform.ActionResult.ExecutionStatus.DISABLED: {
            switch (executionAction.type) {
                case "table": {
                    writeStdOut(`${warningOutput("Dataset creation disabled: ")} ${datasetString(executionAction.target, executionAction.tableType, executionAction.tasks.length === 0)}`);
                    return;
                }
                case "assertion": {
                    writeStdOut(`${warningOutput(`Assertion execution disabled: `)} ${assertionString(executionAction.target, executionAction.tasks.length === 0)}`);
                    return;
                }
                case "operation": {
                    writeStdOut(`${warningOutput(`Operation execution disabled: `)} ${operationString(executionAction.target, executionAction.tasks.length === 0)}`);
                    return;
                }
            }
            return;
        }
        case dataform.ActionResult.ExecutionStatus.CACHE_SKIPPED: {
            switch (executionAction.type) {
                case "table": {
                    writeStdOut(`${warningOutput("Skipped dataset creation (cache hit): ")} ${datasetString(executionAction.target, executionAction.tableType, executionAction.tasks.length === 0)}`);
                    return;
                }
                case "assertion": {
                    writeStdOut(`${warningOutput("Skipped assertion execution (cache hit): ")} ${assertionString(executionAction.target, executionAction.tasks.length === 0)}`);
                    return;
                }
                case "operation": {
                    writeStdOut(`${warningOutput("Skipped operation execution (cache hit): ")} ${operationString(executionAction.target, executionAction.tasks.length === 0)}`);
                    return;
                }
            }
            return;
        }
    }
}
function printFormatFilesResult(formatResults) {
    const sorted = formatResults.sort((a, b) => a.filename.localeCompare(b.filename));
    const successfulFormatResults = sorted.filter(result => !result.err);
    const failedFormatResults = sorted.filter(result => !!result.err);
    if (successfulFormatResults.length > 0) {
        printSuccess("Successfully formatted:");
        successfulFormatResults.forEach(result => writeStdOut(result.filename, 1));
    }
    if (failedFormatResults.length > 0) {
        printError("Errors encountered during formatting:");
        failedFormatResults.forEach(result => writeStdOut(`${result.filename}: ${result.err.message}`, 1));
    }
}
function printListTablesResult(tables) {
    tables.forEach(foundTable => writeStdOut(`${foundTable.schema}.${foundTable.name}`));
}
function printGetTableResult(tableMetadata) {
    writeStdOut(prettyJsonStringify(tableMetadata));
}
function datasetString(target, datasetType, disabled) {
    return `${targetString(target)} [${datasetType}]${disabled ? " [disabled]" : ""}`;
}
function assertionString(target, disabled) {
    return `${targetString(target)}${disabled ? " [disabled]" : ""}`;
}
function operationString(target, disabled) {
    return `${targetString(target)}${disabled ? " [disabled]" : ""}`;
}
function targetString(target) {
    return calloutOutput(`${target.schema}.${target.name}`);
}
function printExecutedActionErrors(executedAction, executionAction) {
    const failingTasks = executedAction.tasks.filter(task => task.status === dataform.ActionResult.ExecutionStatus.FAILED);
    failingTasks.forEach((task, i) => {
        executionAction.tasks[i].statement.split("\n").forEach(line => {
            writeStdErr(`${DEFAULT_PROMPT}${line}`, 1);
        });
        printError(task.errorMessage, 1);
    });
}

const analytics = new Analytics("eR24ln3MniE3TKZXkvAkOGkiSN02xXqw");
let currentCommand;
async function maybeConfigureAnalytics() {
    const settings = await getConfigSettings();
    if (!process.stdout.isTTY) {
        return;
    }
    if (settings.allowAnonymousAnalytics !== undefined) {
        return;
    }
    const optInResponse = ynQuestion(`
To help improve the quality of our products, we collect anonymized usage data and anonymized stacktraces when crashes are encountered.
This can be changed at any point by modifying your settings file: ${getConfigSettingsPath()}

Would you like to opt-in to anonymous usage and error tracking?`, false);
    await upsertConfigSettings({
        allowAnonymousAnalytics: optInResponse,
        anonymousUserId: uuid.v4()
    });
}
async function trackCommand(command) {
    currentCommand = command;
    const config = await getConfigSettings();
    if (!config.allowAnonymousAnalytics) {
        return;
    }
    await new Promise(resolve => {
        analytics.track({
            userId: config.anonymousUserId,
            event: "event_dataform_cli_command",
            properties: {
                command
            }
        }, () => {
            resolve();
        });
    });
}
async function trackError() {
    const config = await getConfigSettings();
    if (!config.allowAnonymousAnalytics) {
        return;
    }
    await new Promise(resolve => {
        analytics.track({
            userId: config.anonymousUserId,
            event: "event_dataform_cli_error",
            properties: {
                currentCommand
            }
        }, () => {
            resolve();
        });
    });
}

const actuallyResolve = (filePath) => path.resolve(untildify(filePath));
function assertPathExists(checkPath) {
    if (!fs.existsSync(checkPath)) {
        throw new Error(`${checkPath} does not exist!`);
    }
}
function compiledGraphHasErrors(graph) {
    var _a, _b;
    return ((_b = (_a = graph.graphErrors) === null || _a === void 0 ? void 0 : _a.compilationErrors) === null || _b === void 0 ? void 0 : _b.length) > 0;
}

function getBigQueryCredentials() {
    const cloudCredentialsPath = actuallyResolve(question("Please follow the instructions at https://docs.dataform.co/how_to_guides/dataform_web/set_up_datawarehouse/\n" +
        "to create and download a private key from the Google Cloud Console in JSON format.\n" +
        "(You can delete this file after credential initialization is complete.)\n\n" +
        "Enter the path to your Google Cloud private key file:"));
    if (!fs.existsSync(cloudCredentialsPath)) {
        throw new Error(`Google Cloud private key file "${cloudCredentialsPath}" does not exist!`);
    }
    const cloudCredentials = JSON.parse(fs.readFileSync(cloudCredentialsPath, "utf8"));
    const locationIndex = selectionQuestion("Enter the location of your datasets:", [
        "US (default)",
        "EU",
        "other"
    ]);
    let location = locationIndex === 0 ? "US" : "EU";
    if (locationIndex === 2) {
        location = question("Enter the location's region name (e.g. 'asia-south1'):");
    }
    return {
        projectId: cloudCredentials.project_id,
        credentials: fs.readFileSync(cloudCredentialsPath, "utf8"),
        location
    };
}
function getPostgresCredentials() {
    return getJdbcCredentials("Enter the hostname of your Postgres database:", 5432);
}
function getRedshiftCredentials() {
    return getJdbcCredentials("Enter the hostname of your Redshift instance (in the form 'name.id.region.redshift.amazonaws.com'):", 5439);
}
function getSQLDataWarehouseCredentials() {
    const server = question("Enter your server name (for example 'name.database.windows.net'):");
    const port = intQuestion("Enter your server port:", 1433);
    const username = question("Enter your datawarehouse user:");
    const password = passwordQuestion("Enter your datawarehouse password:");
    const database = question("Enter the database name:");
    return {
        server,
        port,
        username,
        password,
        database
    };
}
function getSnowflakeCredentials() {
    const accountId = question("Enter your Snowflake account identifier, including region (for example 'myaccount.us-east-1'):");
    const role = question("Enter your database role:");
    const username = question("Enter your database username:");
    const password = passwordQuestion("Enter your database password:");
    const databaseName = question("Enter the database name:");
    const warehouse = question("Enter your warehouse name:");
    return {
        accountId,
        role,
        username,
        password,
        databaseName,
        warehouse
    };
}
function getJdbcCredentials(hostQuestion, defaultPort) {
    const host = question(hostQuestion);
    const port = intQuestion("Enter the port that Dataform should connect to (leave blank to use default):", defaultPort);
    const username = question("Enter your database username:");
    const password = passwordQuestion("Enter your database password:");
    const databaseName = question("Enter the database name:");
    return {
        host,
        port,
        username,
        password,
        databaseName
    };
}

function createYargsCli(cli) {
    let yargsChain = yargs(fixArgvForHelp());
    for (const command of cli.commands) {
        yargsChain = yargsChain.command(command.format, command.description, (yargsChainer) => createOptionsChain(yargsChainer, command), async (argv) => {
            await maybeConfigureAnalytics();
            const analyticsTrack = trackCommand(command.format.split(" ")[0]);
            const exitCode = await command.processFn(argv);
            let timer;
            await Promise.race([
                analyticsTrack,
                new Promise(resolve => (timer = setTimeout(resolve, 2000)))
            ]);
            clearTimeout(timer);
            process.exit(exitCode);
        });
    }
    return yargsChain;
}
function createOptionsChain(yargsChain, command) {
    const checks = [];
    for (const positionalOption of command.positionalOptions) {
        yargsChain = yargsChain.positional(positionalOption.name, positionalOption.option);
        if (positionalOption.check) {
            checks.push(positionalOption.check);
        }
    }
    for (const option of command.options) {
        yargsChain = yargsChain.option(option.name, option.option);
        if (option.check) {
            checks.push(option.check);
        }
    }
    yargsChain = yargsChain.check(argv => {
        checks.forEach(check => check(argv));
        return true;
    });
    return yargsChain;
}
function fixArgvForHelp() {
    const argvCopy = process.argv.slice(2);
    if (argvCopy[0] === "help") {
        argvCopy[0] = "--help";
    }
    return argvCopy;
}

const JS_BEAUTIFY_OPTIONS = {
    indent_size: 2,
    preserve_newlines: true,
    max_preserve_newlines: 2
};
const MAX_SQL_FORMAT_ATTEMPTS = 5;
function format(text, fileExtension) {
    try {
        switch (fileExtension) {
            case "sqlx":
                return postProcessFormattedSqlx(formatSqlx(SyntaxTreeNode.create(text)));
            case "js":
                return `${formatJavaScript(text).trim()}\n`;
            default:
                return text;
        }
    }
    catch (e) {
        throw new ErrorWithCause(`Unable to format "${text === null || text === void 0 ? void 0 : text.substring(0, 20)}...".`, e);
    }
}
async function formatFile(filename, options) {
    const fileExtension = filename.split(".").slice(-1)[0];
    const originalFileContent = await util.promisify(fs.readFile)(filename, "utf8");
    const formattedText = format(originalFileContent, fileExtension);
    if (formattedText !== format(formattedText, fileExtension)) {
        throw new Error("Formatter unable to determine final formatted form.");
    }
    const noWhiteSpaceFormatted = formattedText.replace(/\s/g, "");
    const noWhiteSpaceOriginal = originalFileContent.replace(/\s/g, "");
    if (noWhiteSpaceFormatted.length !== noWhiteSpaceOriginal.length) {
        const isLonger = noWhiteSpaceFormatted.length > noWhiteSpaceOriginal.length;
        throw new Error(`Formatter ${isLonger ? "added" : "removed"} non-whitespace characters`);
    }
    if (options && options.overwriteFile) {
        await util.promisify(fs.writeFile)(filename, formattedText);
    }
    return formattedText;
}
function formatSqlx(node, indent = "") {
    const { sqlxStatements, javascriptBlocks, innerSqlBlocks } = separateSqlxIntoParts(node.children());
    const formattedJsCodeBlocks = javascriptBlocks.map(jsCodeBlock => formatJavaScript(jsCodeBlock.concatenate()));
    const formattedSqlxStatements = sqlxStatements.map(sqlxStatement => {
        const placeholders = {};
        const unformattedPlaceholderSql = stripUnformattableText(sqlxStatement, placeholders).join("");
        const formattedPlaceholderSql = formatSql(unformattedPlaceholderSql);
        return formatEveryLine(replacePlaceholders(formattedPlaceholderSql, placeholders), line => `${indent}${line}`);
    });
    const formattedSqlCodeBlocks = innerSqlBlocks.map((sqlCodeBlock) => {
        const firstPart = sqlCodeBlock.children()[0];
        const upToFirstBrace = firstPart.slice(0, firstPart.indexOf("{") + 1);
        const lastPart = sqlCodeBlock.children()[sqlCodeBlock.children().length - 1];
        const lastBraceOnwards = lastPart.slice(lastPart.lastIndexOf("}"));
        const sqlCodeBlockWithoutOuterBraces = sqlCodeBlock.children().length === 1
            ? new SyntaxTreeNode(SyntaxTreeNodeType.SQL, [
                firstPart.slice(firstPart.indexOf("{") + 1, firstPart.lastIndexOf("}"))
            ])
            : new SyntaxTreeNode(SyntaxTreeNodeType.SQL, [
                firstPart.slice(firstPart.indexOf("{") + 1),
                ...sqlCodeBlock.children().slice(1, -1),
                lastPart.slice(0, lastPart.lastIndexOf("}"))
            ]);
        return `${upToFirstBrace}
${formatSqlx(sqlCodeBlockWithoutOuterBraces, "  ")}
${lastBraceOnwards}`;
    });
    const finalText = `
${formattedJsCodeBlocks.join("\n\n")}

${formattedSqlxStatements.join(`\n\n${indent}---\n\n`)}

${formattedSqlCodeBlocks.join("\n\n")}
`;
    return `${indent}${finalText.trim()}`;
}
function separateSqlxIntoParts(nodeContents) {
    const sqlxStatements = [[]];
    const javascriptBlocks = [];
    const innerSqlBlocks = [];
    nodeContents.forEach(child => {
        if (typeof child !== "string") {
            switch (child.type) {
                case SyntaxTreeNodeType.JAVASCRIPT:
                    javascriptBlocks.push(child);
                    return;
                case SyntaxTreeNodeType.SQL:
                    innerSqlBlocks.push(child);
                    return;
                case SyntaxTreeNodeType.SQL_STATEMENT_SEPARATOR:
                    sqlxStatements.push([]);
                    return;
            }
        }
        sqlxStatements[sqlxStatements.length - 1].push(child);
    });
    return {
        sqlxStatements,
        javascriptBlocks,
        innerSqlBlocks
    };
}
function stripUnformattableText(sqlxStatementParts, placeholders) {
    return sqlxStatementParts.map(part => {
        if (typeof part !== "string") {
            const placeholderId = generatePlaceholderId();
            switch (part.type) {
                case SyntaxTreeNodeType.SQL_LITERAL_STRING:
                case SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER: {
                    placeholders[placeholderId] = part;
                    return placeholderId;
                }
                case SyntaxTreeNodeType.SQL_COMMENT: {
                    const commentPlaceholderId = part.concatenate().startsWith("--")
                        ? `--${placeholderId}`
                        : `/*${placeholderId}*/`;
                    placeholders[commentPlaceholderId] = part;
                    return commentPlaceholderId;
                }
                default:
                    throw new Error(`Misplaced SyntaxTreeNodeType inside SQLX: ${part.type}`);
            }
        }
        return part;
    });
}
function generatePlaceholderId() {
    return uuid.v4()
        .replace(/-/g, "")
        .substring(0, 16);
}
function replacePlaceholders(formattedSql, placeholders) {
    return Object.keys(placeholders).reduce((partiallyFormattedSql, placeholderId) => {
        const placeholderValue = placeholders[placeholderId];
        if (typeof placeholderValue === "string") {
            return partiallyFormattedSql.replace(placeholderId, placeholderValue);
        }
        return formatPlaceholderInSqlx(placeholderId, placeholderValue, partiallyFormattedSql);
    }, formattedSql);
}
function formatJavaScript(text) {
    return jsBeautify.js(text, JS_BEAUTIFY_OPTIONS);
}
function formatSql(text) {
    let formatted = sqlFormatter.format(text);
    for (let attempts = 0; attempts < MAX_SQL_FORMAT_ATTEMPTS; attempts++) {
        const newFormatted = sqlFormatter.format(formatted);
        if (newFormatted === formatted) {
            return newFormatted;
        }
        formatted = newFormatted;
    }
    throw new Error(`SQL formatter was unable to determine final formatted form within ${MAX_SQL_FORMAT_ATTEMPTS} attempts. Original text: ${text}`);
}
function formatPlaceholderInSqlx(placeholderId, placeholderSyntaxNode, sqlx) {
    const wholeLine = getWholeLineContainingPlaceholderId(placeholderId, sqlx);
    const indent = " ".repeat(wholeLine.length - wholeLine.trimLeft().length);
    const formattedPlaceholder = formatSqlQueryPlaceholder(placeholderSyntaxNode, indent);
    if (placeholderSyntaxNode.type !== SyntaxTreeNodeType.SQL_COMMENT &&
        !formattedPlaceholder.includes("\n")) {
        return sqlx.replace(placeholderId, () => formattedPlaceholder.trim());
    }
    const [textBeforePlaceholder, textAfterPlaceholder] = wholeLine.split(placeholderId);
    const newLines = [];
    if (textBeforePlaceholder.trim().length > 0) {
        newLines.push(`${indent}${textBeforePlaceholder.trim()}`);
    }
    newLines.push(formattedPlaceholder);
    if (textAfterPlaceholder.trim().length > 0) {
        newLines.push(`${indent}${textAfterPlaceholder.trim()}`);
    }
    return sqlx.replace(wholeLine, newLines.join("\n"));
}
function formatSqlQueryPlaceholder(node, jsIndent) {
    switch (node.type) {
        case SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER:
            return formatJavaScriptPlaceholder(node, jsIndent);
        case SyntaxTreeNodeType.SQL_LITERAL_STRING:
        case SyntaxTreeNodeType.SQL_COMMENT:
            return formatEveryLine(node.concatenate(), line => `${jsIndent}${line.trimLeft()}`);
        default:
            throw new Error(`Unrecognized SyntaxTreeNodeType: ${node.type}`);
    }
}
function formatJavaScriptPlaceholder(node, jsIndent) {
    const formattedJs = formatJavaScript(node.concatenate());
    const textInsideBraces = formattedJs.slice(formattedJs.indexOf("{") + 1, formattedJs.lastIndexOf("}"));
    const finalJs = textInsideBraces.trim().includes("\n")
        ? `\${${textInsideBraces}}`
        : `\${${textInsideBraces.trim()}}`;
    return formatEveryLine(finalJs, line => `${jsIndent}${line}`);
}
function formatEveryLine(text, mapFn) {
    return text
        .split("\n")
        .map(mapFn)
        .join("\n");
}
function getWholeLineContainingPlaceholderId(placeholderId, text) {
    const regexpEscapedPlaceholderId = placeholderId.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return text.match(new RegExp(".*" + regexpEscapedPlaceholderId + ".*"))[0];
}
function postProcessFormattedSqlx(formattedSql) {
    let previousLineHadContent = false;
    formattedSql = formattedSql.split("\n").reduce((accumulatedSql, currentLine) => {
        const lineHasContent = currentLine.trim().length > 0;
        if (lineHasContent) {
            previousLineHadContent = true;
            return `${accumulatedSql}\n${currentLine.trimRight()}`;
        }
        if (previousLineHadContent) {
            previousLineHadContent = false;
            return `${accumulatedSql}\n`;
        }
        return accumulatedSql;
    }, "");
    return `${formattedSql.trim()}\n`;
}

const RECOMPILE_DELAY = 500;
process.on("unhandledRejection", async (reason) => {
    printError(`Unhandled promise rejection: ${(reason === null || reason === void 0 ? void 0 : reason.stack) || reason}`);
    await trackError();
});
const projectDirOption = {
    name: "project-dir",
    option: {
        describe: "The Dataform project directory.",
        default: ".",
        coerce: actuallyResolve
    }
};
const projectDirMustExistOption = Object.assign(Object.assign({}, projectDirOption), { check: (argv) => {
        assertPathExists(argv["project-dir"]);
        try {
            assertPathExists(path.resolve(argv["project-dir"], "dataform.json"));
        }
        catch (e) {
            throw new Error(`${argv["project-dir"]} does not appear to be a dataform directory (missing dataform.json file).`);
        }
    } });
const fullRefreshOption = {
    name: "full-refresh",
    option: {
        describe: "Forces incremental tables to be rebuilt from scratch.",
        type: "boolean",
        default: false
    }
};
const actionsOption = {
    name: "actions",
    option: {
        describe: "A list of action names or patterns to run. Can include '*' wildcards.",
        type: "array"
    }
};
const includeDepsOption = {
    name: "include-deps",
    option: {
        describe: "If set, dependencies for selected actions will also be run.",
        type: "boolean"
    },
    check: (argv) => {
        if (argv.include_deps && !argv.actions) {
            throw new Error("The --include_deps flag should only be supplied along with --actions.");
        }
    }
};
const tagsOption = {
    name: "tags",
    option: {
        describe: "A list of tags to filter the actions to run.",
        type: "array"
    }
};
const schemaSuffixOverrideOption = {
    name: "schema-suffix",
    option: {
        describe: "A suffix to be appended to output schema names."
    },
    check: (argv) => {
        if (argv.schemaSuffix && !/^[a-zA-Z_0-9]+$/.test(argv.schemaSuffix)) {
            throw new Error("--schema-suffix should contain only alphanumeric characters and/or underscores.");
        }
    }
};
const credentialsOption = {
    name: "credentials",
    option: {
        describe: "The location of the credentials JSON file to use.",
        default: null
    },
    check: (argv) => !argv.credentials || assertPathExists(getCredentialsPath(argv.projectDir, argv.credentials))
};
const warehouseOption = {
    name: "warehouse",
    option: {
        describe: "The project's data warehouse type.",
        choices: Object.values(WarehouseType)
    }
};
const jsonOutputOption = {
    name: "json",
    option: {
        describe: "Outputs a JSON representation of the compiled project.",
        type: "boolean",
        default: false
    }
};
const getCredentialsPath = (projectDir, credentialsPath) => actuallyResolve(credentialsPath || path.join(projectDir, CREDENTIALS_FILENAME));
function runCli() {
    const builtYargs = createYargsCli({
        commands: [
            {
                format: "help [command]",
                description: "Show help. If [command] is specified, the help is for the given command.",
                positionalOptions: [],
                options: [],
                processFn: async (argv) => {
                    return 0;
                }
            },
            {
                format: "init <warehouse> [project-dir]",
                description: "Create a new dataform project.",
                positionalOptions: [warehouseOption, projectDirOption],
                options: [
                    {
                        name: "default-database",
                        option: {
                            describe: "The default database to use. For BigQuery, this is a Google Cloud Project ID."
                        },
                        check: (argv) => {
                            if (argv["default-database"] && !["bigquery", "snowflake"].includes(argv.warehouse)) {
                                throw new Error("The --default-database flag is only used for BigQuery and Snowflake projects.");
                            }
                            if (!argv["default-database"] && argv.warehouse === "bigquery") {
                                throw new Error("The --default-database flag is required for BigQuery projects. Please run 'dataform help init' for more information.");
                            }
                        }
                    },
                    {
                        name: "skip-install",
                        option: {
                            describe: "Whether to skip installing NPM packages.",
                            default: false
                        }
                    },
                    {
                        name: "include-schedules",
                        option: {
                            describe: "Whether to initialize a schedules.json file.",
                            default: false
                        }
                    },
                    {
                        name: "include-environments",
                        option: {
                            describe: "Whether to initialize a environments.json file.",
                            default: false
                        }
                    }
                ],
                processFn: async (argv) => {
                    print("Writing project files...\n");
                    const initResult = await init(argv["project-dir"], {
                        warehouse: argv.warehouse,
                        defaultDatabase: argv["default-database"],
                        useRunCache: false
                    }, {
                        skipInstall: argv["skip-install"],
                        includeSchedules: argv["include-schedules"],
                        includeEnvironments: argv["include-environments"]
                    });
                    printInitResult(initResult);
                    return 0;
                }
            },
            {
                format: "install [project-dir]",
                description: "Install a project's NPM dependencies.",
                positionalOptions: [projectDirMustExistOption],
                options: [],
                processFn: async (argv) => {
                    print("Installing NPM dependencies...\n");
                    await install(argv["project-dir"]);
                    printSuccess("Project dependencies successfully installed.");
                    return 0;
                }
            },
            {
                format: "init-creds <warehouse> [project-dir]",
                description: `Create a ${CREDENTIALS_FILENAME} file for Dataform to use when accessing your warehouse.`,
                positionalOptions: [warehouseOption, projectDirMustExistOption],
                options: [
                    {
                        name: "test-connection",
                        option: {
                            describe: "If true, a test query will be run using your final credentials.",
                            type: "boolean",
                            default: true
                        }
                    }
                ],
                processFn: async (argv) => {
                    const credentialsFn = () => {
                        switch (argv.warehouse) {
                            case "bigquery": {
                                return getBigQueryCredentials();
                            }
                            case "postgres": {
                                return getPostgresCredentials();
                            }
                            case "redshift": {
                                return getRedshiftCredentials();
                            }
                            case "sqldatawarehouse": {
                                return getSQLDataWarehouseCredentials();
                            }
                            case "snowflake": {
                                return getSnowflakeCredentials();
                            }
                            default: {
                                throw new Error(`Unrecognized warehouse type ${argv.warehouse}`);
                            }
                        }
                    };
                    const finalCredentials = credentialsFn();
                    if (argv["test-connection"]) {
                        print("\nRunning connection test...");
                        const dbadapter = await create$1(finalCredentials, argv.warehouse);
                        try {
                            const testResult = await test(dbadapter);
                            switch (testResult.status) {
                                case TestResultStatus.SUCCESSFUL: {
                                    printSuccess("\nWarehouse test query completed successfully.\n");
                                    break;
                                }
                                case TestResultStatus.TIMED_OUT: {
                                    throw new Error("Warehouse test connection timed out.");
                                }
                                case TestResultStatus.OTHER_ERROR: {
                                    throw new Error(`Warehouse test query failed: ${testResult.error.stack ||
                                        testResult.error.message}`);
                                }
                            }
                        }
                        finally {
                            await dbadapter.close();
                        }
                    }
                    else {
                        print("\nWarehouse test query was not run.\n");
                    }
                    const filePath = path.resolve(argv["project-dir"], CREDENTIALS_FILENAME);
                    fs.writeFileSync(filePath, prettyJsonStringify(finalCredentials));
                    printInitCredsResult(filePath);
                    return 0;
                }
            },
            {
                format: "compile [project-dir]",
                description: "Compile the dataform project. Produces JSON output describing the non-executable graph.",
                positionalOptions: [projectDirMustExistOption],
                options: [
                    {
                        name: "watch",
                        option: {
                            describe: "Whether to watch the changes in the project directory.",
                            type: "boolean",
                            default: false
                        }
                    },
                    schemaSuffixOverrideOption,
                    jsonOutputOption
                ],
                processFn: async (argv) => {
                    const projectDir = argv["project-dir"];
                    const schemaSuffixOverride = argv["schema-suffix"];
                    const compileAndPrint = async () => {
                        if (!argv.json) {
                            print("Compiling...\n");
                        }
                        const compiledGraph = await compile({
                            projectDir,
                            schemaSuffixOverride
                        });
                        printCompiledGraph(compiledGraph, argv.json);
                        if (compiledGraphHasErrors(compiledGraph)) {
                            print("");
                            printCompiledGraphErrors(compiledGraph.graphErrors);
                            return true;
                        }
                        return false;
                    };
                    const graphHasErrors = await compileAndPrint();
                    if (!argv.watch) {
                        return graphHasErrors ? 1 : 0;
                    }
                    let watching = true;
                    let timeoutID = null;
                    let isCompiling = false;
                    const watcher = chokidar.watch(projectDir, {
                        ignored: /node_modules/,
                        persistent: true,
                        ignoreInitial: true,
                        awaitWriteFinish: {
                            stabilityThreshold: 1000,
                            pollInterval: 200
                        }
                    });
                    const printReady = () => {
                        print("\nWatching for changes...\n");
                    };
                    watcher
                        .on("ready", printReady)
                        .on("error", error => {
                        printError(`Error: ${error}`);
                        process.exit(1);
                    })
                        .on("all", () => {
                        if (timeoutID || isCompiling) {
                            clearTimeout(timeoutID);
                        }
                        timeoutID = setTimeout(async () => {
                            clearTimeout(timeoutID);
                            if (!isCompiling) {
                                isCompiling = true;
                                await compileAndPrint();
                                printReady();
                                isCompiling = false;
                            }
                        }, RECOMPILE_DELAY);
                    });
                    process.on("SIGINT", () => {
                        watcher.close();
                        watching = false;
                        process.exit(1);
                    });
                    while (watching) {
                        await new Promise((resolve, reject) => setTimeout(() => resolve(), 100));
                    }
                }
            },
            {
                format: "test [project-dir]",
                description: "Run the dataform project's unit tests on the configured data warehouse.",
                positionalOptions: [projectDirMustExistOption],
                options: [credentialsOption],
                processFn: async (argv) => {
                    print("Compiling...\n");
                    const compiledGraph = await compile({
                        projectDir: argv["project-dir"],
                        schemaSuffixOverride: argv["schema-suffix"]
                    });
                    if (compiledGraphHasErrors(compiledGraph)) {
                        printCompiledGraphErrors(compiledGraph.graphErrors);
                        return 1;
                    }
                    printSuccess("Compiled successfully.\n");
                    const readCredentials = read(compiledGraph.projectConfig.warehouse, getCredentialsPath(argv.projectDir, argv.credentials));
                    if (!compiledGraph.tests.length) {
                        printError("No unit tests found.");
                        return 1;
                    }
                    print(`Running ${compiledGraph.tests.length} unit tests...\n`);
                    const dbadapter = await create$1(readCredentials, compiledGraph.projectConfig.warehouse, { concurrencyLimit: compiledGraph.projectConfig.concurrentQueryLimit });
                    try {
                        const testResults = await test$1(dbadapter, compiledGraph.tests);
                        testResults.forEach(testResult => printTestResult(testResult));
                        return testResults.every(testResult => testResult.successful) ? 0 : 1;
                    }
                    finally {
                        await dbadapter.close();
                    }
                }
            },
            {
                format: "run [project-dir]",
                description: "Run the dataform project's scripts on the configured data warehouse.",
                positionalOptions: [projectDirMustExistOption],
                options: [
                    {
                        name: "dry-run",
                        option: {
                            describe: "If set, built SQL is not run against the data warehouse and instead is printed to the console.",
                            type: "boolean"
                        }
                    },
                    {
                        name: "run-tests",
                        option: {
                            describe: "If set, the project's unit tests are required to pass before running the project.",
                            type: "boolean"
                        }
                    },
                    fullRefreshOption,
                    actionsOption,
                    tagsOption,
                    includeDepsOption,
                    schemaSuffixOverrideOption,
                    credentialsOption,
                    jsonOutputOption
                ],
                processFn: async (argv) => {
                    if (!argv.json) {
                        print("Compiling...\n");
                    }
                    const compiledGraph = await compile({
                        projectDir: argv["project-dir"],
                        schemaSuffixOverride: argv["schema-suffix"]
                    });
                    if (compiledGraphHasErrors(compiledGraph)) {
                        printCompiledGraphErrors(compiledGraph.graphErrors);
                        return 1;
                    }
                    if (!argv.json) {
                        printSuccess("Compiled successfully.\n");
                    }
                    const readCredentials = read(compiledGraph.projectConfig.warehouse, getCredentialsPath(argv.projectDir, argv.credentials));
                    const dbadapter = await create$1(readCredentials, compiledGraph.projectConfig.warehouse, { concurrencyLimit: compiledGraph.projectConfig.concurrentQueryLimit });
                    try {
                        const executionGraph = await build(compiledGraph, {
                            fullRefresh: argv["full-refresh"],
                            actions: argv.actions,
                            includeDependencies: argv["include-dependencies"],
                            includeDependents: argv["include-dependents"],
                            tags: argv.tags
                        }, dbadapter);
                        if (argv["dry-run"]) {
                            if (!argv.json) {
                                print("Dry run (--dry-run) mode is turned on; not running the following actions against your warehouse:\n");
                            }
                            printExecutionGraph(executionGraph, argv.json);
                            return;
                        }
                        if (argv["run-tests"]) {
                            print(`Running ${compiledGraph.tests.length} unit tests...\n`);
                            const testResults = await test$1(dbadapter, compiledGraph.tests);
                            testResults.forEach(testResult => printTestResult(testResult));
                            if (testResults.some(testResult => !testResult.successful)) {
                                printError("\nUnit tests did not pass; aborting run.");
                                return 1;
                            }
                            printSuccess("Unit tests completed successfully.\n");
                        }
                        if (!argv.json) {
                            print("Running...\n");
                        }
                        const runner = run(dbadapter, executionGraph);
                        process.on("SIGINT", () => {
                            if (!supportsCancel(WarehouseType[compiledGraph.projectConfig.warehouse])) {
                                process.exit(1);
                            }
                            runner.cancel();
                        });
                        const actionsByName = new Map();
                        executionGraph.actions.forEach(action => {
                            actionsByName.set(action.name, action);
                        });
                        const alreadyPrintedActions = new Set();
                        const printExecutedGraph = (executedGraph) => {
                            executedGraph.actions
                                .filter(actionResult => actionResult.status !== dataform.ActionResult.ExecutionStatus.RUNNING)
                                .filter(executedAction => !alreadyPrintedActions.has(executedAction.name))
                                .forEach(executedAction => {
                                printExecutedAction(executedAction, actionsByName.get(executedAction.name));
                                alreadyPrintedActions.add(executedAction.name);
                            });
                        };
                        runner.onChange(printExecutedGraph);
                        const runResult = await runner.result();
                        printExecutedGraph(runResult);
                        return runResult.status === dataform.RunResult.ExecutionStatus.SUCCESSFUL ? 0 : 1;
                    }
                    finally {
                        await dbadapter.close();
                    }
                }
            },
            {
                format: "format [project-dir]",
                description: "Format the dataform project's files.",
                positionalOptions: [projectDirMustExistOption],
                options: [],
                processFn: async (argv) => {
                    const filenames = glob.sync("{definitions,includes}/**/*.{js,sqlx}", {
                        cwd: argv["project-dir"]
                    });
                    const results = await Promise.all(filenames.map(async (filename) => {
                        try {
                            await formatFile(path.resolve(argv["project-dir"], filename), {
                                overwriteFile: true
                            });
                            return {
                                filename
                            };
                        }
                        catch (e) {
                            return {
                                filename,
                                err: e
                            };
                        }
                    }));
                    printFormatFilesResult(results);
                    return 0;
                }
            },
            {
                format: "listtables <warehouse>",
                description: "List tables on the configured data warehouse.",
                positionalOptions: [warehouseOption],
                options: [credentialsOption],
                processFn: async (argv) => {
                    const readCredentials = read(argv.warehouse, actuallyResolve(argv.credentials));
                    const dbadapter = await create$1(readCredentials, argv.warehouse);
                    try {
                        printListTablesResult(await list(dbadapter));
                    }
                    finally {
                        await dbadapter.close();
                    }
                    return 0;
                }
            },
            {
                format: "gettablemetadata <warehouse> <schema> <table>",
                description: "Fetch metadata for a specified table.",
                positionalOptions: [warehouseOption],
                options: [credentialsOption],
                processFn: async (argv) => {
                    const readCredentials = read(argv.warehouse, actuallyResolve(argv.credentials));
                    const dbadapter = await create$1(readCredentials, argv.warehouse);
                    try {
                        printGetTableResult(await get(dbadapter, {
                            schema: argv.schema,
                            name: argv.table
                        }));
                    }
                    finally {
                        await dbadapter.close();
                    }
                    return 0;
                }
            }
        ]
    })
        .scriptName("dataform")
        .strict()
        .wrap(null)
        .recommendCommands()
        .fail(async (msg, err) => {
        if (!!err && err.name === "VMError" && err.message.includes("Cannot find module")) {
            printError("Could not find NPM dependencies. Have you run 'dataform install'?");
        }
        else {
            const message = (err === null || err === void 0 ? void 0 : err.message) ? err.message.split("\n")[0] : msg;
            printError(`Dataform encountered an error: ${message}`);
            await trackError();
            if (err === null || err === void 0 ? void 0 : err.stack) {
                printError(err.stack);
            }
        }
        process.exit(1);
    }).argv;
    if (!builtYargs._[0]) {
        yargs.showHelp();
    }
}

runCli();
