#!/usr/bin/env node
'use strict';

var path = require('path');
var vm2 = require('vm2');
var glob = require('glob');
var protobufjs = require('protobufjs');
var $protobuf = require('protobufjs/minimal');

function encode(protoType, value = {}) {
    return toBase64(protoType.encode(protoType.create(value)).finish());
}
function decode(protoType, encodedValue) {
    if (!encodedValue) {
        return protoType.create();
    }
    return protoType.decode(fromBase64(encodedValue));
}
function toBase64(value) {
    return protobufjs.util.base64.encode(value, 0, value.length);
}
function fromBase64(value) {
    const buf = new Uint8Array(protobufjs.util.base64.length(value));
    protobufjs.util.base64.decode(value, buf, 0);
    return buf;
}

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

const dataform = $root.dataform = (() => {

    /**
     * Namespace dataform.
     * @exports dataform
     * @namespace
     */
    const dataform = {};

    dataform.ProjectConfig = (function() {

        /**
         * Properties of a ProjectConfig.
         * @memberof dataform
         * @interface IProjectConfig
         * @property {string|null} [warehouse] ProjectConfig warehouse
         * @property {string|null} [defaultDatabase] ProjectConfig defaultDatabase
         * @property {string|null} [defaultSchema] ProjectConfig defaultSchema
         * @property {string|null} [assertionSchema] ProjectConfig assertionSchema
         * @property {Object.<string,string>|null} [vars] ProjectConfig vars
         * @property {number|null} [concurrentQueryLimit] ProjectConfig concurrentQueryLimit
         * @property {number|null} [idempotentActionRetries] ProjectConfig idempotentActionRetries
         * @property {string|null} [databaseSuffix] ProjectConfig databaseSuffix
         * @property {string|null} [schemaSuffix] ProjectConfig schemaSuffix
         * @property {string|null} [tablePrefix] ProjectConfig tablePrefix
         * @property {boolean|null} [useRunCache] ProjectConfig useRunCache
         * @property {string|null} [gcloudProjectId] ProjectConfig gcloudProjectId
         */

        /**
         * Constructs a new ProjectConfig.
         * @memberof dataform
         * @classdesc Represents a ProjectConfig.
         * @implements IProjectConfig
         * @constructor
         * @param {dataform.IProjectConfig=} [properties] Properties to set
         */
        function ProjectConfig(properties) {
            this.vars = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProjectConfig warehouse.
         * @member {string} warehouse
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.warehouse = "";

        /**
         * ProjectConfig defaultDatabase.
         * @member {string} defaultDatabase
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultDatabase = "";

        /**
         * ProjectConfig defaultSchema.
         * @member {string} defaultSchema
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultSchema = "";

        /**
         * ProjectConfig assertionSchema.
         * @member {string} assertionSchema
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.assertionSchema = "";

        /**
         * ProjectConfig vars.
         * @member {Object.<string,string>} vars
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.vars = $util.emptyObject;

        /**
         * ProjectConfig concurrentQueryLimit.
         * @member {number} concurrentQueryLimit
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.concurrentQueryLimit = 0;

        /**
         * ProjectConfig idempotentActionRetries.
         * @member {number} idempotentActionRetries
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.idempotentActionRetries = 0;

        /**
         * ProjectConfig databaseSuffix.
         * @member {string} databaseSuffix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.databaseSuffix = "";

        /**
         * ProjectConfig schemaSuffix.
         * @member {string} schemaSuffix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.schemaSuffix = "";

        /**
         * ProjectConfig tablePrefix.
         * @member {string} tablePrefix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.tablePrefix = "";

        /**
         * ProjectConfig useRunCache.
         * @member {boolean} useRunCache
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.useRunCache = false;

        /**
         * ProjectConfig gcloudProjectId.
         * @member {string} gcloudProjectId
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.gcloudProjectId = "";

        /**
         * Creates a new ProjectConfig instance using the specified properties.
         * @function create
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig=} [properties] Properties to set
         * @returns {dataform.ProjectConfig} ProjectConfig instance
         */
        ProjectConfig.create = function create(properties) {
            return new ProjectConfig(properties);
        };

        /**
         * Encodes the specified ProjectConfig message. Does not implicitly {@link dataform.ProjectConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig} message ProjectConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProjectConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.warehouse);
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.defaultSchema);
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.assertionSchema);
            if (message.gcloudProjectId != null && message.hasOwnProperty("gcloudProjectId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.gcloudProjectId);
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.schemaSuffix);
            if (message.idempotentActionRetries != null && message.hasOwnProperty("idempotentActionRetries"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.idempotentActionRetries);
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.defaultDatabase);
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.useRunCache);
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.tablePrefix);
            if (message.concurrentQueryLimit != null && message.hasOwnProperty("concurrentQueryLimit"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.concurrentQueryLimit);
            if (message.vars != null && message.hasOwnProperty("vars"))
                for (let keys = Object.keys(message.vars), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.vars[keys[i]]).ldelim();
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.databaseSuffix);
            return writer;
        };

        /**
         * Encodes the specified ProjectConfig message, length delimited. Does not implicitly {@link dataform.ProjectConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig} message ProjectConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProjectConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProjectConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ProjectConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ProjectConfig} ProjectConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProjectConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ProjectConfig(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.warehouse = reader.string();
                    break;
                case 9:
                    message.defaultDatabase = reader.string();
                    break;
                case 2:
                    message.defaultSchema = reader.string();
                    break;
                case 5:
                    message.assertionSchema = reader.string();
                    break;
                case 14:
                    reader.skip().pos++;
                    if (message.vars === $util.emptyObject)
                        message.vars = {};
                    key = reader.string();
                    reader.pos++;
                    message.vars[key] = reader.string();
                    break;
                case 13:
                    message.concurrentQueryLimit = reader.int32();
                    break;
                case 8:
                    message.idempotentActionRetries = reader.int32();
                    break;
                case 15:
                    message.databaseSuffix = reader.string();
                    break;
                case 7:
                    message.schemaSuffix = reader.string();
                    break;
                case 11:
                    message.tablePrefix = reader.string();
                    break;
                case 10:
                    message.useRunCache = reader.bool();
                    break;
                case 6:
                    message.gcloudProjectId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProjectConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ProjectConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ProjectConfig} ProjectConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProjectConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProjectConfig message.
         * @function verify
         * @memberof dataform.ProjectConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProjectConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                if (!$util.isString(message.warehouse))
                    return "warehouse: string expected";
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                if (!$util.isString(message.defaultDatabase))
                    return "defaultDatabase: string expected";
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                if (!$util.isString(message.defaultSchema))
                    return "defaultSchema: string expected";
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                if (!$util.isString(message.assertionSchema))
                    return "assertionSchema: string expected";
            if (message.vars != null && message.hasOwnProperty("vars")) {
                if (!$util.isObject(message.vars))
                    return "vars: object expected";
                let key = Object.keys(message.vars);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.vars[key[i]]))
                        return "vars: string{k:string} expected";
            }
            if (message.concurrentQueryLimit != null && message.hasOwnProperty("concurrentQueryLimit"))
                if (!$util.isInteger(message.concurrentQueryLimit))
                    return "concurrentQueryLimit: integer expected";
            if (message.idempotentActionRetries != null && message.hasOwnProperty("idempotentActionRetries"))
                if (!$util.isInteger(message.idempotentActionRetries))
                    return "idempotentActionRetries: integer expected";
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                if (!$util.isString(message.databaseSuffix))
                    return "databaseSuffix: string expected";
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                if (!$util.isString(message.schemaSuffix))
                    return "schemaSuffix: string expected";
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                if (!$util.isString(message.tablePrefix))
                    return "tablePrefix: string expected";
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                if (typeof message.useRunCache !== "boolean")
                    return "useRunCache: boolean expected";
            if (message.gcloudProjectId != null && message.hasOwnProperty("gcloudProjectId"))
                if (!$util.isString(message.gcloudProjectId))
                    return "gcloudProjectId: string expected";
            return null;
        };

        /**
         * Creates a ProjectConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ProjectConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ProjectConfig} ProjectConfig
         */
        ProjectConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ProjectConfig)
                return object;
            let message = new $root.dataform.ProjectConfig();
            if (object.warehouse != null)
                message.warehouse = String(object.warehouse);
            if (object.defaultDatabase != null)
                message.defaultDatabase = String(object.defaultDatabase);
            if (object.defaultSchema != null)
                message.defaultSchema = String(object.defaultSchema);
            if (object.assertionSchema != null)
                message.assertionSchema = String(object.assertionSchema);
            if (object.vars) {
                if (typeof object.vars !== "object")
                    throw TypeError(".dataform.ProjectConfig.vars: object expected");
                message.vars = {};
                for (let keys = Object.keys(object.vars), i = 0; i < keys.length; ++i)
                    message.vars[keys[i]] = String(object.vars[keys[i]]);
            }
            if (object.concurrentQueryLimit != null)
                message.concurrentQueryLimit = object.concurrentQueryLimit | 0;
            if (object.idempotentActionRetries != null)
                message.idempotentActionRetries = object.idempotentActionRetries | 0;
            if (object.databaseSuffix != null)
                message.databaseSuffix = String(object.databaseSuffix);
            if (object.schemaSuffix != null)
                message.schemaSuffix = String(object.schemaSuffix);
            if (object.tablePrefix != null)
                message.tablePrefix = String(object.tablePrefix);
            if (object.useRunCache != null)
                message.useRunCache = Boolean(object.useRunCache);
            if (object.gcloudProjectId != null)
                message.gcloudProjectId = String(object.gcloudProjectId);
            return message;
        };

        /**
         * Creates a plain object from a ProjectConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.ProjectConfig} message ProjectConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProjectConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.vars = {};
            if (options.defaults) {
                object.warehouse = "";
                object.defaultSchema = "";
                object.assertionSchema = "";
                object.gcloudProjectId = "";
                object.schemaSuffix = "";
                object.idempotentActionRetries = 0;
                object.defaultDatabase = "";
                object.useRunCache = false;
                object.tablePrefix = "";
                object.concurrentQueryLimit = 0;
                object.databaseSuffix = "";
            }
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                object.warehouse = message.warehouse;
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                object.defaultSchema = message.defaultSchema;
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                object.assertionSchema = message.assertionSchema;
            if (message.gcloudProjectId != null && message.hasOwnProperty("gcloudProjectId"))
                object.gcloudProjectId = message.gcloudProjectId;
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                object.schemaSuffix = message.schemaSuffix;
            if (message.idempotentActionRetries != null && message.hasOwnProperty("idempotentActionRetries"))
                object.idempotentActionRetries = message.idempotentActionRetries;
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                object.defaultDatabase = message.defaultDatabase;
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                object.useRunCache = message.useRunCache;
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                object.tablePrefix = message.tablePrefix;
            if (message.concurrentQueryLimit != null && message.hasOwnProperty("concurrentQueryLimit"))
                object.concurrentQueryLimit = message.concurrentQueryLimit;
            let keys2;
            if (message.vars && (keys2 = Object.keys(message.vars)).length) {
                object.vars = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.vars[keys2[j]] = message.vars[keys2[j]];
            }
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                object.databaseSuffix = message.databaseSuffix;
            return object;
        };

        /**
         * Converts this ProjectConfig to JSON.
         * @function toJSON
         * @memberof dataform.ProjectConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProjectConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProjectConfig;
    })();

    dataform.Environments = (function() {

        /**
         * Properties of an Environments.
         * @memberof dataform
         * @interface IEnvironments
         * @property {Array.<dataform.Environments.IEnvironment>|null} [environments] Environments environments
         * @property {Array.<dataform.Environments.INotificationChannel>|null} [notificationChannels] Environments notificationChannels
         */

        /**
         * Constructs a new Environments.
         * @memberof dataform
         * @classdesc Represents an Environments.
         * @implements IEnvironments
         * @constructor
         * @param {dataform.IEnvironments=} [properties] Properties to set
         */
        function Environments(properties) {
            this.environments = [];
            this.notificationChannels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Environments environments.
         * @member {Array.<dataform.Environments.IEnvironment>} environments
         * @memberof dataform.Environments
         * @instance
         */
        Environments.prototype.environments = $util.emptyArray;

        /**
         * Environments notificationChannels.
         * @member {Array.<dataform.Environments.INotificationChannel>} notificationChannels
         * @memberof dataform.Environments
         * @instance
         */
        Environments.prototype.notificationChannels = $util.emptyArray;

        /**
         * Creates a new Environments instance using the specified properties.
         * @function create
         * @memberof dataform.Environments
         * @static
         * @param {dataform.IEnvironments=} [properties] Properties to set
         * @returns {dataform.Environments} Environments instance
         */
        Environments.create = function create(properties) {
            return new Environments(properties);
        };

        /**
         * Encodes the specified Environments message. Does not implicitly {@link dataform.Environments.verify|verify} messages.
         * @function encode
         * @memberof dataform.Environments
         * @static
         * @param {dataform.IEnvironments} message Environments message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Environments.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.environments != null && message.environments.length)
                for (let i = 0; i < message.environments.length; ++i)
                    $root.dataform.Environments.Environment.encode(message.environments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.notificationChannels != null && message.notificationChannels.length)
                for (let i = 0; i < message.notificationChannels.length; ++i)
                    $root.dataform.Environments.NotificationChannel.encode(message.notificationChannels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Environments message, length delimited. Does not implicitly {@link dataform.Environments.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Environments
         * @static
         * @param {dataform.IEnvironments} message Environments message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Environments.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Environments message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Environments
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Environments} Environments
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Environments.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.environments && message.environments.length))
                        message.environments = [];
                    message.environments.push($root.dataform.Environments.Environment.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.notificationChannels && message.notificationChannels.length))
                        message.notificationChannels = [];
                    message.notificationChannels.push($root.dataform.Environments.NotificationChannel.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Environments message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Environments
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Environments} Environments
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Environments.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Environments message.
         * @function verify
         * @memberof dataform.Environments
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Environments.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.environments != null && message.hasOwnProperty("environments")) {
                if (!Array.isArray(message.environments))
                    return "environments: array expected";
                for (let i = 0; i < message.environments.length; ++i) {
                    let error = $root.dataform.Environments.Environment.verify(message.environments[i]);
                    if (error)
                        return "environments." + error;
                }
            }
            if (message.notificationChannels != null && message.hasOwnProperty("notificationChannels")) {
                if (!Array.isArray(message.notificationChannels))
                    return "notificationChannels: array expected";
                for (let i = 0; i < message.notificationChannels.length; ++i) {
                    let error = $root.dataform.Environments.NotificationChannel.verify(message.notificationChannels[i]);
                    if (error)
                        return "notificationChannels." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Environments message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Environments
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Environments} Environments
         */
        Environments.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Environments)
                return object;
            let message = new $root.dataform.Environments();
            if (object.environments) {
                if (!Array.isArray(object.environments))
                    throw TypeError(".dataform.Environments.environments: array expected");
                message.environments = [];
                for (let i = 0; i < object.environments.length; ++i) {
                    if (typeof object.environments[i] !== "object")
                        throw TypeError(".dataform.Environments.environments: object expected");
                    message.environments[i] = $root.dataform.Environments.Environment.fromObject(object.environments[i]);
                }
            }
            if (object.notificationChannels) {
                if (!Array.isArray(object.notificationChannels))
                    throw TypeError(".dataform.Environments.notificationChannels: array expected");
                message.notificationChannels = [];
                for (let i = 0; i < object.notificationChannels.length; ++i) {
                    if (typeof object.notificationChannels[i] !== "object")
                        throw TypeError(".dataform.Environments.notificationChannels: object expected");
                    message.notificationChannels[i] = $root.dataform.Environments.NotificationChannel.fromObject(object.notificationChannels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Environments message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Environments
         * @static
         * @param {dataform.Environments} message Environments
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Environments.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.environments = [];
                object.notificationChannels = [];
            }
            if (message.environments && message.environments.length) {
                object.environments = [];
                for (let j = 0; j < message.environments.length; ++j)
                    object.environments[j] = $root.dataform.Environments.Environment.toObject(message.environments[j], options);
            }
            if (message.notificationChannels && message.notificationChannels.length) {
                object.notificationChannels = [];
                for (let j = 0; j < message.notificationChannels.length; ++j)
                    object.notificationChannels[j] = $root.dataform.Environments.NotificationChannel.toObject(message.notificationChannels[j], options);
            }
            return object;
        };

        /**
         * Converts this Environments to JSON.
         * @function toJSON
         * @memberof dataform.Environments
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Environments.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Environments.Environment = (function() {

            /**
             * Properties of an Environment.
             * @memberof dataform.Environments
             * @interface IEnvironment
             * @property {string|null} [name] Environment name
             * @property {string|null} [gitRef] Environment gitRef
             * @property {dataform.Environments.Environment.IGitReference|null} [gitReference] Environment gitReference
             * @property {dataform.IProjectConfig|null} [configOverride] Environment configOverride
             * @property {Array.<dataform.Environments.Environment.ISchedule>|null} [schedules] Environment schedules
             */

            /**
             * Constructs a new Environment.
             * @memberof dataform.Environments
             * @classdesc Represents an Environment.
             * @implements IEnvironment
             * @constructor
             * @param {dataform.Environments.IEnvironment=} [properties] Properties to set
             */
            function Environment(properties) {
                this.schedules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Environment name.
             * @member {string} name
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.name = "";

            /**
             * Environment gitRef.
             * @member {string} gitRef
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.gitRef = "";

            /**
             * Environment gitReference.
             * @member {dataform.Environments.Environment.IGitReference|null|undefined} gitReference
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.gitReference = null;

            /**
             * Environment configOverride.
             * @member {dataform.IProjectConfig|null|undefined} configOverride
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.configOverride = null;

            /**
             * Environment schedules.
             * @member {Array.<dataform.Environments.Environment.ISchedule>} schedules
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Environment.prototype.schedules = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Environment gitSettings.
             * @member {"gitRef"|"gitReference"|undefined} gitSettings
             * @memberof dataform.Environments.Environment
             * @instance
             */
            Object.defineProperty(Environment.prototype, "gitSettings", {
                get: $util.oneOfGetter($oneOfFields = ["gitRef", "gitReference"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Environment instance using the specified properties.
             * @function create
             * @memberof dataform.Environments.Environment
             * @static
             * @param {dataform.Environments.IEnvironment=} [properties] Properties to set
             * @returns {dataform.Environments.Environment} Environment instance
             */
            Environment.create = function create(properties) {
                return new Environment(properties);
            };

            /**
             * Encodes the specified Environment message. Does not implicitly {@link dataform.Environments.Environment.verify|verify} messages.
             * @function encode
             * @memberof dataform.Environments.Environment
             * @static
             * @param {dataform.Environments.IEnvironment} message Environment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Environment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.gitReference != null && message.hasOwnProperty("gitReference"))
                    $root.dataform.Environments.Environment.GitReference.encode(message.gitReference, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.configOverride != null && message.hasOwnProperty("configOverride"))
                    $root.dataform.ProjectConfig.encode(message.configOverride, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.schedules != null && message.schedules.length)
                    for (let i = 0; i < message.schedules.length; ++i)
                        $root.dataform.Environments.Environment.Schedule.encode(message.schedules[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.gitRef != null && message.hasOwnProperty("gitRef"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.gitRef);
                return writer;
            };

            /**
             * Encodes the specified Environment message, length delimited. Does not implicitly {@link dataform.Environments.Environment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.Environments.Environment
             * @static
             * @param {dataform.Environments.IEnvironment} message Environment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Environment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Environment message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.Environments.Environment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.Environments.Environment} Environment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Environment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 5:
                        message.gitRef = reader.string();
                        break;
                    case 2:
                        message.gitReference = $root.dataform.Environments.Environment.GitReference.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.configOverride = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.schedules && message.schedules.length))
                            message.schedules = [];
                        message.schedules.push($root.dataform.Environments.Environment.Schedule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Environment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.Environments.Environment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.Environments.Environment} Environment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Environment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Environment message.
             * @function verify
             * @memberof dataform.Environments.Environment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Environment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.gitRef != null && message.hasOwnProperty("gitRef")) {
                    properties.gitSettings = 1;
                    if (!$util.isString(message.gitRef))
                        return "gitRef: string expected";
                }
                if (message.gitReference != null && message.hasOwnProperty("gitReference")) {
                    if (properties.gitSettings === 1)
                        return "gitSettings: multiple values";
                    properties.gitSettings = 1;
                    {
                        let error = $root.dataform.Environments.Environment.GitReference.verify(message.gitReference);
                        if (error)
                            return "gitReference." + error;
                    }
                }
                if (message.configOverride != null && message.hasOwnProperty("configOverride")) {
                    let error = $root.dataform.ProjectConfig.verify(message.configOverride);
                    if (error)
                        return "configOverride." + error;
                }
                if (message.schedules != null && message.hasOwnProperty("schedules")) {
                    if (!Array.isArray(message.schedules))
                        return "schedules: array expected";
                    for (let i = 0; i < message.schedules.length; ++i) {
                        let error = $root.dataform.Environments.Environment.Schedule.verify(message.schedules[i]);
                        if (error)
                            return "schedules." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Environment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.Environments.Environment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.Environments.Environment} Environment
             */
            Environment.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.Environments.Environment)
                    return object;
                let message = new $root.dataform.Environments.Environment();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.gitRef != null)
                    message.gitRef = String(object.gitRef);
                if (object.gitReference != null) {
                    if (typeof object.gitReference !== "object")
                        throw TypeError(".dataform.Environments.Environment.gitReference: object expected");
                    message.gitReference = $root.dataform.Environments.Environment.GitReference.fromObject(object.gitReference);
                }
                if (object.configOverride != null) {
                    if (typeof object.configOverride !== "object")
                        throw TypeError(".dataform.Environments.Environment.configOverride: object expected");
                    message.configOverride = $root.dataform.ProjectConfig.fromObject(object.configOverride);
                }
                if (object.schedules) {
                    if (!Array.isArray(object.schedules))
                        throw TypeError(".dataform.Environments.Environment.schedules: array expected");
                    message.schedules = [];
                    for (let i = 0; i < object.schedules.length; ++i) {
                        if (typeof object.schedules[i] !== "object")
                            throw TypeError(".dataform.Environments.Environment.schedules: object expected");
                        message.schedules[i] = $root.dataform.Environments.Environment.Schedule.fromObject(object.schedules[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Environment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.Environments.Environment
             * @static
             * @param {dataform.Environments.Environment} message Environment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Environment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.schedules = [];
                if (options.defaults) {
                    object.name = "";
                    object.configOverride = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.gitReference != null && message.hasOwnProperty("gitReference")) {
                    object.gitReference = $root.dataform.Environments.Environment.GitReference.toObject(message.gitReference, options);
                    if (options.oneofs)
                        object.gitSettings = "gitReference";
                }
                if (message.configOverride != null && message.hasOwnProperty("configOverride"))
                    object.configOverride = $root.dataform.ProjectConfig.toObject(message.configOverride, options);
                if (message.schedules && message.schedules.length) {
                    object.schedules = [];
                    for (let j = 0; j < message.schedules.length; ++j)
                        object.schedules[j] = $root.dataform.Environments.Environment.Schedule.toObject(message.schedules[j], options);
                }
                if (message.gitRef != null && message.hasOwnProperty("gitRef")) {
                    object.gitRef = message.gitRef;
                    if (options.oneofs)
                        object.gitSettings = "gitRef";
                }
                return object;
            };

            /**
             * Converts this Environment to JSON.
             * @function toJSON
             * @memberof dataform.Environments.Environment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Environment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Environment.GitReference = (function() {

                /**
                 * Properties of a GitReference.
                 * @memberof dataform.Environments.Environment
                 * @interface IGitReference
                 * @property {string|null} [branch] GitReference branch
                 * @property {string|null} [commitSha] GitReference commitSha
                 */

                /**
                 * Constructs a new GitReference.
                 * @memberof dataform.Environments.Environment
                 * @classdesc Represents a GitReference.
                 * @implements IGitReference
                 * @constructor
                 * @param {dataform.Environments.Environment.IGitReference=} [properties] Properties to set
                 */
                function GitReference(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GitReference branch.
                 * @member {string} branch
                 * @memberof dataform.Environments.Environment.GitReference
                 * @instance
                 */
                GitReference.prototype.branch = "";

                /**
                 * GitReference commitSha.
                 * @member {string} commitSha
                 * @memberof dataform.Environments.Environment.GitReference
                 * @instance
                 */
                GitReference.prototype.commitSha = "";

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * GitReference gitReference.
                 * @member {"branch"|"commitSha"|undefined} gitReference
                 * @memberof dataform.Environments.Environment.GitReference
                 * @instance
                 */
                Object.defineProperty(GitReference.prototype, "gitReference", {
                    get: $util.oneOfGetter($oneOfFields = ["branch", "commitSha"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new GitReference instance using the specified properties.
                 * @function create
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {dataform.Environments.Environment.IGitReference=} [properties] Properties to set
                 * @returns {dataform.Environments.Environment.GitReference} GitReference instance
                 */
                GitReference.create = function create(properties) {
                    return new GitReference(properties);
                };

                /**
                 * Encodes the specified GitReference message. Does not implicitly {@link dataform.Environments.Environment.GitReference.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {dataform.Environments.Environment.IGitReference} message GitReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GitReference.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.branch != null && message.hasOwnProperty("branch"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.branch);
                    if (message.commitSha != null && message.hasOwnProperty("commitSha"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.commitSha);
                    return writer;
                };

                /**
                 * Encodes the specified GitReference message, length delimited. Does not implicitly {@link dataform.Environments.Environment.GitReference.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {dataform.Environments.Environment.IGitReference} message GitReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GitReference.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GitReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.Environments.Environment.GitReference} GitReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GitReference.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment.GitReference();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.branch = reader.string();
                            break;
                        case 2:
                            message.commitSha = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GitReference message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.Environments.Environment.GitReference} GitReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GitReference.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GitReference message.
                 * @function verify
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GitReference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.branch != null && message.hasOwnProperty("branch")) {
                        properties.gitReference = 1;
                        if (!$util.isString(message.branch))
                            return "branch: string expected";
                    }
                    if (message.commitSha != null && message.hasOwnProperty("commitSha")) {
                        if (properties.gitReference === 1)
                            return "gitReference: multiple values";
                        properties.gitReference = 1;
                        if (!$util.isString(message.commitSha))
                            return "commitSha: string expected";
                    }
                    return null;
                };

                /**
                 * Creates a GitReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.Environments.Environment.GitReference} GitReference
                 */
                GitReference.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.Environments.Environment.GitReference)
                        return object;
                    let message = new $root.dataform.Environments.Environment.GitReference();
                    if (object.branch != null)
                        message.branch = String(object.branch);
                    if (object.commitSha != null)
                        message.commitSha = String(object.commitSha);
                    return message;
                };

                /**
                 * Creates a plain object from a GitReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.Environments.Environment.GitReference
                 * @static
                 * @param {dataform.Environments.Environment.GitReference} message GitReference
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GitReference.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.branch != null && message.hasOwnProperty("branch")) {
                        object.branch = message.branch;
                        if (options.oneofs)
                            object.gitReference = "branch";
                    }
                    if (message.commitSha != null && message.hasOwnProperty("commitSha")) {
                        object.commitSha = message.commitSha;
                        if (options.oneofs)
                            object.gitReference = "commitSha";
                    }
                    return object;
                };

                /**
                 * Converts this GitReference to JSON.
                 * @function toJSON
                 * @memberof dataform.Environments.Environment.GitReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GitReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GitReference;
            })();

            Environment.Schedule = (function() {

                /**
                 * Properties of a Schedule.
                 * @memberof dataform.Environments.Environment
                 * @interface ISchedule
                 * @property {string|null} [name] Schedule name
                 * @property {string|null} [cron] Schedule cron
                 * @property {Array.<string>|null} [tags] Schedule tags
                 * @property {dataform.Environments.Environment.Schedule.IOptions|null} [options] Schedule options
                 * @property {boolean|null} [disabled] Schedule disabled
                 * @property {Array.<dataform.Environments.Environment.Schedule.INotificationRequirement>|null} [notify] Schedule notify
                 */

                /**
                 * Constructs a new Schedule.
                 * @memberof dataform.Environments.Environment
                 * @classdesc Represents a Schedule.
                 * @implements ISchedule
                 * @constructor
                 * @param {dataform.Environments.Environment.ISchedule=} [properties] Properties to set
                 */
                function Schedule(properties) {
                    this.tags = [];
                    this.notify = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Schedule name.
                 * @member {string} name
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.name = "";

                /**
                 * Schedule cron.
                 * @member {string} cron
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.cron = "";

                /**
                 * Schedule tags.
                 * @member {Array.<string>} tags
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.tags = $util.emptyArray;

                /**
                 * Schedule options.
                 * @member {dataform.Environments.Environment.Schedule.IOptions|null|undefined} options
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.options = null;

                /**
                 * Schedule disabled.
                 * @member {boolean} disabled
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.disabled = false;

                /**
                 * Schedule notify.
                 * @member {Array.<dataform.Environments.Environment.Schedule.INotificationRequirement>} notify
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 */
                Schedule.prototype.notify = $util.emptyArray;

                /**
                 * Creates a new Schedule instance using the specified properties.
                 * @function create
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {dataform.Environments.Environment.ISchedule=} [properties] Properties to set
                 * @returns {dataform.Environments.Environment.Schedule} Schedule instance
                 */
                Schedule.create = function create(properties) {
                    return new Schedule(properties);
                };

                /**
                 * Encodes the specified Schedule message. Does not implicitly {@link dataform.Environments.Environment.Schedule.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {dataform.Environments.Environment.ISchedule} message Schedule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Schedule.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.cron != null && message.hasOwnProperty("cron"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.cron);
                    if (message.tags != null && message.tags.length)
                        for (let i = 0; i < message.tags.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tags[i]);
                    if (message.options != null && message.hasOwnProperty("options"))
                        $root.dataform.Environments.Environment.Schedule.Options.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.disabled != null && message.hasOwnProperty("disabled"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.disabled);
                    if (message.notify != null && message.notify.length)
                        for (let i = 0; i < message.notify.length; ++i)
                            $root.dataform.Environments.Environment.Schedule.NotificationRequirement.encode(message.notify[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Schedule message, length delimited. Does not implicitly {@link dataform.Environments.Environment.Schedule.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {dataform.Environments.Environment.ISchedule} message Schedule message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Schedule.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Schedule message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.Environments.Environment.Schedule} Schedule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Schedule.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment.Schedule();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.cron = reader.string();
                            break;
                        case 3:
                            if (!(message.tags && message.tags.length))
                                message.tags = [];
                            message.tags.push(reader.string());
                            break;
                        case 4:
                            message.options = $root.dataform.Environments.Environment.Schedule.Options.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.disabled = reader.bool();
                            break;
                        case 6:
                            if (!(message.notify && message.notify.length))
                                message.notify = [];
                            message.notify.push($root.dataform.Environments.Environment.Schedule.NotificationRequirement.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Schedule message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.Environments.Environment.Schedule} Schedule
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Schedule.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Schedule message.
                 * @function verify
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Schedule.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.cron != null && message.hasOwnProperty("cron"))
                        if (!$util.isString(message.cron))
                            return "cron: string expected";
                    if (message.tags != null && message.hasOwnProperty("tags")) {
                        if (!Array.isArray(message.tags))
                            return "tags: array expected";
                        for (let i = 0; i < message.tags.length; ++i)
                            if (!$util.isString(message.tags[i]))
                                return "tags: string[] expected";
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.dataform.Environments.Environment.Schedule.Options.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.disabled != null && message.hasOwnProperty("disabled"))
                        if (typeof message.disabled !== "boolean")
                            return "disabled: boolean expected";
                    if (message.notify != null && message.hasOwnProperty("notify")) {
                        if (!Array.isArray(message.notify))
                            return "notify: array expected";
                        for (let i = 0; i < message.notify.length; ++i) {
                            let error = $root.dataform.Environments.Environment.Schedule.NotificationRequirement.verify(message.notify[i]);
                            if (error)
                                return "notify." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Schedule message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.Environments.Environment.Schedule} Schedule
                 */
                Schedule.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.Environments.Environment.Schedule)
                        return object;
                    let message = new $root.dataform.Environments.Environment.Schedule();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.cron != null)
                        message.cron = String(object.cron);
                    if (object.tags) {
                        if (!Array.isArray(object.tags))
                            throw TypeError(".dataform.Environments.Environment.Schedule.tags: array expected");
                        message.tags = [];
                        for (let i = 0; i < object.tags.length; ++i)
                            message.tags[i] = String(object.tags[i]);
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".dataform.Environments.Environment.Schedule.options: object expected");
                        message.options = $root.dataform.Environments.Environment.Schedule.Options.fromObject(object.options);
                    }
                    if (object.disabled != null)
                        message.disabled = Boolean(object.disabled);
                    if (object.notify) {
                        if (!Array.isArray(object.notify))
                            throw TypeError(".dataform.Environments.Environment.Schedule.notify: array expected");
                        message.notify = [];
                        for (let i = 0; i < object.notify.length; ++i) {
                            if (typeof object.notify[i] !== "object")
                                throw TypeError(".dataform.Environments.Environment.Schedule.notify: object expected");
                            message.notify[i] = $root.dataform.Environments.Environment.Schedule.NotificationRequirement.fromObject(object.notify[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Schedule message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.Environments.Environment.Schedule
                 * @static
                 * @param {dataform.Environments.Environment.Schedule} message Schedule
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Schedule.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.tags = [];
                        object.notify = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.cron = "";
                        object.options = null;
                        object.disabled = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.cron != null && message.hasOwnProperty("cron"))
                        object.cron = message.cron;
                    if (message.tags && message.tags.length) {
                        object.tags = [];
                        for (let j = 0; j < message.tags.length; ++j)
                            object.tags[j] = message.tags[j];
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.dataform.Environments.Environment.Schedule.Options.toObject(message.options, options);
                    if (message.disabled != null && message.hasOwnProperty("disabled"))
                        object.disabled = message.disabled;
                    if (message.notify && message.notify.length) {
                        object.notify = [];
                        for (let j = 0; j < message.notify.length; ++j)
                            object.notify[j] = $root.dataform.Environments.Environment.Schedule.NotificationRequirement.toObject(message.notify[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Schedule to JSON.
                 * @function toJSON
                 * @memberof dataform.Environments.Environment.Schedule
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Schedule.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Schedule.Options = (function() {

                    /**
                     * Properties of an Options.
                     * @memberof dataform.Environments.Environment.Schedule
                     * @interface IOptions
                     * @property {boolean|null} [includeDependencies] Options includeDependencies
                     * @property {boolean|null} [includeDependents] Options includeDependents
                     * @property {boolean|null} [fullRefresh] Options fullRefresh
                     */

                    /**
                     * Constructs a new Options.
                     * @memberof dataform.Environments.Environment.Schedule
                     * @classdesc Represents an Options.
                     * @implements IOptions
                     * @constructor
                     * @param {dataform.Environments.Environment.Schedule.IOptions=} [properties] Properties to set
                     */
                    function Options(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Options includeDependencies.
                     * @member {boolean} includeDependencies
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @instance
                     */
                    Options.prototype.includeDependencies = false;

                    /**
                     * Options includeDependents.
                     * @member {boolean} includeDependents
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @instance
                     */
                    Options.prototype.includeDependents = false;

                    /**
                     * Options fullRefresh.
                     * @member {boolean} fullRefresh
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @instance
                     */
                    Options.prototype.fullRefresh = false;

                    /**
                     * Creates a new Options instance using the specified properties.
                     * @function create
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.IOptions=} [properties] Properties to set
                     * @returns {dataform.Environments.Environment.Schedule.Options} Options instance
                     */
                    Options.create = function create(properties) {
                        return new Options(properties);
                    };

                    /**
                     * Encodes the specified Options message. Does not implicitly {@link dataform.Environments.Environment.Schedule.Options.verify|verify} messages.
                     * @function encode
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.IOptions} message Options message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Options.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includeDependencies);
                        if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fullRefresh);
                        if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.includeDependents);
                        return writer;
                    };

                    /**
                     * Encodes the specified Options message, length delimited. Does not implicitly {@link dataform.Environments.Environment.Schedule.Options.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.IOptions} message Options message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Options.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Options message from the specified reader or buffer.
                     * @function decode
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {dataform.Environments.Environment.Schedule.Options} Options
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Options.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment.Schedule.Options();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 4:
                                message.includeDependencies = reader.bool();
                                break;
                            case 6:
                                message.includeDependents = reader.bool();
                                break;
                            case 5:
                                message.fullRefresh = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Options message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {dataform.Environments.Environment.Schedule.Options} Options
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Options.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Options message.
                     * @function verify
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Options.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                            if (typeof message.includeDependencies !== "boolean")
                                return "includeDependencies: boolean expected";
                        if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                            if (typeof message.includeDependents !== "boolean")
                                return "includeDependents: boolean expected";
                        if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                            if (typeof message.fullRefresh !== "boolean")
                                return "fullRefresh: boolean expected";
                        return null;
                    };

                    /**
                     * Creates an Options message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {dataform.Environments.Environment.Schedule.Options} Options
                     */
                    Options.fromObject = function fromObject(object) {
                        if (object instanceof $root.dataform.Environments.Environment.Schedule.Options)
                            return object;
                        let message = new $root.dataform.Environments.Environment.Schedule.Options();
                        if (object.includeDependencies != null)
                            message.includeDependencies = Boolean(object.includeDependencies);
                        if (object.includeDependents != null)
                            message.includeDependents = Boolean(object.includeDependents);
                        if (object.fullRefresh != null)
                            message.fullRefresh = Boolean(object.fullRefresh);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Options message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.Options} message Options
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Options.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.includeDependencies = false;
                            object.fullRefresh = false;
                            object.includeDependents = false;
                        }
                        if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                            object.includeDependencies = message.includeDependencies;
                        if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                            object.fullRefresh = message.fullRefresh;
                        if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                            object.includeDependents = message.includeDependents;
                        return object;
                    };

                    /**
                     * Converts this Options to JSON.
                     * @function toJSON
                     * @memberof dataform.Environments.Environment.Schedule.Options
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Options.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Options;
                })();

                Schedule.NotificationRequirement = (function() {

                    /**
                     * Properties of a NotificationRequirement.
                     * @memberof dataform.Environments.Environment.Schedule
                     * @interface INotificationRequirement
                     * @property {string|null} [channel] NotificationRequirement channel
                     * @property {Array.<dataform.Environments.Environment.Schedule.NotificationRequirement.CompletionStatus>|null} [statuses] NotificationRequirement statuses
                     */

                    /**
                     * Constructs a new NotificationRequirement.
                     * @memberof dataform.Environments.Environment.Schedule
                     * @classdesc Represents a NotificationRequirement.
                     * @implements INotificationRequirement
                     * @constructor
                     * @param {dataform.Environments.Environment.Schedule.INotificationRequirement=} [properties] Properties to set
                     */
                    function NotificationRequirement(properties) {
                        this.statuses = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * NotificationRequirement channel.
                     * @member {string} channel
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @instance
                     */
                    NotificationRequirement.prototype.channel = "";

                    /**
                     * NotificationRequirement statuses.
                     * @member {Array.<dataform.Environments.Environment.Schedule.NotificationRequirement.CompletionStatus>} statuses
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @instance
                     */
                    NotificationRequirement.prototype.statuses = $util.emptyArray;

                    /**
                     * Creates a new NotificationRequirement instance using the specified properties.
                     * @function create
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.INotificationRequirement=} [properties] Properties to set
                     * @returns {dataform.Environments.Environment.Schedule.NotificationRequirement} NotificationRequirement instance
                     */
                    NotificationRequirement.create = function create(properties) {
                        return new NotificationRequirement(properties);
                    };

                    /**
                     * Encodes the specified NotificationRequirement message. Does not implicitly {@link dataform.Environments.Environment.Schedule.NotificationRequirement.verify|verify} messages.
                     * @function encode
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.INotificationRequirement} message NotificationRequirement message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NotificationRequirement.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                        if (message.statuses != null && message.statuses.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (let i = 0; i < message.statuses.length; ++i)
                                writer.int32(message.statuses[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };

                    /**
                     * Encodes the specified NotificationRequirement message, length delimited. Does not implicitly {@link dataform.Environments.Environment.Schedule.NotificationRequirement.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.INotificationRequirement} message NotificationRequirement message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NotificationRequirement.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a NotificationRequirement message from the specified reader or buffer.
                     * @function decode
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {dataform.Environments.Environment.Schedule.NotificationRequirement} NotificationRequirement
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NotificationRequirement.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.Environment.Schedule.NotificationRequirement();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.channel = reader.string();
                                break;
                            case 2:
                                if (!(message.statuses && message.statuses.length))
                                    message.statuses = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.statuses.push(reader.int32());
                                } else
                                    message.statuses.push(reader.int32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a NotificationRequirement message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {dataform.Environments.Environment.Schedule.NotificationRequirement} NotificationRequirement
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NotificationRequirement.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a NotificationRequirement message.
                     * @function verify
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NotificationRequirement.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            if (!$util.isString(message.channel))
                                return "channel: string expected";
                        if (message.statuses != null && message.hasOwnProperty("statuses")) {
                            if (!Array.isArray(message.statuses))
                                return "statuses: array expected";
                            for (let i = 0; i < message.statuses.length; ++i)
                                switch (message.statuses[i]) {
                                default:
                                    return "statuses: enum value[] expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                        }
                        return null;
                    };

                    /**
                     * Creates a NotificationRequirement message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {dataform.Environments.Environment.Schedule.NotificationRequirement} NotificationRequirement
                     */
                    NotificationRequirement.fromObject = function fromObject(object) {
                        if (object instanceof $root.dataform.Environments.Environment.Schedule.NotificationRequirement)
                            return object;
                        let message = new $root.dataform.Environments.Environment.Schedule.NotificationRequirement();
                        if (object.channel != null)
                            message.channel = String(object.channel);
                        if (object.statuses) {
                            if (!Array.isArray(object.statuses))
                                throw TypeError(".dataform.Environments.Environment.Schedule.NotificationRequirement.statuses: array expected");
                            message.statuses = [];
                            for (let i = 0; i < object.statuses.length; ++i)
                                switch (object.statuses[i]) {
                                default:
                                case "UNKNOWN":
                                case 0:
                                    message.statuses[i] = 0;
                                    break;
                                case "SUCCESS":
                                case 1:
                                    message.statuses[i] = 1;
                                    break;
                                case "FAILURE":
                                case 2:
                                    message.statuses[i] = 2;
                                    break;
                                }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a NotificationRequirement message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @static
                     * @param {dataform.Environments.Environment.Schedule.NotificationRequirement} message NotificationRequirement
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NotificationRequirement.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.statuses = [];
                        if (options.defaults)
                            object.channel = "";
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            object.channel = message.channel;
                        if (message.statuses && message.statuses.length) {
                            object.statuses = [];
                            for (let j = 0; j < message.statuses.length; ++j)
                                object.statuses[j] = options.enums === String ? $root.dataform.Environments.Environment.Schedule.NotificationRequirement.CompletionStatus[message.statuses[j]] : message.statuses[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this NotificationRequirement to JSON.
                     * @function toJSON
                     * @memberof dataform.Environments.Environment.Schedule.NotificationRequirement
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NotificationRequirement.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * CompletionStatus enum.
                     * @name dataform.Environments.Environment.Schedule.NotificationRequirement.CompletionStatus
                     * @enum {string}
                     * @property {number} UNKNOWN=0 UNKNOWN value
                     * @property {number} SUCCESS=1 SUCCESS value
                     * @property {number} FAILURE=2 FAILURE value
                     */
                    NotificationRequirement.CompletionStatus = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNKNOWN"] = 0;
                        values[valuesById[1] = "SUCCESS"] = 1;
                        values[valuesById[2] = "FAILURE"] = 2;
                        return values;
                    })();

                    return NotificationRequirement;
                })();

                return Schedule;
            })();

            return Environment;
        })();

        Environments.NotificationChannel = (function() {

            /**
             * Properties of a NotificationChannel.
             * @memberof dataform.Environments
             * @interface INotificationChannel
             * @property {string|null} [name] NotificationChannel name
             * @property {dataform.Environments.NotificationChannel.IEmailNotificationChannel|null} [email] NotificationChannel email
             * @property {dataform.Environments.NotificationChannel.ISlackNotificationChannel|null} [slack] NotificationChannel slack
             */

            /**
             * Constructs a new NotificationChannel.
             * @memberof dataform.Environments
             * @classdesc Represents a NotificationChannel.
             * @implements INotificationChannel
             * @constructor
             * @param {dataform.Environments.INotificationChannel=} [properties] Properties to set
             */
            function NotificationChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotificationChannel name.
             * @member {string} name
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.name = "";

            /**
             * NotificationChannel email.
             * @member {dataform.Environments.NotificationChannel.IEmailNotificationChannel|null|undefined} email
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.email = null;

            /**
             * NotificationChannel slack.
             * @member {dataform.Environments.NotificationChannel.ISlackNotificationChannel|null|undefined} slack
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.slack = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NotificationChannel channel.
             * @member {"email"|"slack"|undefined} channel
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             */
            Object.defineProperty(NotificationChannel.prototype, "channel", {
                get: $util.oneOfGetter($oneOfFields = ["email", "slack"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NotificationChannel instance using the specified properties.
             * @function create
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {dataform.Environments.INotificationChannel=} [properties] Properties to set
             * @returns {dataform.Environments.NotificationChannel} NotificationChannel instance
             */
            NotificationChannel.create = function create(properties) {
                return new NotificationChannel(properties);
            };

            /**
             * Encodes the specified NotificationChannel message. Does not implicitly {@link dataform.Environments.NotificationChannel.verify|verify} messages.
             * @function encode
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {dataform.Environments.INotificationChannel} message NotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.email != null && message.hasOwnProperty("email"))
                    $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.encode(message.email, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.slack != null && message.hasOwnProperty("slack"))
                    $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.encode(message.slack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NotificationChannel message, length delimited. Does not implicitly {@link dataform.Environments.NotificationChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {dataform.Environments.INotificationChannel} message NotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotificationChannel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.Environments.NotificationChannel} NotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.NotificationChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.email = $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.slack = $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotificationChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.Environments.NotificationChannel} NotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotificationChannel message.
             * @function verify
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotificationChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties.channel = 1;
                    {
                        let error = $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.verify(message.email);
                        if (error)
                            return "email." + error;
                    }
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    if (properties.channel === 1)
                        return "channel: multiple values";
                    properties.channel = 1;
                    {
                        let error = $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.verify(message.slack);
                        if (error)
                            return "slack." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NotificationChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.Environments.NotificationChannel} NotificationChannel
             */
            NotificationChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.Environments.NotificationChannel)
                    return object;
                let message = new $root.dataform.Environments.NotificationChannel();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.email != null) {
                    if (typeof object.email !== "object")
                        throw TypeError(".dataform.Environments.NotificationChannel.email: object expected");
                    message.email = $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.fromObject(object.email);
                }
                if (object.slack != null) {
                    if (typeof object.slack !== "object")
                        throw TypeError(".dataform.Environments.NotificationChannel.slack: object expected");
                    message.slack = $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.fromObject(object.slack);
                }
                return message;
            };

            /**
             * Creates a plain object from a NotificationChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.Environments.NotificationChannel
             * @static
             * @param {dataform.Environments.NotificationChannel} message NotificationChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotificationChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.email != null && message.hasOwnProperty("email")) {
                    object.email = $root.dataform.Environments.NotificationChannel.EmailNotificationChannel.toObject(message.email, options);
                    if (options.oneofs)
                        object.channel = "email";
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    object.slack = $root.dataform.Environments.NotificationChannel.SlackNotificationChannel.toObject(message.slack, options);
                    if (options.oneofs)
                        object.channel = "slack";
                }
                return object;
            };

            /**
             * Converts this NotificationChannel to JSON.
             * @function toJSON
             * @memberof dataform.Environments.NotificationChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotificationChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            NotificationChannel.EmailNotificationChannel = (function() {

                /**
                 * Properties of an EmailNotificationChannel.
                 * @memberof dataform.Environments.NotificationChannel
                 * @interface IEmailNotificationChannel
                 * @property {Array.<string>|null} [to] EmailNotificationChannel to
                 */

                /**
                 * Constructs a new EmailNotificationChannel.
                 * @memberof dataform.Environments.NotificationChannel
                 * @classdesc Represents an EmailNotificationChannel.
                 * @implements IEmailNotificationChannel
                 * @constructor
                 * @param {dataform.Environments.NotificationChannel.IEmailNotificationChannel=} [properties] Properties to set
                 */
                function EmailNotificationChannel(properties) {
                    this.to = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EmailNotificationChannel to.
                 * @member {Array.<string>} to
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @instance
                 */
                EmailNotificationChannel.prototype.to = $util.emptyArray;

                /**
                 * Creates a new EmailNotificationChannel instance using the specified properties.
                 * @function create
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.IEmailNotificationChannel=} [properties] Properties to set
                 * @returns {dataform.Environments.NotificationChannel.EmailNotificationChannel} EmailNotificationChannel instance
                 */
                EmailNotificationChannel.create = function create(properties) {
                    return new EmailNotificationChannel(properties);
                };

                /**
                 * Encodes the specified EmailNotificationChannel message. Does not implicitly {@link dataform.Environments.NotificationChannel.EmailNotificationChannel.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.IEmailNotificationChannel} message EmailNotificationChannel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmailNotificationChannel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.to != null && message.to.length)
                        for (let i = 0; i < message.to.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.to[i]);
                    return writer;
                };

                /**
                 * Encodes the specified EmailNotificationChannel message, length delimited. Does not implicitly {@link dataform.Environments.NotificationChannel.EmailNotificationChannel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.IEmailNotificationChannel} message EmailNotificationChannel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmailNotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EmailNotificationChannel message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.Environments.NotificationChannel.EmailNotificationChannel} EmailNotificationChannel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmailNotificationChannel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.NotificationChannel.EmailNotificationChannel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.to && message.to.length))
                                message.to = [];
                            message.to.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EmailNotificationChannel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.Environments.NotificationChannel.EmailNotificationChannel} EmailNotificationChannel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmailNotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EmailNotificationChannel message.
                 * @function verify
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EmailNotificationChannel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.to != null && message.hasOwnProperty("to")) {
                        if (!Array.isArray(message.to))
                            return "to: array expected";
                        for (let i = 0; i < message.to.length; ++i)
                            if (!$util.isString(message.to[i]))
                                return "to: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates an EmailNotificationChannel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.Environments.NotificationChannel.EmailNotificationChannel} EmailNotificationChannel
                 */
                EmailNotificationChannel.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.Environments.NotificationChannel.EmailNotificationChannel)
                        return object;
                    let message = new $root.dataform.Environments.NotificationChannel.EmailNotificationChannel();
                    if (object.to) {
                        if (!Array.isArray(object.to))
                            throw TypeError(".dataform.Environments.NotificationChannel.EmailNotificationChannel.to: array expected");
                        message.to = [];
                        for (let i = 0; i < object.to.length; ++i)
                            message.to[i] = String(object.to[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an EmailNotificationChannel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.EmailNotificationChannel} message EmailNotificationChannel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EmailNotificationChannel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.to = [];
                    if (message.to && message.to.length) {
                        object.to = [];
                        for (let j = 0; j < message.to.length; ++j)
                            object.to[j] = message.to[j];
                    }
                    return object;
                };

                /**
                 * Converts this EmailNotificationChannel to JSON.
                 * @function toJSON
                 * @memberof dataform.Environments.NotificationChannel.EmailNotificationChannel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EmailNotificationChannel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EmailNotificationChannel;
            })();

            NotificationChannel.SlackNotificationChannel = (function() {

                /**
                 * Properties of a SlackNotificationChannel.
                 * @memberof dataform.Environments.NotificationChannel
                 * @interface ISlackNotificationChannel
                 * @property {string|null} [webhookUrl] SlackNotificationChannel webhookUrl
                 */

                /**
                 * Constructs a new SlackNotificationChannel.
                 * @memberof dataform.Environments.NotificationChannel
                 * @classdesc Represents a SlackNotificationChannel.
                 * @implements ISlackNotificationChannel
                 * @constructor
                 * @param {dataform.Environments.NotificationChannel.ISlackNotificationChannel=} [properties] Properties to set
                 */
                function SlackNotificationChannel(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SlackNotificationChannel webhookUrl.
                 * @member {string} webhookUrl
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @instance
                 */
                SlackNotificationChannel.prototype.webhookUrl = "";

                /**
                 * Creates a new SlackNotificationChannel instance using the specified properties.
                 * @function create
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.ISlackNotificationChannel=} [properties] Properties to set
                 * @returns {dataform.Environments.NotificationChannel.SlackNotificationChannel} SlackNotificationChannel instance
                 */
                SlackNotificationChannel.create = function create(properties) {
                    return new SlackNotificationChannel(properties);
                };

                /**
                 * Encodes the specified SlackNotificationChannel message. Does not implicitly {@link dataform.Environments.NotificationChannel.SlackNotificationChannel.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.ISlackNotificationChannel} message SlackNotificationChannel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlackNotificationChannel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.webhookUrl);
                    return writer;
                };

                /**
                 * Encodes the specified SlackNotificationChannel message, length delimited. Does not implicitly {@link dataform.Environments.NotificationChannel.SlackNotificationChannel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.ISlackNotificationChannel} message SlackNotificationChannel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SlackNotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SlackNotificationChannel message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.Environments.NotificationChannel.SlackNotificationChannel} SlackNotificationChannel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlackNotificationChannel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Environments.NotificationChannel.SlackNotificationChannel();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.webhookUrl = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SlackNotificationChannel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.Environments.NotificationChannel.SlackNotificationChannel} SlackNotificationChannel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SlackNotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SlackNotificationChannel message.
                 * @function verify
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SlackNotificationChannel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                        if (!$util.isString(message.webhookUrl))
                            return "webhookUrl: string expected";
                    return null;
                };

                /**
                 * Creates a SlackNotificationChannel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.Environments.NotificationChannel.SlackNotificationChannel} SlackNotificationChannel
                 */
                SlackNotificationChannel.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.Environments.NotificationChannel.SlackNotificationChannel)
                        return object;
                    let message = new $root.dataform.Environments.NotificationChannel.SlackNotificationChannel();
                    if (object.webhookUrl != null)
                        message.webhookUrl = String(object.webhookUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a SlackNotificationChannel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @static
                 * @param {dataform.Environments.NotificationChannel.SlackNotificationChannel} message SlackNotificationChannel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SlackNotificationChannel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.webhookUrl = "";
                    if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                        object.webhookUrl = message.webhookUrl;
                    return object;
                };

                /**
                 * Converts this SlackNotificationChannel to JSON.
                 * @function toJSON
                 * @memberof dataform.Environments.NotificationChannel.SlackNotificationChannel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SlackNotificationChannel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SlackNotificationChannel;
            })();

            return NotificationChannel;
        })();

        return Environments;
    })();

    dataform.RunConfig = (function() {

        /**
         * Properties of a RunConfig.
         * @memberof dataform
         * @interface IRunConfig
         * @property {Array.<string>|null} [actions] RunConfig actions
         * @property {Array.<string>|null} [tags] RunConfig tags
         * @property {boolean|null} [includeDependencies] RunConfig includeDependencies
         * @property {boolean|null} [includeDependents] RunConfig includeDependents
         * @property {boolean|null} [fullRefresh] RunConfig fullRefresh
         * @property {number|null} [timeoutMillis] RunConfig timeoutMillis
         * @property {boolean|null} [useRunCache] RunConfig useRunCache
         * @property {boolean|null} [disableSetMetadata] RunConfig disableSetMetadata
         */

        /**
         * Constructs a new RunConfig.
         * @memberof dataform
         * @classdesc Represents a RunConfig.
         * @implements IRunConfig
         * @constructor
         * @param {dataform.IRunConfig=} [properties] Properties to set
         */
        function RunConfig(properties) {
            this.actions = [];
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RunConfig actions.
         * @member {Array.<string>} actions
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.actions = $util.emptyArray;

        /**
         * RunConfig tags.
         * @member {Array.<string>} tags
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.tags = $util.emptyArray;

        /**
         * RunConfig includeDependencies.
         * @member {boolean} includeDependencies
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.includeDependencies = false;

        /**
         * RunConfig includeDependents.
         * @member {boolean} includeDependents
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.includeDependents = false;

        /**
         * RunConfig fullRefresh.
         * @member {boolean} fullRefresh
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.fullRefresh = false;

        /**
         * RunConfig timeoutMillis.
         * @member {number} timeoutMillis
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.timeoutMillis = 0;

        /**
         * RunConfig useRunCache.
         * @member {boolean} useRunCache
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.useRunCache = false;

        /**
         * RunConfig disableSetMetadata.
         * @member {boolean} disableSetMetadata
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.disableSetMetadata = false;

        /**
         * Creates a new RunConfig instance using the specified properties.
         * @function create
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig=} [properties] Properties to set
         * @returns {dataform.RunConfig} RunConfig instance
         */
        RunConfig.create = function create(properties) {
            return new RunConfig(properties);
        };

        /**
         * Encodes the specified RunConfig message. Does not implicitly {@link dataform.RunConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig} message RunConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.actions[i]);
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fullRefresh);
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeDependencies);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.timeoutMillis);
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.useRunCache);
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.disableSetMetadata);
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.includeDependents);
            return writer;
        };

        /**
         * Encodes the specified RunConfig message, length delimited. Does not implicitly {@link dataform.RunConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig} message RunConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RunConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RunConfig} RunConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RunConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.actions && message.actions.length))
                        message.actions = [];
                    message.actions.push(reader.string());
                    break;
                case 5:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 3:
                    message.includeDependencies = reader.bool();
                    break;
                case 11:
                    message.includeDependents = reader.bool();
                    break;
                case 2:
                    message.fullRefresh = reader.bool();
                    break;
                case 7:
                    message.timeoutMillis = reader.int32();
                    break;
                case 8:
                    message.useRunCache = reader.bool();
                    break;
                case 9:
                    message.disableSetMetadata = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RunConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RunConfig} RunConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunConfig message.
         * @function verify
         * @memberof dataform.RunConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i)
                    if (!$util.isString(message.actions[i]))
                        return "actions: string[] expected";
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                if (typeof message.includeDependencies !== "boolean")
                    return "includeDependencies: boolean expected";
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                if (typeof message.includeDependents !== "boolean")
                    return "includeDependents: boolean expected";
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                if (typeof message.fullRefresh !== "boolean")
                    return "fullRefresh: boolean expected";
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                if (!$util.isInteger(message.timeoutMillis))
                    return "timeoutMillis: integer expected";
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                if (typeof message.useRunCache !== "boolean")
                    return "useRunCache: boolean expected";
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                if (typeof message.disableSetMetadata !== "boolean")
                    return "disableSetMetadata: boolean expected";
            return null;
        };

        /**
         * Creates a RunConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RunConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RunConfig} RunConfig
         */
        RunConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RunConfig)
                return object;
            let message = new $root.dataform.RunConfig();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.RunConfig.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i)
                    message.actions[i] = String(object.actions[i]);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.RunConfig.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.includeDependencies != null)
                message.includeDependencies = Boolean(object.includeDependencies);
            if (object.includeDependents != null)
                message.includeDependents = Boolean(object.includeDependents);
            if (object.fullRefresh != null)
                message.fullRefresh = Boolean(object.fullRefresh);
            if (object.timeoutMillis != null)
                message.timeoutMillis = object.timeoutMillis | 0;
            if (object.useRunCache != null)
                message.useRunCache = Boolean(object.useRunCache);
            if (object.disableSetMetadata != null)
                message.disableSetMetadata = Boolean(object.disableSetMetadata);
            return message;
        };

        /**
         * Creates a plain object from a RunConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.RunConfig} message RunConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.tags = [];
            }
            if (options.defaults) {
                object.fullRefresh = false;
                object.includeDependencies = false;
                object.timeoutMillis = 0;
                object.useRunCache = false;
                object.disableSetMetadata = false;
                object.includeDependents = false;
            }
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = message.actions[j];
            }
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                object.fullRefresh = message.fullRefresh;
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                object.includeDependencies = message.includeDependencies;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                object.timeoutMillis = message.timeoutMillis;
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                object.useRunCache = message.useRunCache;
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                object.disableSetMetadata = message.disableSetMetadata;
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                object.includeDependents = message.includeDependents;
            return object;
        };

        /**
         * Converts this RunConfig to JSON.
         * @function toJSON
         * @memberof dataform.RunConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RunConfig;
    })();

    dataform.GenerateIndexConfig = (function() {

        /**
         * Properties of a GenerateIndexConfig.
         * @memberof dataform
         * @interface IGenerateIndexConfig
         * @property {dataform.ICompileConfig|null} [compileConfig] GenerateIndexConfig compileConfig
         * @property {Array.<string>|null} [includePaths] GenerateIndexConfig includePaths
         * @property {Array.<string>|null} [definitionPaths] GenerateIndexConfig definitionPaths
         * @property {string|null} [returnOverride] GenerateIndexConfig returnOverride
         */

        /**
         * Constructs a new GenerateIndexConfig.
         * @memberof dataform
         * @classdesc Represents a GenerateIndexConfig.
         * @implements IGenerateIndexConfig
         * @constructor
         * @param {dataform.IGenerateIndexConfig=} [properties] Properties to set
         */
        function GenerateIndexConfig(properties) {
            this.includePaths = [];
            this.definitionPaths = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenerateIndexConfig compileConfig.
         * @member {dataform.ICompileConfig|null|undefined} compileConfig
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.compileConfig = null;

        /**
         * GenerateIndexConfig includePaths.
         * @member {Array.<string>} includePaths
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.includePaths = $util.emptyArray;

        /**
         * GenerateIndexConfig definitionPaths.
         * @member {Array.<string>} definitionPaths
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.definitionPaths = $util.emptyArray;

        /**
         * GenerateIndexConfig returnOverride.
         * @member {string} returnOverride
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.returnOverride = "";

        /**
         * Creates a new GenerateIndexConfig instance using the specified properties.
         * @function create
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig=} [properties] Properties to set
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig instance
         */
        GenerateIndexConfig.create = function create(properties) {
            return new GenerateIndexConfig(properties);
        };

        /**
         * Encodes the specified GenerateIndexConfig message. Does not implicitly {@link dataform.GenerateIndexConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig} message GenerateIndexConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenerateIndexConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig"))
                $root.dataform.CompileConfig.encode(message.compileConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.includePaths != null && message.includePaths.length)
                for (let i = 0; i < message.includePaths.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.includePaths[i]);
            if (message.definitionPaths != null && message.definitionPaths.length)
                for (let i = 0; i < message.definitionPaths.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.definitionPaths[i]);
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.returnOverride);
            return writer;
        };

        /**
         * Encodes the specified GenerateIndexConfig message, length delimited. Does not implicitly {@link dataform.GenerateIndexConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig} message GenerateIndexConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenerateIndexConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenerateIndexConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenerateIndexConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.GenerateIndexConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.compileConfig = $root.dataform.CompileConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.includePaths && message.includePaths.length))
                        message.includePaths = [];
                    message.includePaths.push(reader.string());
                    break;
                case 3:
                    if (!(message.definitionPaths && message.definitionPaths.length))
                        message.definitionPaths = [];
                    message.definitionPaths.push(reader.string());
                    break;
                case 4:
                    message.returnOverride = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenerateIndexConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenerateIndexConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenerateIndexConfig message.
         * @function verify
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenerateIndexConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig")) {
                let error = $root.dataform.CompileConfig.verify(message.compileConfig);
                if (error)
                    return "compileConfig." + error;
            }
            if (message.includePaths != null && message.hasOwnProperty("includePaths")) {
                if (!Array.isArray(message.includePaths))
                    return "includePaths: array expected";
                for (let i = 0; i < message.includePaths.length; ++i)
                    if (!$util.isString(message.includePaths[i]))
                        return "includePaths: string[] expected";
            }
            if (message.definitionPaths != null && message.hasOwnProperty("definitionPaths")) {
                if (!Array.isArray(message.definitionPaths))
                    return "definitionPaths: array expected";
                for (let i = 0; i < message.definitionPaths.length; ++i)
                    if (!$util.isString(message.definitionPaths[i]))
                        return "definitionPaths: string[] expected";
            }
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                if (!$util.isString(message.returnOverride))
                    return "returnOverride: string expected";
            return null;
        };

        /**
         * Creates a GenerateIndexConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         */
        GenerateIndexConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.GenerateIndexConfig)
                return object;
            let message = new $root.dataform.GenerateIndexConfig();
            if (object.compileConfig != null) {
                if (typeof object.compileConfig !== "object")
                    throw TypeError(".dataform.GenerateIndexConfig.compileConfig: object expected");
                message.compileConfig = $root.dataform.CompileConfig.fromObject(object.compileConfig);
            }
            if (object.includePaths) {
                if (!Array.isArray(object.includePaths))
                    throw TypeError(".dataform.GenerateIndexConfig.includePaths: array expected");
                message.includePaths = [];
                for (let i = 0; i < object.includePaths.length; ++i)
                    message.includePaths[i] = String(object.includePaths[i]);
            }
            if (object.definitionPaths) {
                if (!Array.isArray(object.definitionPaths))
                    throw TypeError(".dataform.GenerateIndexConfig.definitionPaths: array expected");
                message.definitionPaths = [];
                for (let i = 0; i < object.definitionPaths.length; ++i)
                    message.definitionPaths[i] = String(object.definitionPaths[i]);
            }
            if (object.returnOverride != null)
                message.returnOverride = String(object.returnOverride);
            return message;
        };

        /**
         * Creates a plain object from a GenerateIndexConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.GenerateIndexConfig} message GenerateIndexConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenerateIndexConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.includePaths = [];
                object.definitionPaths = [];
            }
            if (options.defaults) {
                object.compileConfig = null;
                object.returnOverride = "";
            }
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig"))
                object.compileConfig = $root.dataform.CompileConfig.toObject(message.compileConfig, options);
            if (message.includePaths && message.includePaths.length) {
                object.includePaths = [];
                for (let j = 0; j < message.includePaths.length; ++j)
                    object.includePaths[j] = message.includePaths[j];
            }
            if (message.definitionPaths && message.definitionPaths.length) {
                object.definitionPaths = [];
                for (let j = 0; j < message.definitionPaths.length; ++j)
                    object.definitionPaths[j] = message.definitionPaths[j];
            }
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                object.returnOverride = message.returnOverride;
            return object;
        };

        /**
         * Converts this GenerateIndexConfig to JSON.
         * @function toJSON
         * @memberof dataform.GenerateIndexConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenerateIndexConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenerateIndexConfig;
    })();

    dataform.CompileConfig = (function() {

        /**
         * Properties of a CompileConfig.
         * @memberof dataform
         * @interface ICompileConfig
         * @property {string|null} [projectDir] CompileConfig projectDir
         * @property {dataform.IProjectConfig|null} [projectConfigOverride] CompileConfig projectConfigOverride
         * @property {boolean|null} [compileSingleQuery] CompileConfig compileSingleQuery
         * @property {string|null} [query] CompileConfig query
         * @property {number|null} [timeoutMillis] CompileConfig timeoutMillis
         * @property {string|null} [schemaSuffixOverride] CompileConfig schemaSuffixOverride
         * @property {string|null} [returnOverride] CompileConfig returnOverride
         */

        /**
         * Constructs a new CompileConfig.
         * @memberof dataform
         * @classdesc Represents a CompileConfig.
         * @implements ICompileConfig
         * @constructor
         * @param {dataform.ICompileConfig=} [properties] Properties to set
         */
        function CompileConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompileConfig projectDir.
         * @member {string} projectDir
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.projectDir = "";

        /**
         * CompileConfig projectConfigOverride.
         * @member {dataform.IProjectConfig|null|undefined} projectConfigOverride
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.projectConfigOverride = null;

        /**
         * CompileConfig compileSingleQuery.
         * @member {boolean} compileSingleQuery
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.compileSingleQuery = false;

        /**
         * CompileConfig query.
         * @member {string} query
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.query = "";

        /**
         * CompileConfig timeoutMillis.
         * @member {number} timeoutMillis
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.timeoutMillis = 0;

        /**
         * CompileConfig schemaSuffixOverride.
         * @member {string} schemaSuffixOverride
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.schemaSuffixOverride = "";

        /**
         * CompileConfig returnOverride.
         * @member {string} returnOverride
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.returnOverride = "";

        /**
         * Creates a new CompileConfig instance using the specified properties.
         * @function create
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig=} [properties] Properties to set
         * @returns {dataform.CompileConfig} CompileConfig instance
         */
        CompileConfig.create = function create(properties) {
            return new CompileConfig(properties);
        };

        /**
         * Encodes the specified CompileConfig message. Does not implicitly {@link dataform.CompileConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig} message CompileConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectDir);
            if (message.schemaSuffixOverride != null && message.hasOwnProperty("schemaSuffixOverride"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaSuffixOverride);
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride"))
                $root.dataform.ProjectConfig.encode(message.projectConfigOverride, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.query);
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.returnOverride);
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.timeoutMillis);
            if (message.compileSingleQuery != null && message.hasOwnProperty("compileSingleQuery"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.compileSingleQuery);
            return writer;
        };

        /**
         * Encodes the specified CompileConfig message, length delimited. Does not implicitly {@link dataform.CompileConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig} message CompileConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompileConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompileConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompileConfig} CompileConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompileConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.projectDir = reader.string();
                    break;
                case 3:
                    message.projectConfigOverride = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.compileSingleQuery = reader.bool();
                    break;
                case 4:
                    message.query = reader.string();
                    break;
                case 6:
                    message.timeoutMillis = reader.int32();
                    break;
                case 2:
                    message.schemaSuffixOverride = reader.string();
                    break;
                case 5:
                    message.returnOverride = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompileConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompileConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompileConfig} CompileConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompileConfig message.
         * @function verify
         * @memberof dataform.CompileConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompileConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                if (!$util.isString(message.projectDir))
                    return "projectDir: string expected";
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfigOverride);
                if (error)
                    return "projectConfigOverride." + error;
            }
            if (message.compileSingleQuery != null && message.hasOwnProperty("compileSingleQuery"))
                if (typeof message.compileSingleQuery !== "boolean")
                    return "compileSingleQuery: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                if (!$util.isInteger(message.timeoutMillis))
                    return "timeoutMillis: integer expected";
            if (message.schemaSuffixOverride != null && message.hasOwnProperty("schemaSuffixOverride"))
                if (!$util.isString(message.schemaSuffixOverride))
                    return "schemaSuffixOverride: string expected";
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                if (!$util.isString(message.returnOverride))
                    return "returnOverride: string expected";
            return null;
        };

        /**
         * Creates a CompileConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompileConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompileConfig} CompileConfig
         */
        CompileConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompileConfig)
                return object;
            let message = new $root.dataform.CompileConfig();
            if (object.projectDir != null)
                message.projectDir = String(object.projectDir);
            if (object.projectConfigOverride != null) {
                if (typeof object.projectConfigOverride !== "object")
                    throw TypeError(".dataform.CompileConfig.projectConfigOverride: object expected");
                message.projectConfigOverride = $root.dataform.ProjectConfig.fromObject(object.projectConfigOverride);
            }
            if (object.compileSingleQuery != null)
                message.compileSingleQuery = Boolean(object.compileSingleQuery);
            if (object.query != null)
                message.query = String(object.query);
            if (object.timeoutMillis != null)
                message.timeoutMillis = object.timeoutMillis | 0;
            if (object.schemaSuffixOverride != null)
                message.schemaSuffixOverride = String(object.schemaSuffixOverride);
            if (object.returnOverride != null)
                message.returnOverride = String(object.returnOverride);
            return message;
        };

        /**
         * Creates a plain object from a CompileConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.CompileConfig} message CompileConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompileConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.projectDir = "";
                object.schemaSuffixOverride = "";
                object.projectConfigOverride = null;
                object.query = "";
                object.returnOverride = "";
                object.timeoutMillis = 0;
                object.compileSingleQuery = false;
            }
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                object.projectDir = message.projectDir;
            if (message.schemaSuffixOverride != null && message.hasOwnProperty("schemaSuffixOverride"))
                object.schemaSuffixOverride = message.schemaSuffixOverride;
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride"))
                object.projectConfigOverride = $root.dataform.ProjectConfig.toObject(message.projectConfigOverride, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.returnOverride != null && message.hasOwnProperty("returnOverride"))
                object.returnOverride = message.returnOverride;
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                object.timeoutMillis = message.timeoutMillis;
            if (message.compileSingleQuery != null && message.hasOwnProperty("compileSingleQuery"))
                object.compileSingleQuery = message.compileSingleQuery;
            return object;
        };

        /**
         * Converts this CompileConfig to JSON.
         * @function toJSON
         * @memberof dataform.CompileConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompileConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CompileConfig;
    })();

    dataform.Target = (function() {

        /**
         * Properties of a Target.
         * @memberof dataform
         * @interface ITarget
         * @property {string|null} [database] Target database
         * @property {string|null} [schema] Target schema
         * @property {string|null} [name] Target name
         */

        /**
         * Constructs a new Target.
         * @memberof dataform
         * @classdesc Represents a Target.
         * @implements ITarget
         * @constructor
         * @param {dataform.ITarget=} [properties] Properties to set
         */
        function Target(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Target database.
         * @member {string} database
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.database = "";

        /**
         * Target schema.
         * @member {string} schema
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.schema = "";

        /**
         * Target name.
         * @member {string} name
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.name = "";

        /**
         * Creates a new Target instance using the specified properties.
         * @function create
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget=} [properties] Properties to set
         * @returns {dataform.Target} Target instance
         */
        Target.create = function create(properties) {
            return new Target(properties);
        };

        /**
         * Encodes the specified Target message. Does not implicitly {@link dataform.Target.verify|verify} messages.
         * @function encode
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && message.hasOwnProperty("schema"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.schema);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.database != null && message.hasOwnProperty("database"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.database);
            return writer;
        };

        /**
         * Encodes the specified Target message, length delimited. Does not implicitly {@link dataform.Target.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Target message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Target();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.database = reader.string();
                    break;
                case 1:
                    message.schema = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Target message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Target message.
         * @function verify
         * @memberof dataform.Target
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Target.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isString(message.schema))
                    return "schema: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Target message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Target
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Target} Target
         */
        Target.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Target)
                return object;
            let message = new $root.dataform.Target();
            if (object.database != null)
                message.database = String(object.database);
            if (object.schema != null)
                message.schema = String(object.schema);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Target message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Target
         * @static
         * @param {dataform.Target} message Target
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Target.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.schema = "";
                object.name = "";
                object.database = "";
            }
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            return object;
        };

        /**
         * Converts this Target to JSON.
         * @function toJSON
         * @memberof dataform.Target
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Target.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Target;
    })();

    dataform.BigQueryOptions = (function() {

        /**
         * Properties of a BigQueryOptions.
         * @memberof dataform
         * @interface IBigQueryOptions
         * @property {string|null} [partitionBy] BigQueryOptions partitionBy
         * @property {Array.<string>|null} [clusterBy] BigQueryOptions clusterBy
         * @property {string|null} [updatePartitionFilter] BigQueryOptions updatePartitionFilter
         * @property {Object.<string,string>|null} [labels] BigQueryOptions labels
         */

        /**
         * Constructs a new BigQueryOptions.
         * @memberof dataform
         * @classdesc Represents a BigQueryOptions.
         * @implements IBigQueryOptions
         * @constructor
         * @param {dataform.IBigQueryOptions=} [properties] Properties to set
         */
        function BigQueryOptions(properties) {
            this.clusterBy = [];
            this.labels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigQueryOptions partitionBy.
         * @member {string} partitionBy
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.partitionBy = "";

        /**
         * BigQueryOptions clusterBy.
         * @member {Array.<string>} clusterBy
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.clusterBy = $util.emptyArray;

        /**
         * BigQueryOptions updatePartitionFilter.
         * @member {string} updatePartitionFilter
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.updatePartitionFilter = "";

        /**
         * BigQueryOptions labels.
         * @member {Object.<string,string>} labels
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.labels = $util.emptyObject;

        /**
         * Creates a new BigQueryOptions instance using the specified properties.
         * @function create
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions=} [properties] Properties to set
         * @returns {dataform.BigQueryOptions} BigQueryOptions instance
         */
        BigQueryOptions.create = function create(properties) {
            return new BigQueryOptions(properties);
        };

        /**
         * Encodes the specified BigQueryOptions message. Does not implicitly {@link dataform.BigQueryOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions} message BigQueryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQueryOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.partitionBy);
            if (message.clusterBy != null && message.clusterBy.length)
                for (let i = 0; i < message.clusterBy.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterBy[i]);
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.updatePartitionFilter);
            if (message.labels != null && message.hasOwnProperty("labels"))
                for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BigQueryOptions message, length delimited. Does not implicitly {@link dataform.BigQueryOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions} message BigQueryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQueryOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BigQueryOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQueryOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.BigQueryOptions(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.partitionBy = reader.string();
                    break;
                case 2:
                    if (!(message.clusterBy && message.clusterBy.length))
                        message.clusterBy = [];
                    message.clusterBy.push(reader.string());
                    break;
                case 3:
                    message.updatePartitionFilter = reader.string();
                    break;
                case 4:
                    reader.skip().pos++;
                    if (message.labels === $util.emptyObject)
                        message.labels = {};
                    key = reader.string();
                    reader.pos++;
                    message.labels[key] = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BigQueryOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQueryOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BigQueryOptions message.
         * @function verify
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BigQueryOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                if (!$util.isString(message.partitionBy))
                    return "partitionBy: string expected";
            if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                if (!Array.isArray(message.clusterBy))
                    return "clusterBy: array expected";
                for (let i = 0; i < message.clusterBy.length; ++i)
                    if (!$util.isString(message.clusterBy[i]))
                        return "clusterBy: string[] expected";
            }
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                if (!$util.isString(message.updatePartitionFilter))
                    return "updatePartitionFilter: string expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!$util.isObject(message.labels))
                    return "labels: object expected";
                let key = Object.keys(message.labels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.labels[key[i]]))
                        return "labels: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a BigQueryOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         */
        BigQueryOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.BigQueryOptions)
                return object;
            let message = new $root.dataform.BigQueryOptions();
            if (object.partitionBy != null)
                message.partitionBy = String(object.partitionBy);
            if (object.clusterBy) {
                if (!Array.isArray(object.clusterBy))
                    throw TypeError(".dataform.BigQueryOptions.clusterBy: array expected");
                message.clusterBy = [];
                for (let i = 0; i < object.clusterBy.length; ++i)
                    message.clusterBy[i] = String(object.clusterBy[i]);
            }
            if (object.updatePartitionFilter != null)
                message.updatePartitionFilter = String(object.updatePartitionFilter);
            if (object.labels) {
                if (typeof object.labels !== "object")
                    throw TypeError(".dataform.BigQueryOptions.labels: object expected");
                message.labels = {};
                for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                    message.labels[keys[i]] = String(object.labels[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a BigQueryOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.BigQueryOptions} message BigQueryOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BigQueryOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.clusterBy = [];
            if (options.objects || options.defaults)
                object.labels = {};
            if (options.defaults) {
                object.partitionBy = "";
                object.updatePartitionFilter = "";
            }
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                object.partitionBy = message.partitionBy;
            if (message.clusterBy && message.clusterBy.length) {
                object.clusterBy = [];
                for (let j = 0; j < message.clusterBy.length; ++j)
                    object.clusterBy[j] = message.clusterBy[j];
            }
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                object.updatePartitionFilter = message.updatePartitionFilter;
            let keys2;
            if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                object.labels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.labels[keys2[j]] = message.labels[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this BigQueryOptions to JSON.
         * @function toJSON
         * @memberof dataform.BigQueryOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BigQueryOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BigQueryOptions;
    })();

    dataform.RedshiftOptions = (function() {

        /**
         * Properties of a RedshiftOptions.
         * @memberof dataform
         * @interface IRedshiftOptions
         * @property {string|null} [distKey] RedshiftOptions distKey
         * @property {string|null} [distStyle] RedshiftOptions distStyle
         * @property {Array.<string>|null} [sortKeys] RedshiftOptions sortKeys
         * @property {string|null} [sortStyle] RedshiftOptions sortStyle
         * @property {boolean|null} [bind] RedshiftOptions bind
         */

        /**
         * Constructs a new RedshiftOptions.
         * @memberof dataform
         * @classdesc Represents a RedshiftOptions.
         * @implements IRedshiftOptions
         * @constructor
         * @param {dataform.IRedshiftOptions=} [properties] Properties to set
         */
        function RedshiftOptions(properties) {
            this.sortKeys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedshiftOptions distKey.
         * @member {string} distKey
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.distKey = "";

        /**
         * RedshiftOptions distStyle.
         * @member {string} distStyle
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.distStyle = "";

        /**
         * RedshiftOptions sortKeys.
         * @member {Array.<string>} sortKeys
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.sortKeys = $util.emptyArray;

        /**
         * RedshiftOptions sortStyle.
         * @member {string} sortStyle
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.sortStyle = "";

        /**
         * RedshiftOptions bind.
         * @member {boolean} bind
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.bind = false;

        /**
         * Creates a new RedshiftOptions instance using the specified properties.
         * @function create
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions=} [properties] Properties to set
         * @returns {dataform.RedshiftOptions} RedshiftOptions instance
         */
        RedshiftOptions.create = function create(properties) {
            return new RedshiftOptions(properties);
        };

        /**
         * Encodes the specified RedshiftOptions message. Does not implicitly {@link dataform.RedshiftOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions} message RedshiftOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedshiftOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distKey != null && message.hasOwnProperty("distKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.distKey);
            if (message.distStyle != null && message.hasOwnProperty("distStyle"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.distStyle);
            if (message.sortKeys != null && message.sortKeys.length)
                for (let i = 0; i < message.sortKeys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sortKeys[i]);
            if (message.sortStyle != null && message.hasOwnProperty("sortStyle"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sortStyle);
            if (message.bind != null && message.hasOwnProperty("bind"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.bind);
            return writer;
        };

        /**
         * Encodes the specified RedshiftOptions message, length delimited. Does not implicitly {@link dataform.RedshiftOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions} message RedshiftOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedshiftOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedshiftOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedshiftOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RedshiftOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.distKey = reader.string();
                    break;
                case 2:
                    message.distStyle = reader.string();
                    break;
                case 3:
                    if (!(message.sortKeys && message.sortKeys.length))
                        message.sortKeys = [];
                    message.sortKeys.push(reader.string());
                    break;
                case 4:
                    message.sortStyle = reader.string();
                    break;
                case 5:
                    message.bind = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedshiftOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedshiftOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedshiftOptions message.
         * @function verify
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedshiftOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distKey != null && message.hasOwnProperty("distKey"))
                if (!$util.isString(message.distKey))
                    return "distKey: string expected";
            if (message.distStyle != null && message.hasOwnProperty("distStyle"))
                if (!$util.isString(message.distStyle))
                    return "distStyle: string expected";
            if (message.sortKeys != null && message.hasOwnProperty("sortKeys")) {
                if (!Array.isArray(message.sortKeys))
                    return "sortKeys: array expected";
                for (let i = 0; i < message.sortKeys.length; ++i)
                    if (!$util.isString(message.sortKeys[i]))
                        return "sortKeys: string[] expected";
            }
            if (message.sortStyle != null && message.hasOwnProperty("sortStyle"))
                if (!$util.isString(message.sortStyle))
                    return "sortStyle: string expected";
            if (message.bind != null && message.hasOwnProperty("bind"))
                if (typeof message.bind !== "boolean")
                    return "bind: boolean expected";
            return null;
        };

        /**
         * Creates a RedshiftOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         */
        RedshiftOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RedshiftOptions)
                return object;
            let message = new $root.dataform.RedshiftOptions();
            if (object.distKey != null)
                message.distKey = String(object.distKey);
            if (object.distStyle != null)
                message.distStyle = String(object.distStyle);
            if (object.sortKeys) {
                if (!Array.isArray(object.sortKeys))
                    throw TypeError(".dataform.RedshiftOptions.sortKeys: array expected");
                message.sortKeys = [];
                for (let i = 0; i < object.sortKeys.length; ++i)
                    message.sortKeys[i] = String(object.sortKeys[i]);
            }
            if (object.sortStyle != null)
                message.sortStyle = String(object.sortStyle);
            if (object.bind != null)
                message.bind = Boolean(object.bind);
            return message;
        };

        /**
         * Creates a plain object from a RedshiftOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.RedshiftOptions} message RedshiftOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedshiftOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sortKeys = [];
            if (options.defaults) {
                object.distKey = "";
                object.distStyle = "";
                object.sortStyle = "";
                object.bind = false;
            }
            if (message.distKey != null && message.hasOwnProperty("distKey"))
                object.distKey = message.distKey;
            if (message.distStyle != null && message.hasOwnProperty("distStyle"))
                object.distStyle = message.distStyle;
            if (message.sortKeys && message.sortKeys.length) {
                object.sortKeys = [];
                for (let j = 0; j < message.sortKeys.length; ++j)
                    object.sortKeys[j] = message.sortKeys[j];
            }
            if (message.sortStyle != null && message.hasOwnProperty("sortStyle"))
                object.sortStyle = message.sortStyle;
            if (message.bind != null && message.hasOwnProperty("bind"))
                object.bind = message.bind;
            return object;
        };

        /**
         * Converts this RedshiftOptions to JSON.
         * @function toJSON
         * @memberof dataform.RedshiftOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedshiftOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RedshiftOptions;
    })();

    dataform.SnowflakeOptions = (function() {

        /**
         * Properties of a SnowflakeOptions.
         * @memberof dataform
         * @interface ISnowflakeOptions
         * @property {boolean|null} [secure] SnowflakeOptions secure
         * @property {boolean|null} [transient] SnowflakeOptions transient
         * @property {Array.<string>|null} [clusterBy] SnowflakeOptions clusterBy
         */

        /**
         * Constructs a new SnowflakeOptions.
         * @memberof dataform
         * @classdesc Represents a SnowflakeOptions.
         * @implements ISnowflakeOptions
         * @constructor
         * @param {dataform.ISnowflakeOptions=} [properties] Properties to set
         */
        function SnowflakeOptions(properties) {
            this.clusterBy = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SnowflakeOptions secure.
         * @member {boolean} secure
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.secure = false;

        /**
         * SnowflakeOptions transient.
         * @member {boolean} transient
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.transient = false;

        /**
         * SnowflakeOptions clusterBy.
         * @member {Array.<string>} clusterBy
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.clusterBy = $util.emptyArray;

        /**
         * Creates a new SnowflakeOptions instance using the specified properties.
         * @function create
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions=} [properties] Properties to set
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions instance
         */
        SnowflakeOptions.create = function create(properties) {
            return new SnowflakeOptions(properties);
        };

        /**
         * Encodes the specified SnowflakeOptions message. Does not implicitly {@link dataform.SnowflakeOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions} message SnowflakeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnowflakeOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.secure != null && message.hasOwnProperty("secure"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.secure);
            if (message.transient != null && message.hasOwnProperty("transient"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.transient);
            if (message.clusterBy != null && message.clusterBy.length)
                for (let i = 0; i < message.clusterBy.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clusterBy[i]);
            return writer;
        };

        /**
         * Encodes the specified SnowflakeOptions message, length delimited. Does not implicitly {@link dataform.SnowflakeOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions} message SnowflakeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnowflakeOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SnowflakeOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnowflakeOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SnowflakeOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.secure = reader.bool();
                    break;
                case 2:
                    message.transient = reader.bool();
                    break;
                case 3:
                    if (!(message.clusterBy && message.clusterBy.length))
                        message.clusterBy = [];
                    message.clusterBy.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SnowflakeOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnowflakeOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SnowflakeOptions message.
         * @function verify
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SnowflakeOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.secure != null && message.hasOwnProperty("secure"))
                if (typeof message.secure !== "boolean")
                    return "secure: boolean expected";
            if (message.transient != null && message.hasOwnProperty("transient"))
                if (typeof message.transient !== "boolean")
                    return "transient: boolean expected";
            if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                if (!Array.isArray(message.clusterBy))
                    return "clusterBy: array expected";
                for (let i = 0; i < message.clusterBy.length; ++i)
                    if (!$util.isString(message.clusterBy[i]))
                        return "clusterBy: string[] expected";
            }
            return null;
        };

        /**
         * Creates a SnowflakeOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         */
        SnowflakeOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SnowflakeOptions)
                return object;
            let message = new $root.dataform.SnowflakeOptions();
            if (object.secure != null)
                message.secure = Boolean(object.secure);
            if (object.transient != null)
                message.transient = Boolean(object.transient);
            if (object.clusterBy) {
                if (!Array.isArray(object.clusterBy))
                    throw TypeError(".dataform.SnowflakeOptions.clusterBy: array expected");
                message.clusterBy = [];
                for (let i = 0; i < object.clusterBy.length; ++i)
                    message.clusterBy[i] = String(object.clusterBy[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a SnowflakeOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.SnowflakeOptions} message SnowflakeOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnowflakeOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.clusterBy = [];
            if (options.defaults) {
                object.secure = false;
                object.transient = false;
            }
            if (message.secure != null && message.hasOwnProperty("secure"))
                object.secure = message.secure;
            if (message.transient != null && message.hasOwnProperty("transient"))
                object.transient = message.transient;
            if (message.clusterBy && message.clusterBy.length) {
                object.clusterBy = [];
                for (let j = 0; j < message.clusterBy.length; ++j)
                    object.clusterBy[j] = message.clusterBy[j];
            }
            return object;
        };

        /**
         * Converts this SnowflakeOptions to JSON.
         * @function toJSON
         * @memberof dataform.SnowflakeOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SnowflakeOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SnowflakeOptions;
    })();

    dataform.SQLDataWarehouseOptions = (function() {

        /**
         * Properties of a SQLDataWarehouseOptions.
         * @memberof dataform
         * @interface ISQLDataWarehouseOptions
         * @property {string|null} [distribution] SQLDataWarehouseOptions distribution
         */

        /**
         * Constructs a new SQLDataWarehouseOptions.
         * @memberof dataform
         * @classdesc Represents a SQLDataWarehouseOptions.
         * @implements ISQLDataWarehouseOptions
         * @constructor
         * @param {dataform.ISQLDataWarehouseOptions=} [properties] Properties to set
         */
        function SQLDataWarehouseOptions(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SQLDataWarehouseOptions distribution.
         * @member {string} distribution
         * @memberof dataform.SQLDataWarehouseOptions
         * @instance
         */
        SQLDataWarehouseOptions.prototype.distribution = "";

        /**
         * Creates a new SQLDataWarehouseOptions instance using the specified properties.
         * @function create
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions=} [properties] Properties to set
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions instance
         */
        SQLDataWarehouseOptions.create = function create(properties) {
            return new SQLDataWarehouseOptions(properties);
        };

        /**
         * Encodes the specified SQLDataWarehouseOptions message. Does not implicitly {@link dataform.SQLDataWarehouseOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions} message SQLDataWarehouseOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouseOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distribution != null && message.hasOwnProperty("distribution"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.distribution);
            return writer;
        };

        /**
         * Encodes the specified SQLDataWarehouseOptions message, length delimited. Does not implicitly {@link dataform.SQLDataWarehouseOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions} message SQLDataWarehouseOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouseOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SQLDataWarehouseOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouseOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SQLDataWarehouseOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.distribution = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SQLDataWarehouseOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouseOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SQLDataWarehouseOptions message.
         * @function verify
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SQLDataWarehouseOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distribution != null && message.hasOwnProperty("distribution"))
                if (!$util.isString(message.distribution))
                    return "distribution: string expected";
            return null;
        };

        /**
         * Creates a SQLDataWarehouseOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         */
        SQLDataWarehouseOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SQLDataWarehouseOptions)
                return object;
            let message = new $root.dataform.SQLDataWarehouseOptions();
            if (object.distribution != null)
                message.distribution = String(object.distribution);
            return message;
        };

        /**
         * Creates a plain object from a SQLDataWarehouseOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.SQLDataWarehouseOptions} message SQLDataWarehouseOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SQLDataWarehouseOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.distribution = "";
            if (message.distribution != null && message.hasOwnProperty("distribution"))
                object.distribution = message.distribution;
            return object;
        };

        /**
         * Converts this SQLDataWarehouseOptions to JSON.
         * @function toJSON
         * @memberof dataform.SQLDataWarehouseOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SQLDataWarehouseOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SQLDataWarehouseOptions;
    })();

    dataform.PrestoOptions = (function() {

        /**
         * Properties of a PrestoOptions.
         * @memberof dataform
         * @interface IPrestoOptions
         * @property {Array.<string>|null} [partitionBy] PrestoOptions partitionBy
         */

        /**
         * Constructs a new PrestoOptions.
         * @memberof dataform
         * @classdesc Represents a PrestoOptions.
         * @implements IPrestoOptions
         * @constructor
         * @param {dataform.IPrestoOptions=} [properties] Properties to set
         */
        function PrestoOptions(properties) {
            this.partitionBy = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrestoOptions partitionBy.
         * @member {Array.<string>} partitionBy
         * @memberof dataform.PrestoOptions
         * @instance
         */
        PrestoOptions.prototype.partitionBy = $util.emptyArray;

        /**
         * Creates a new PrestoOptions instance using the specified properties.
         * @function create
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions=} [properties] Properties to set
         * @returns {dataform.PrestoOptions} PrestoOptions instance
         */
        PrestoOptions.create = function create(properties) {
            return new PrestoOptions(properties);
        };

        /**
         * Encodes the specified PrestoOptions message. Does not implicitly {@link dataform.PrestoOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions} message PrestoOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrestoOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partitionBy != null && message.partitionBy.length)
                for (let i = 0; i < message.partitionBy.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.partitionBy[i]);
            return writer;
        };

        /**
         * Encodes the specified PrestoOptions message, length delimited. Does not implicitly {@link dataform.PrestoOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions} message PrestoOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrestoOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrestoOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.PrestoOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.PrestoOptions} PrestoOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrestoOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.PrestoOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    if (!(message.partitionBy && message.partitionBy.length))
                        message.partitionBy = [];
                    message.partitionBy.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrestoOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.PrestoOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.PrestoOptions} PrestoOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrestoOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrestoOptions message.
         * @function verify
         * @memberof dataform.PrestoOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrestoOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy")) {
                if (!Array.isArray(message.partitionBy))
                    return "partitionBy: array expected";
                for (let i = 0; i < message.partitionBy.length; ++i)
                    if (!$util.isString(message.partitionBy[i]))
                        return "partitionBy: string[] expected";
            }
            return null;
        };

        /**
         * Creates a PrestoOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.PrestoOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.PrestoOptions} PrestoOptions
         */
        PrestoOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.PrestoOptions)
                return object;
            let message = new $root.dataform.PrestoOptions();
            if (object.partitionBy) {
                if (!Array.isArray(object.partitionBy))
                    throw TypeError(".dataform.PrestoOptions.partitionBy: array expected");
                message.partitionBy = [];
                for (let i = 0; i < object.partitionBy.length; ++i)
                    message.partitionBy[i] = String(object.partitionBy[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a PrestoOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.PrestoOptions} message PrestoOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrestoOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.partitionBy = [];
            if (message.partitionBy && message.partitionBy.length) {
                object.partitionBy = [];
                for (let j = 0; j < message.partitionBy.length; ++j)
                    object.partitionBy[j] = message.partitionBy[j];
            }
            return object;
        };

        /**
         * Converts this PrestoOptions to JSON.
         * @function toJSON
         * @memberof dataform.PrestoOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrestoOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrestoOptions;
    })();

    dataform.GraphErrors = (function() {

        /**
         * Properties of a GraphErrors.
         * @memberof dataform
         * @interface IGraphErrors
         * @property {Array.<dataform.ICompilationError>|null} [compilationErrors] GraphErrors compilationErrors
         * @property {Array.<dataform.IValidationError>|null} [validationErrors] GraphErrors validationErrors
         */

        /**
         * Constructs a new GraphErrors.
         * @memberof dataform
         * @classdesc Represents a GraphErrors.
         * @implements IGraphErrors
         * @constructor
         * @param {dataform.IGraphErrors=} [properties] Properties to set
         */
        function GraphErrors(properties) {
            this.compilationErrors = [];
            this.validationErrors = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphErrors compilationErrors.
         * @member {Array.<dataform.ICompilationError>} compilationErrors
         * @memberof dataform.GraphErrors
         * @instance
         */
        GraphErrors.prototype.compilationErrors = $util.emptyArray;

        /**
         * GraphErrors validationErrors.
         * @member {Array.<dataform.IValidationError>} validationErrors
         * @memberof dataform.GraphErrors
         * @instance
         */
        GraphErrors.prototype.validationErrors = $util.emptyArray;

        /**
         * Creates a new GraphErrors instance using the specified properties.
         * @function create
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors=} [properties] Properties to set
         * @returns {dataform.GraphErrors} GraphErrors instance
         */
        GraphErrors.create = function create(properties) {
            return new GraphErrors(properties);
        };

        /**
         * Encodes the specified GraphErrors message. Does not implicitly {@link dataform.GraphErrors.verify|verify} messages.
         * @function encode
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors} message GraphErrors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphErrors.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compilationErrors != null && message.compilationErrors.length)
                for (let i = 0; i < message.compilationErrors.length; ++i)
                    $root.dataform.CompilationError.encode(message.compilationErrors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.validationErrors != null && message.validationErrors.length)
                for (let i = 0; i < message.validationErrors.length; ++i)
                    $root.dataform.ValidationError.encode(message.validationErrors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphErrors message, length delimited. Does not implicitly {@link dataform.GraphErrors.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors} message GraphErrors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphErrors.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphErrors message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.GraphErrors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.GraphErrors} GraphErrors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphErrors.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.GraphErrors();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.compilationErrors && message.compilationErrors.length))
                        message.compilationErrors = [];
                    message.compilationErrors.push($root.dataform.CompilationError.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.validationErrors && message.validationErrors.length))
                        message.validationErrors = [];
                    message.validationErrors.push($root.dataform.ValidationError.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphErrors message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.GraphErrors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.GraphErrors} GraphErrors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphErrors.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphErrors message.
         * @function verify
         * @memberof dataform.GraphErrors
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphErrors.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compilationErrors != null && message.hasOwnProperty("compilationErrors")) {
                if (!Array.isArray(message.compilationErrors))
                    return "compilationErrors: array expected";
                for (let i = 0; i < message.compilationErrors.length; ++i) {
                    let error = $root.dataform.CompilationError.verify(message.compilationErrors[i]);
                    if (error)
                        return "compilationErrors." + error;
                }
            }
            if (message.validationErrors != null && message.hasOwnProperty("validationErrors")) {
                if (!Array.isArray(message.validationErrors))
                    return "validationErrors: array expected";
                for (let i = 0; i < message.validationErrors.length; ++i) {
                    let error = $root.dataform.ValidationError.verify(message.validationErrors[i]);
                    if (error)
                        return "validationErrors." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphErrors message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.GraphErrors
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.GraphErrors} GraphErrors
         */
        GraphErrors.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.GraphErrors)
                return object;
            let message = new $root.dataform.GraphErrors();
            if (object.compilationErrors) {
                if (!Array.isArray(object.compilationErrors))
                    throw TypeError(".dataform.GraphErrors.compilationErrors: array expected");
                message.compilationErrors = [];
                for (let i = 0; i < object.compilationErrors.length; ++i) {
                    if (typeof object.compilationErrors[i] !== "object")
                        throw TypeError(".dataform.GraphErrors.compilationErrors: object expected");
                    message.compilationErrors[i] = $root.dataform.CompilationError.fromObject(object.compilationErrors[i]);
                }
            }
            if (object.validationErrors) {
                if (!Array.isArray(object.validationErrors))
                    throw TypeError(".dataform.GraphErrors.validationErrors: array expected");
                message.validationErrors = [];
                for (let i = 0; i < object.validationErrors.length; ++i) {
                    if (typeof object.validationErrors[i] !== "object")
                        throw TypeError(".dataform.GraphErrors.validationErrors: object expected");
                    message.validationErrors[i] = $root.dataform.ValidationError.fromObject(object.validationErrors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphErrors message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.GraphErrors} message GraphErrors
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphErrors.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.compilationErrors = [];
                object.validationErrors = [];
            }
            if (message.compilationErrors && message.compilationErrors.length) {
                object.compilationErrors = [];
                for (let j = 0; j < message.compilationErrors.length; ++j)
                    object.compilationErrors[j] = $root.dataform.CompilationError.toObject(message.compilationErrors[j], options);
            }
            if (message.validationErrors && message.validationErrors.length) {
                object.validationErrors = [];
                for (let j = 0; j < message.validationErrors.length; ++j)
                    object.validationErrors[j] = $root.dataform.ValidationError.toObject(message.validationErrors[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphErrors to JSON.
         * @function toJSON
         * @memberof dataform.GraphErrors
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphErrors.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphErrors;
    })();

    dataform.ValidationError = (function() {

        /**
         * Properties of a ValidationError.
         * @memberof dataform
         * @interface IValidationError
         * @property {string|null} [actionName] ValidationError actionName
         * @property {string|null} [message] ValidationError message
         */

        /**
         * Constructs a new ValidationError.
         * @memberof dataform
         * @classdesc Represents a ValidationError.
         * @implements IValidationError
         * @constructor
         * @param {dataform.IValidationError=} [properties] Properties to set
         */
        function ValidationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidationError actionName.
         * @member {string} actionName
         * @memberof dataform.ValidationError
         * @instance
         */
        ValidationError.prototype.actionName = "";

        /**
         * ValidationError message.
         * @member {string} message
         * @memberof dataform.ValidationError
         * @instance
         */
        ValidationError.prototype.message = "";

        /**
         * Creates a new ValidationError instance using the specified properties.
         * @function create
         * @memberof dataform.ValidationError
         * @static
         * @param {dataform.IValidationError=} [properties] Properties to set
         * @returns {dataform.ValidationError} ValidationError instance
         */
        ValidationError.create = function create(properties) {
            return new ValidationError(properties);
        };

        /**
         * Encodes the specified ValidationError message. Does not implicitly {@link dataform.ValidationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.ValidationError
         * @static
         * @param {dataform.IValidationError} message ValidationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.actionName);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified ValidationError message, length delimited. Does not implicitly {@link dataform.ValidationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ValidationError
         * @static
         * @param {dataform.IValidationError} message ValidationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ValidationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ValidationError} ValidationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ValidationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.actionName = reader.string();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ValidationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ValidationError} ValidationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidationError message.
         * @function verify
         * @memberof dataform.ValidationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                if (!$util.isString(message.actionName))
                    return "actionName: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a ValidationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ValidationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ValidationError} ValidationError
         */
        ValidationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ValidationError)
                return object;
            let message = new $root.dataform.ValidationError();
            if (object.actionName != null)
                message.actionName = String(object.actionName);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a ValidationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ValidationError
         * @static
         * @param {dataform.ValidationError} message ValidationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.actionName = "";
                object.message = "";
            }
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                object.actionName = message.actionName;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this ValidationError to JSON.
         * @function toJSON
         * @memberof dataform.ValidationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidationError;
    })();

    dataform.CompilationError = (function() {

        /**
         * Properties of a CompilationError.
         * @memberof dataform
         * @interface ICompilationError
         * @property {string|null} [fileName] CompilationError fileName
         * @property {string|null} [actionName] CompilationError actionName
         * @property {string|null} [message] CompilationError message
         * @property {string|null} [stack] CompilationError stack
         */

        /**
         * Constructs a new CompilationError.
         * @memberof dataform
         * @classdesc Represents a CompilationError.
         * @implements ICompilationError
         * @constructor
         * @param {dataform.ICompilationError=} [properties] Properties to set
         */
        function CompilationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompilationError fileName.
         * @member {string} fileName
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.fileName = "";

        /**
         * CompilationError actionName.
         * @member {string} actionName
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.actionName = "";

        /**
         * CompilationError message.
         * @member {string} message
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.message = "";

        /**
         * CompilationError stack.
         * @member {string} stack
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.stack = "";

        /**
         * Creates a new CompilationError instance using the specified properties.
         * @function create
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError=} [properties] Properties to set
         * @returns {dataform.CompilationError} CompilationError instance
         */
        CompilationError.create = function create(properties) {
            return new CompilationError(properties);
        };

        /**
         * Encodes the specified CompilationError message. Does not implicitly {@link dataform.CompilationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError} message CompilationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompilationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.stack != null && message.hasOwnProperty("stack"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stack);
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.actionName);
            return writer;
        };

        /**
         * Encodes the specified CompilationError message, length delimited. Does not implicitly {@link dataform.CompilationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError} message CompilationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompilationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompilationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompilationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompilationError} CompilationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompilationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompilationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fileName = reader.string();
                    break;
                case 4:
                    message.actionName = reader.string();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.stack = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompilationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompilationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompilationError} CompilationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompilationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompilationError message.
         * @function verify
         * @memberof dataform.CompilationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompilationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                if (!$util.isString(message.actionName))
                    return "actionName: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.stack != null && message.hasOwnProperty("stack"))
                if (!$util.isString(message.stack))
                    return "stack: string expected";
            return null;
        };

        /**
         * Creates a CompilationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompilationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompilationError} CompilationError
         */
        CompilationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompilationError)
                return object;
            let message = new $root.dataform.CompilationError();
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.actionName != null)
                message.actionName = String(object.actionName);
            if (object.message != null)
                message.message = String(object.message);
            if (object.stack != null)
                message.stack = String(object.stack);
            return message;
        };

        /**
         * Creates a plain object from a CompilationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.CompilationError} message CompilationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompilationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.fileName = "";
                object.message = "";
                object.stack = "";
                object.actionName = "";
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.stack != null && message.hasOwnProperty("stack"))
                object.stack = message.stack;
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                object.actionName = message.actionName;
            return object;
        };

        /**
         * Converts this CompilationError to JSON.
         * @function toJSON
         * @memberof dataform.CompilationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompilationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CompilationError;
    })();

    dataform.QueryEvaluationError = (function() {

        /**
         * Properties of a QueryEvaluationError.
         * @memberof dataform
         * @interface IQueryEvaluationError
         * @property {string|null} [message] QueryEvaluationError message
         * @property {dataform.QueryEvaluationError.IErrorLocation|null} [errorLocation] QueryEvaluationError errorLocation
         */

        /**
         * Constructs a new QueryEvaluationError.
         * @memberof dataform
         * @classdesc Represents a QueryEvaluationError.
         * @implements IQueryEvaluationError
         * @constructor
         * @param {dataform.IQueryEvaluationError=} [properties] Properties to set
         */
        function QueryEvaluationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryEvaluationError message.
         * @member {string} message
         * @memberof dataform.QueryEvaluationError
         * @instance
         */
        QueryEvaluationError.prototype.message = "";

        /**
         * QueryEvaluationError errorLocation.
         * @member {dataform.QueryEvaluationError.IErrorLocation|null|undefined} errorLocation
         * @memberof dataform.QueryEvaluationError
         * @instance
         */
        QueryEvaluationError.prototype.errorLocation = null;

        /**
         * Creates a new QueryEvaluationError instance using the specified properties.
         * @function create
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError=} [properties] Properties to set
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError instance
         */
        QueryEvaluationError.create = function create(properties) {
            return new QueryEvaluationError(properties);
        };

        /**
         * Encodes the specified QueryEvaluationError message. Does not implicitly {@link dataform.QueryEvaluationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError} message QueryEvaluationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation"))
                $root.dataform.QueryEvaluationError.ErrorLocation.encode(message.errorLocation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryEvaluationError message, length delimited. Does not implicitly {@link dataform.QueryEvaluationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError} message QueryEvaluationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryEvaluationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                case 2:
                    message.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryEvaluationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryEvaluationError message.
         * @function verify
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryEvaluationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation")) {
                let error = $root.dataform.QueryEvaluationError.ErrorLocation.verify(message.errorLocation);
                if (error)
                    return "errorLocation." + error;
            }
            return null;
        };

        /**
         * Creates a QueryEvaluationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         */
        QueryEvaluationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.QueryEvaluationError)
                return object;
            let message = new $root.dataform.QueryEvaluationError();
            if (object.message != null)
                message.message = String(object.message);
            if (object.errorLocation != null) {
                if (typeof object.errorLocation !== "object")
                    throw TypeError(".dataform.QueryEvaluationError.errorLocation: object expected");
                message.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.fromObject(object.errorLocation);
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryEvaluationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.QueryEvaluationError} message QueryEvaluationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryEvaluationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.message = "";
                object.errorLocation = null;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation"))
                object.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.toObject(message.errorLocation, options);
            return object;
        };

        /**
         * Converts this QueryEvaluationError to JSON.
         * @function toJSON
         * @memberof dataform.QueryEvaluationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryEvaluationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        QueryEvaluationError.ErrorLocation = (function() {

            /**
             * Properties of an ErrorLocation.
             * @memberof dataform.QueryEvaluationError
             * @interface IErrorLocation
             * @property {number|null} [line] ErrorLocation line
             * @property {number|null} [column] ErrorLocation column
             */

            /**
             * Constructs a new ErrorLocation.
             * @memberof dataform.QueryEvaluationError
             * @classdesc Represents an ErrorLocation.
             * @implements IErrorLocation
             * @constructor
             * @param {dataform.QueryEvaluationError.IErrorLocation=} [properties] Properties to set
             */
            function ErrorLocation(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorLocation line.
             * @member {number} line
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             */
            ErrorLocation.prototype.line = 0;

            /**
             * ErrorLocation column.
             * @member {number} column
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             */
            ErrorLocation.prototype.column = 0;

            /**
             * Creates a new ErrorLocation instance using the specified properties.
             * @function create
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation=} [properties] Properties to set
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation instance
             */
            ErrorLocation.create = function create(properties) {
                return new ErrorLocation(properties);
            };

            /**
             * Encodes the specified ErrorLocation message. Does not implicitly {@link dataform.QueryEvaluationError.ErrorLocation.verify|verify} messages.
             * @function encode
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation} message ErrorLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorLocation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.line != null && message.hasOwnProperty("line"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.line);
                if (message.column != null && message.hasOwnProperty("column"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.column);
                return writer;
            };

            /**
             * Encodes the specified ErrorLocation message, length delimited. Does not implicitly {@link dataform.QueryEvaluationError.ErrorLocation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation} message ErrorLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorLocation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorLocation message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorLocation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluationError.ErrorLocation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.line = reader.int32();
                        break;
                    case 2:
                        message.column = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorLocation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorLocation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorLocation message.
             * @function verify
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorLocation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line))
                        return "line: integer expected";
                if (message.column != null && message.hasOwnProperty("column"))
                    if (!$util.isInteger(message.column))
                        return "column: integer expected";
                return null;
            };

            /**
             * Creates an ErrorLocation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             */
            ErrorLocation.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.QueryEvaluationError.ErrorLocation)
                    return object;
                let message = new $root.dataform.QueryEvaluationError.ErrorLocation();
                if (object.line != null)
                    message.line = object.line | 0;
                if (object.column != null)
                    message.column = object.column | 0;
                return message;
            };

            /**
             * Creates a plain object from an ErrorLocation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.ErrorLocation} message ErrorLocation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorLocation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.line = 0;
                    object.column = 0;
                }
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                if (message.column != null && message.hasOwnProperty("column"))
                    object.column = message.column;
                return object;
            };

            /**
             * Converts this ErrorLocation to JSON.
             * @function toJSON
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorLocation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ErrorLocation;
        })();

        return QueryEvaluationError;
    })();

    dataform.QueryEvaluation = (function() {

        /**
         * Properties of a QueryEvaluation.
         * @memberof dataform
         * @interface IQueryEvaluation
         * @property {dataform.QueryEvaluation.QueryEvaluationStatus|null} [status] QueryEvaluation status
         * @property {dataform.IQueryEvaluationError|null} [error] QueryEvaluation error
         * @property {boolean|null} [incremental] QueryEvaluation incremental
         * @property {string|null} [query] QueryEvaluation query
         */

        /**
         * Constructs a new QueryEvaluation.
         * @memberof dataform
         * @classdesc Represents a QueryEvaluation.
         * @implements IQueryEvaluation
         * @constructor
         * @param {dataform.IQueryEvaluation=} [properties] Properties to set
         */
        function QueryEvaluation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryEvaluation status.
         * @member {dataform.QueryEvaluation.QueryEvaluationStatus} status
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.status = 0;

        /**
         * QueryEvaluation error.
         * @member {dataform.IQueryEvaluationError|null|undefined} error
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.error = null;

        /**
         * QueryEvaluation incremental.
         * @member {boolean} incremental
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.incremental = false;

        /**
         * QueryEvaluation query.
         * @member {string} query
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.query = "";

        /**
         * Creates a new QueryEvaluation instance using the specified properties.
         * @function create
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation=} [properties] Properties to set
         * @returns {dataform.QueryEvaluation} QueryEvaluation instance
         */
        QueryEvaluation.create = function create(properties) {
            return new QueryEvaluation(properties);
        };

        /**
         * Encodes the specified QueryEvaluation message. Does not implicitly {@link dataform.QueryEvaluation.verify|verify} messages.
         * @function encode
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation} message QueryEvaluation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.error != null && message.hasOwnProperty("error"))
                $root.dataform.QueryEvaluationError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.incremental);
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.query);
            return writer;
        };

        /**
         * Encodes the specified QueryEvaluation message, length delimited. Does not implicitly {@link dataform.QueryEvaluation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation} message QueryEvaluation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryEvaluation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.error = $root.dataform.QueryEvaluationError.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.incremental = reader.bool();
                    break;
                case 4:
                    message.query = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryEvaluation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryEvaluation message.
         * @function verify
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryEvaluation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.error != null && message.hasOwnProperty("error")) {
                let error = $root.dataform.QueryEvaluationError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                if (typeof message.incremental !== "boolean")
                    return "incremental: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            return null;
        };

        /**
         * Creates a QueryEvaluation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         */
        QueryEvaluation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.QueryEvaluation)
                return object;
            let message = new $root.dataform.QueryEvaluation();
            switch (object.status) {
            case "SUCCESS":
            case 0:
                message.status = 0;
                break;
            case "FAILURE":
            case 1:
                message.status = 1;
                break;
            }
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".dataform.QueryEvaluation.error: object expected");
                message.error = $root.dataform.QueryEvaluationError.fromObject(object.error);
            }
            if (object.incremental != null)
                message.incremental = Boolean(object.incremental);
            if (object.query != null)
                message.query = String(object.query);
            return message;
        };

        /**
         * Creates a plain object from a QueryEvaluation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.QueryEvaluation} message QueryEvaluation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryEvaluation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "SUCCESS" : 0;
                object.error = null;
                object.incremental = false;
                object.query = "";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.QueryEvaluation.QueryEvaluationStatus[message.status] : message.status;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.dataform.QueryEvaluationError.toObject(message.error, options);
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                object.incremental = message.incremental;
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            return object;
        };

        /**
         * Converts this QueryEvaluation to JSON.
         * @function toJSON
         * @memberof dataform.QueryEvaluation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryEvaluation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * QueryEvaluationStatus enum.
         * @name dataform.QueryEvaluation.QueryEvaluationStatus
         * @enum {string}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} FAILURE=1 FAILURE value
         */
        QueryEvaluation.QueryEvaluationStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "FAILURE"] = 1;
            return values;
        })();

        return QueryEvaluation;
    })();

    dataform.ValidationQuery = (function() {

        /**
         * Properties of a ValidationQuery.
         * @memberof dataform
         * @interface IValidationQuery
         * @property {string|null} [query] ValidationQuery query
         * @property {boolean|null} [incremental] ValidationQuery incremental
         */

        /**
         * Constructs a new ValidationQuery.
         * @memberof dataform
         * @classdesc Represents a ValidationQuery.
         * @implements IValidationQuery
         * @constructor
         * @param {dataform.IValidationQuery=} [properties] Properties to set
         */
        function ValidationQuery(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidationQuery query.
         * @member {string} query
         * @memberof dataform.ValidationQuery
         * @instance
         */
        ValidationQuery.prototype.query = "";

        /**
         * ValidationQuery incremental.
         * @member {boolean} incremental
         * @memberof dataform.ValidationQuery
         * @instance
         */
        ValidationQuery.prototype.incremental = false;

        /**
         * Creates a new ValidationQuery instance using the specified properties.
         * @function create
         * @memberof dataform.ValidationQuery
         * @static
         * @param {dataform.IValidationQuery=} [properties] Properties to set
         * @returns {dataform.ValidationQuery} ValidationQuery instance
         */
        ValidationQuery.create = function create(properties) {
            return new ValidationQuery(properties);
        };

        /**
         * Encodes the specified ValidationQuery message. Does not implicitly {@link dataform.ValidationQuery.verify|verify} messages.
         * @function encode
         * @memberof dataform.ValidationQuery
         * @static
         * @param {dataform.IValidationQuery} message ValidationQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.incremental);
            return writer;
        };

        /**
         * Encodes the specified ValidationQuery message, length delimited. Does not implicitly {@link dataform.ValidationQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ValidationQuery
         * @static
         * @param {dataform.IValidationQuery} message ValidationQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidationQuery message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ValidationQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ValidationQuery} ValidationQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ValidationQuery();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.query = reader.string();
                    break;
                case 2:
                    message.incremental = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidationQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ValidationQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ValidationQuery} ValidationQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidationQuery message.
         * @function verify
         * @memberof dataform.ValidationQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidationQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                if (typeof message.incremental !== "boolean")
                    return "incremental: boolean expected";
            return null;
        };

        /**
         * Creates a ValidationQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ValidationQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ValidationQuery} ValidationQuery
         */
        ValidationQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ValidationQuery)
                return object;
            let message = new $root.dataform.ValidationQuery();
            if (object.query != null)
                message.query = String(object.query);
            if (object.incremental != null)
                message.incremental = Boolean(object.incremental);
            return message;
        };

        /**
         * Creates a plain object from a ValidationQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ValidationQuery
         * @static
         * @param {dataform.ValidationQuery} message ValidationQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidationQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.query = "";
                object.incremental = false;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                object.incremental = message.incremental;
            return object;
        };

        /**
         * Converts this ValidationQuery to JSON.
         * @function toJSON
         * @memberof dataform.ValidationQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidationQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidationQuery;
    })();

    dataform.ActionDescriptor = (function() {

        /**
         * Properties of an ActionDescriptor.
         * @memberof dataform
         * @interface IActionDescriptor
         * @property {string|null} [description] ActionDescriptor description
         * @property {Array.<dataform.IColumnDescriptor>|null} [columns] ActionDescriptor columns
         * @property {Object.<string,string>|null} [bigqueryLabels] ActionDescriptor bigqueryLabels
         */

        /**
         * Constructs a new ActionDescriptor.
         * @memberof dataform
         * @classdesc Represents an ActionDescriptor.
         * @implements IActionDescriptor
         * @constructor
         * @param {dataform.IActionDescriptor=} [properties] Properties to set
         */
        function ActionDescriptor(properties) {
            this.columns = [];
            this.bigqueryLabels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionDescriptor description.
         * @member {string} description
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.description = "";

        /**
         * ActionDescriptor columns.
         * @member {Array.<dataform.IColumnDescriptor>} columns
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.columns = $util.emptyArray;

        /**
         * ActionDescriptor bigqueryLabels.
         * @member {Object.<string,string>} bigqueryLabels
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.bigqueryLabels = $util.emptyObject;

        /**
         * Creates a new ActionDescriptor instance using the specified properties.
         * @function create
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor=} [properties] Properties to set
         * @returns {dataform.ActionDescriptor} ActionDescriptor instance
         */
        ActionDescriptor.create = function create(properties) {
            return new ActionDescriptor(properties);
        };

        /**
         * Encodes the specified ActionDescriptor message. Does not implicitly {@link dataform.ActionDescriptor.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor} message ActionDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.columns != null && message.columns.length)
                for (let i = 0; i < message.columns.length; ++i)
                    $root.dataform.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.bigqueryLabels != null && message.hasOwnProperty("bigqueryLabels"))
                for (let keys = Object.keys(message.bigqueryLabels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.bigqueryLabels[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionDescriptor message, length delimited. Does not implicitly {@link dataform.ActionDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor} message ActionDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionDescriptor(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push($root.dataform.ColumnDescriptor.decode(reader, reader.uint32()));
                    break;
                case 3:
                    reader.skip().pos++;
                    if (message.bigqueryLabels === $util.emptyObject)
                        message.bigqueryLabels = {};
                    key = reader.string();
                    reader.pos++;
                    message.bigqueryLabels[key] = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionDescriptor message.
         * @function verify
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (let i = 0; i < message.columns.length; ++i) {
                    let error = $root.dataform.ColumnDescriptor.verify(message.columns[i]);
                    if (error)
                        return "columns." + error;
                }
            }
            if (message.bigqueryLabels != null && message.hasOwnProperty("bigqueryLabels")) {
                if (!$util.isObject(message.bigqueryLabels))
                    return "bigqueryLabels: object expected";
                let key = Object.keys(message.bigqueryLabels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.bigqueryLabels[key[i]]))
                        return "bigqueryLabels: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates an ActionDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         */
        ActionDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionDescriptor)
                return object;
            let message = new $root.dataform.ActionDescriptor();
            if (object.description != null)
                message.description = String(object.description);
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".dataform.ActionDescriptor.columns: array expected");
                message.columns = [];
                for (let i = 0; i < object.columns.length; ++i) {
                    if (typeof object.columns[i] !== "object")
                        throw TypeError(".dataform.ActionDescriptor.columns: object expected");
                    message.columns[i] = $root.dataform.ColumnDescriptor.fromObject(object.columns[i]);
                }
            }
            if (object.bigqueryLabels) {
                if (typeof object.bigqueryLabels !== "object")
                    throw TypeError(".dataform.ActionDescriptor.bigqueryLabels: object expected");
                message.bigqueryLabels = {};
                for (let keys = Object.keys(object.bigqueryLabels), i = 0; i < keys.length; ++i)
                    message.bigqueryLabels[keys[i]] = String(object.bigqueryLabels[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.ActionDescriptor} message ActionDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.columns = [];
            if (options.objects || options.defaults)
                object.bigqueryLabels = {};
            if (options.defaults)
                object.description = "";
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (let j = 0; j < message.columns.length; ++j)
                    object.columns[j] = $root.dataform.ColumnDescriptor.toObject(message.columns[j], options);
            }
            let keys2;
            if (message.bigqueryLabels && (keys2 = Object.keys(message.bigqueryLabels)).length) {
                object.bigqueryLabels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.bigqueryLabels[keys2[j]] = message.bigqueryLabels[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this ActionDescriptor to JSON.
         * @function toJSON
         * @memberof dataform.ActionDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActionDescriptor;
    })();

    dataform.ColumnDescriptor = (function() {

        /**
         * Properties of a ColumnDescriptor.
         * @memberof dataform
         * @interface IColumnDescriptor
         * @property {string|null} [description] ColumnDescriptor description
         * @property {Array.<string>|null} [path] ColumnDescriptor path
         * @property {string|null} [displayName] ColumnDescriptor displayName
         * @property {dataform.ColumnDescriptor.DimensionType|null} [dimensionType] ColumnDescriptor dimensionType
         * @property {dataform.ColumnDescriptor.Aggregation|null} [aggregation] ColumnDescriptor aggregation
         * @property {string|null} [expression] ColumnDescriptor expression
         * @property {Array.<string>|null} [tags] ColumnDescriptor tags
         * @property {Array.<string>|null} [bigqueryPolicyTags] ColumnDescriptor bigqueryPolicyTags
         */

        /**
         * Constructs a new ColumnDescriptor.
         * @memberof dataform
         * @classdesc Represents a ColumnDescriptor.
         * @implements IColumnDescriptor
         * @constructor
         * @param {dataform.IColumnDescriptor=} [properties] Properties to set
         */
        function ColumnDescriptor(properties) {
            this.path = [];
            this.tags = [];
            this.bigqueryPolicyTags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColumnDescriptor description.
         * @member {string} description
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.description = "";

        /**
         * ColumnDescriptor path.
         * @member {Array.<string>} path
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.path = $util.emptyArray;

        /**
         * ColumnDescriptor displayName.
         * @member {string} displayName
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.displayName = "";

        /**
         * ColumnDescriptor dimensionType.
         * @member {dataform.ColumnDescriptor.DimensionType} dimensionType
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.dimensionType = 0;

        /**
         * ColumnDescriptor aggregation.
         * @member {dataform.ColumnDescriptor.Aggregation} aggregation
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.aggregation = 0;

        /**
         * ColumnDescriptor expression.
         * @member {string} expression
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.expression = "";

        /**
         * ColumnDescriptor tags.
         * @member {Array.<string>} tags
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.tags = $util.emptyArray;

        /**
         * ColumnDescriptor bigqueryPolicyTags.
         * @member {Array.<string>} bigqueryPolicyTags
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.bigqueryPolicyTags = $util.emptyArray;

        /**
         * Creates a new ColumnDescriptor instance using the specified properties.
         * @function create
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor=} [properties] Properties to set
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor instance
         */
        ColumnDescriptor.create = function create(properties) {
            return new ColumnDescriptor(properties);
        };

        /**
         * Encodes the specified ColumnDescriptor message. Does not implicitly {@link dataform.ColumnDescriptor.verify|verify} messages.
         * @function encode
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.path != null && message.path.length)
                for (let i = 0; i < message.path.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path[i]);
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.displayName);
            if (message.dimensionType != null && message.hasOwnProperty("dimensionType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.dimensionType);
            if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.aggregation);
            if (message.expression != null && message.hasOwnProperty("expression"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.expression);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.tags[i]);
            if (message.bigqueryPolicyTags != null && message.bigqueryPolicyTags.length)
                for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.bigqueryPolicyTags[i]);
            return writer;
        };

        /**
         * Encodes the specified ColumnDescriptor message, length delimited. Does not implicitly {@link dataform.ColumnDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColumnDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ColumnDescriptor();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    if (!(message.path && message.path.length))
                        message.path = [];
                    message.path.push(reader.string());
                    break;
                case 3:
                    message.displayName = reader.string();
                    break;
                case 4:
                    message.dimensionType = reader.int32();
                    break;
                case 5:
                    message.aggregation = reader.int32();
                    break;
                case 6:
                    message.expression = reader.string();
                    break;
                case 7:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 8:
                    if (!(message.bigqueryPolicyTags && message.bigqueryPolicyTags.length))
                        message.bigqueryPolicyTags = [];
                    message.bigqueryPolicyTags.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColumnDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColumnDescriptor message.
         * @function verify
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColumnDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (let i = 0; i < message.path.length; ++i)
                    if (!$util.isString(message.path[i]))
                        return "path: string[] expected";
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                if (!$util.isString(message.displayName))
                    return "displayName: string expected";
            if (message.dimensionType != null && message.hasOwnProperty("dimensionType"))
                switch (message.dimensionType) {
                default:
                    return "dimensionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                switch (message.aggregation) {
                default:
                    return "aggregation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.expression != null && message.hasOwnProperty("expression"))
                if (!$util.isString(message.expression))
                    return "expression: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.bigqueryPolicyTags != null && message.hasOwnProperty("bigqueryPolicyTags")) {
                if (!Array.isArray(message.bigqueryPolicyTags))
                    return "bigqueryPolicyTags: array expected";
                for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                    if (!$util.isString(message.bigqueryPolicyTags[i]))
                        return "bigqueryPolicyTags: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ColumnDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         */
        ColumnDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ColumnDescriptor)
                return object;
            let message = new $root.dataform.ColumnDescriptor();
            if (object.description != null)
                message.description = String(object.description);
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".dataform.ColumnDescriptor.path: array expected");
                message.path = [];
                for (let i = 0; i < object.path.length; ++i)
                    message.path[i] = String(object.path[i]);
            }
            if (object.displayName != null)
                message.displayName = String(object.displayName);
            switch (object.dimensionType) {
            case "UNKNOWN_DIMENSION":
            case 0:
                message.dimensionType = 0;
                break;
            case "CATEGORY":
            case 1:
                message.dimensionType = 1;
                break;
            case "TIMESTAMP":
            case 2:
                message.dimensionType = 2;
                break;
            case "NUMBER":
            case 3:
                message.dimensionType = 3;
                break;
            }
            switch (object.aggregation) {
            case "UNKNOWN_AGGREGATION":
            case 0:
                message.aggregation = 0;
                break;
            case "SUM":
            case 1:
                message.aggregation = 1;
                break;
            case "DISTINCT":
            case 2:
                message.aggregation = 2;
                break;
            case "DERIVED":
            case 3:
                message.aggregation = 3;
                break;
            }
            if (object.expression != null)
                message.expression = String(object.expression);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.ColumnDescriptor.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.bigqueryPolicyTags) {
                if (!Array.isArray(object.bigqueryPolicyTags))
                    throw TypeError(".dataform.ColumnDescriptor.bigqueryPolicyTags: array expected");
                message.bigqueryPolicyTags = [];
                for (let i = 0; i < object.bigqueryPolicyTags.length; ++i)
                    message.bigqueryPolicyTags[i] = String(object.bigqueryPolicyTags[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ColumnDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.ColumnDescriptor} message ColumnDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColumnDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.path = [];
                object.tags = [];
                object.bigqueryPolicyTags = [];
            }
            if (options.defaults) {
                object.description = "";
                object.displayName = "";
                object.dimensionType = options.enums === String ? "UNKNOWN_DIMENSION" : 0;
                object.aggregation = options.enums === String ? "UNKNOWN_AGGREGATION" : 0;
                object.expression = "";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.path && message.path.length) {
                object.path = [];
                for (let j = 0; j < message.path.length; ++j)
                    object.path[j] = message.path[j];
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                object.displayName = message.displayName;
            if (message.dimensionType != null && message.hasOwnProperty("dimensionType"))
                object.dimensionType = options.enums === String ? $root.dataform.ColumnDescriptor.DimensionType[message.dimensionType] : message.dimensionType;
            if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                object.aggregation = options.enums === String ? $root.dataform.ColumnDescriptor.Aggregation[message.aggregation] : message.aggregation;
            if (message.expression != null && message.hasOwnProperty("expression"))
                object.expression = message.expression;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.bigqueryPolicyTags && message.bigqueryPolicyTags.length) {
                object.bigqueryPolicyTags = [];
                for (let j = 0; j < message.bigqueryPolicyTags.length; ++j)
                    object.bigqueryPolicyTags[j] = message.bigqueryPolicyTags[j];
            }
            return object;
        };

        /**
         * Converts this ColumnDescriptor to JSON.
         * @function toJSON
         * @memberof dataform.ColumnDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColumnDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * DimensionType enum.
         * @name dataform.ColumnDescriptor.DimensionType
         * @enum {string}
         * @property {number} UNKNOWN_DIMENSION=0 UNKNOWN_DIMENSION value
         * @property {number} CATEGORY=1 CATEGORY value
         * @property {number} TIMESTAMP=2 TIMESTAMP value
         * @property {number} NUMBER=3 NUMBER value
         */
        ColumnDescriptor.DimensionType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_DIMENSION"] = 0;
            values[valuesById[1] = "CATEGORY"] = 1;
            values[valuesById[2] = "TIMESTAMP"] = 2;
            values[valuesById[3] = "NUMBER"] = 3;
            return values;
        })();

        /**
         * Aggregation enum.
         * @name dataform.ColumnDescriptor.Aggregation
         * @enum {string}
         * @property {number} UNKNOWN_AGGREGATION=0 UNKNOWN_AGGREGATION value
         * @property {number} SUM=1 SUM value
         * @property {number} DISTINCT=2 DISTINCT value
         * @property {number} DERIVED=3 DERIVED value
         */
        ColumnDescriptor.Aggregation = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_AGGREGATION"] = 0;
            values[valuesById[1] = "SUM"] = 1;
            values[valuesById[2] = "DISTINCT"] = 2;
            values[valuesById[3] = "DERIVED"] = 3;
            return values;
        })();

        return ColumnDescriptor;
    })();

    dataform.Table = (function() {

        /**
         * Properties of a Table.
         * @memberof dataform
         * @interface ITable
         * @property {dataform.ITarget|null} [target] Table target
         * @property {dataform.ITarget|null} [canonicalTarget] Table canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Table dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Table hermeticity
         * @property {boolean|null} [disabled] Table disabled
         * @property {string|null} [type] Table type
         * @property {string|null} [query] Table query
         * @property {boolean|null} ["protected"] Table protected
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Table actionDescriptor
         * @property {Array.<string>|null} [tags] Table tags
         * @property {string|null} [where] Table where
         * @property {string|null} [incrementalQuery] Table incrementalQuery
         * @property {Array.<string>|null} [uniqueKey] Table uniqueKey
         * @property {Array.<string>|null} [preOps] Table preOps
         * @property {Array.<string>|null} [postOps] Table postOps
         * @property {Array.<string>|null} [incrementalPreOps] Table incrementalPreOps
         * @property {Array.<string>|null} [incrementalPostOps] Table incrementalPostOps
         * @property {dataform.IRedshiftOptions|null} [redshift] Table redshift
         * @property {dataform.IBigQueryOptions|null} [bigquery] Table bigquery
         * @property {dataform.ISnowflakeOptions|null} [snowflake] Table snowflake
         * @property {dataform.ISQLDataWarehouseOptions|null} [sqlDataWarehouse] Table sqlDataWarehouse
         * @property {dataform.IPrestoOptions|null} [presto] Table presto
         * @property {string|null} [fileName] Table fileName
         * @property {Array.<string>|null} [deprecatedParsedColumns] Table deprecatedParsedColumns
         * @property {Array.<dataform.IValidationError>|null} [deprecatedValidationErrors] Table deprecatedValidationErrors
         * @property {string|null} [name] Table name
         * @property {Array.<string>|null} [dependencies] Table dependencies
         */

        /**
         * Constructs a new Table.
         * @memberof dataform
         * @classdesc Represents a Table.
         * @implements ITable
         * @constructor
         * @param {dataform.ITable=} [properties] Properties to set
         */
        function Table(properties) {
            this.dependencyTargets = [];
            this.tags = [];
            this.uniqueKey = [];
            this.preOps = [];
            this.postOps = [];
            this.incrementalPreOps = [];
            this.incrementalPostOps = [];
            this.deprecatedParsedColumns = [];
            this.deprecatedValidationErrors = [];
            this.dependencies = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Table target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.target = null;

        /**
         * Table canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.canonicalTarget = null;

        /**
         * Table dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Table hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.hermeticity = 0;

        /**
         * Table disabled.
         * @member {boolean} disabled
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.disabled = false;

        /**
         * Table type.
         * @member {string} type
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.type = "";

        /**
         * Table query.
         * @member {string} query
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.query = "";

        /**
         * Table protected.
         * @member {boolean} protected
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype["protected"] = false;

        /**
         * Table actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.actionDescriptor = null;

        /**
         * Table tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.tags = $util.emptyArray;

        /**
         * Table where.
         * @member {string} where
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.where = "";

        /**
         * Table incrementalQuery.
         * @member {string} incrementalQuery
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalQuery = "";

        /**
         * Table uniqueKey.
         * @member {Array.<string>} uniqueKey
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.uniqueKey = $util.emptyArray;

        /**
         * Table preOps.
         * @member {Array.<string>} preOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.preOps = $util.emptyArray;

        /**
         * Table postOps.
         * @member {Array.<string>} postOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.postOps = $util.emptyArray;

        /**
         * Table incrementalPreOps.
         * @member {Array.<string>} incrementalPreOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalPreOps = $util.emptyArray;

        /**
         * Table incrementalPostOps.
         * @member {Array.<string>} incrementalPostOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalPostOps = $util.emptyArray;

        /**
         * Table redshift.
         * @member {dataform.IRedshiftOptions|null|undefined} redshift
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.redshift = null;

        /**
         * Table bigquery.
         * @member {dataform.IBigQueryOptions|null|undefined} bigquery
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.bigquery = null;

        /**
         * Table snowflake.
         * @member {dataform.ISnowflakeOptions|null|undefined} snowflake
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.snowflake = null;

        /**
         * Table sqlDataWarehouse.
         * @member {dataform.ISQLDataWarehouseOptions|null|undefined} sqlDataWarehouse
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.sqlDataWarehouse = null;

        /**
         * Table presto.
         * @member {dataform.IPrestoOptions|null|undefined} presto
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.presto = null;

        /**
         * Table fileName.
         * @member {string} fileName
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.fileName = "";

        /**
         * Table deprecatedParsedColumns.
         * @member {Array.<string>} deprecatedParsedColumns
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.deprecatedParsedColumns = $util.emptyArray;

        /**
         * Table deprecatedValidationErrors.
         * @member {Array.<dataform.IValidationError>} deprecatedValidationErrors
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.deprecatedValidationErrors = $util.emptyArray;

        /**
         * Table name.
         * @member {string} name
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.name = "";

        /**
         * Table dependencies.
         * @member {Array.<string>} dependencies
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.dependencies = $util.emptyArray;

        /**
         * Creates a new Table instance using the specified properties.
         * @function create
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable=} [properties] Properties to set
         * @returns {dataform.Table} Table instance
         */
        Table.create = function create(properties) {
            return new Table(properties);
        };

        /**
         * Encodes the specified Table message. Does not implicitly {@link dataform.Table.verify|verify} messages.
         * @function encode
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.dependencies != null && message.dependencies.length)
                for (let i = 0; i < message.dependencies.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dependencies[i]);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.query);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disabled);
            if (message.deprecatedValidationErrors != null && message.deprecatedValidationErrors.length)
                for (let i = 0; i < message.deprecatedValidationErrors.length; ++i)
                    $root.dataform.ValidationError.encode(message.deprecatedValidationErrors[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.where != null && message.hasOwnProperty("where"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.where);
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message["protected"]);
            if (message.deprecatedParsedColumns != null && message.deprecatedParsedColumns.length)
                for (let i = 0; i < message.deprecatedParsedColumns.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.deprecatedParsedColumns[i]);
            if (message.preOps != null && message.preOps.length)
                for (let i = 0; i < message.preOps.length; ++i)
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.preOps[i]);
            if (message.postOps != null && message.postOps.length)
                for (let i = 0; i < message.postOps.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.postOps[i]);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.fileName);
            if (message.redshift != null && message.hasOwnProperty("redshift"))
                $root.dataform.RedshiftOptions.encode(message.redshift, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                $root.dataform.BigQueryOptions.encode(message.bigquery, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 23, wireType 2 =*/186).string(message.tags[i]);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.sqlDataWarehouse != null && message.hasOwnProperty("sqlDataWarehouse"))
                $root.dataform.SQLDataWarehouseOptions.encode(message.sqlDataWarehouse, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.incrementalQuery);
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.incrementalPreOps != null && message.incrementalPreOps.length)
                for (let i = 0; i < message.incrementalPreOps.length; ++i)
                    writer.uint32(/* id 28, wireType 2 =*/226).string(message.incrementalPreOps[i]);
            if (message.incrementalPostOps != null && message.incrementalPostOps.length)
                for (let i = 0; i < message.incrementalPostOps.length; ++i)
                    writer.uint32(/* id 29, wireType 2 =*/234).string(message.incrementalPostOps[i]);
            if (message.uniqueKey != null && message.uniqueKey.length)
                for (let i = 0; i < message.uniqueKey.length; ++i)
                    writer.uint32(/* id 30, wireType 2 =*/242).string(message.uniqueKey[i]);
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.hermeticity);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.snowflake != null && message.hasOwnProperty("snowflake"))
                $root.dataform.SnowflakeOptions.encode(message.snowflake, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.presto != null && message.hasOwnProperty("presto"))
                $root.dataform.PrestoOptions.encode(message.presto, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Table message, length delimited. Does not implicitly {@link dataform.Table.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Table message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Table();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 27:
                    if (!(message.dependencyTargets && message.dependencyTargets.length))
                        message.dependencyTargets = [];
                    message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 31:
                    message.hermeticity = reader.int32();
                    break;
                case 6:
                    message.disabled = reader.bool();
                    break;
                case 3:
                    message.type = reader.string();
                    break;
                case 5:
                    message.query = reader.string();
                    break;
                case 9:
                    message["protected"] = reader.bool();
                    break;
                case 24:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                case 23:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 8:
                    message.where = reader.string();
                    break;
                case 26:
                    message.incrementalQuery = reader.string();
                    break;
                case 30:
                    if (!(message.uniqueKey && message.uniqueKey.length))
                        message.uniqueKey = [];
                    message.uniqueKey.push(reader.string());
                    break;
                case 13:
                    if (!(message.preOps && message.preOps.length))
                        message.preOps = [];
                    message.preOps.push(reader.string());
                    break;
                case 14:
                    if (!(message.postOps && message.postOps.length))
                        message.postOps = [];
                    message.postOps.push(reader.string());
                    break;
                case 28:
                    if (!(message.incrementalPreOps && message.incrementalPreOps.length))
                        message.incrementalPreOps = [];
                    message.incrementalPreOps.push(reader.string());
                    break;
                case 29:
                    if (!(message.incrementalPostOps && message.incrementalPostOps.length))
                        message.incrementalPostOps = [];
                    message.incrementalPostOps.push(reader.string());
                    break;
                case 21:
                    message.redshift = $root.dataform.RedshiftOptions.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.bigquery = $root.dataform.BigQueryOptions.decode(reader, reader.uint32());
                    break;
                case 33:
                    message.snowflake = $root.dataform.SnowflakeOptions.decode(reader, reader.uint32());
                    break;
                case 25:
                    message.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.decode(reader, reader.uint32());
                    break;
                case 34:
                    message.presto = $root.dataform.PrestoOptions.decode(reader, reader.uint32());
                    break;
                case 18:
                    message.fileName = reader.string();
                    break;
                case 12:
                    if (!(message.deprecatedParsedColumns && message.deprecatedParsedColumns.length))
                        message.deprecatedParsedColumns = [];
                    message.deprecatedParsedColumns.push(reader.string());
                    break;
                case 7:
                    if (!(message.deprecatedValidationErrors && message.deprecatedValidationErrors.length))
                        message.deprecatedValidationErrors = [];
                    message.deprecatedValidationErrors.push($root.dataform.ValidationError.decode(reader, reader.uint32()));
                    break;
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.dependencies && message.dependencies.length))
                        message.dependencies = [];
                    message.dependencies.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Table message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Table message.
         * @function verify
         * @memberof dataform.Table
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Table.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                if (typeof message["protected"] !== "boolean")
                    return "protected: boolean expected";
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.where != null && message.hasOwnProperty("where"))
                if (!$util.isString(message.where))
                    return "where: string expected";
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                if (!$util.isString(message.incrementalQuery))
                    return "incrementalQuery: string expected";
            if (message.uniqueKey != null && message.hasOwnProperty("uniqueKey")) {
                if (!Array.isArray(message.uniqueKey))
                    return "uniqueKey: array expected";
                for (let i = 0; i < message.uniqueKey.length; ++i)
                    if (!$util.isString(message.uniqueKey[i]))
                        return "uniqueKey: string[] expected";
            }
            if (message.preOps != null && message.hasOwnProperty("preOps")) {
                if (!Array.isArray(message.preOps))
                    return "preOps: array expected";
                for (let i = 0; i < message.preOps.length; ++i)
                    if (!$util.isString(message.preOps[i]))
                        return "preOps: string[] expected";
            }
            if (message.postOps != null && message.hasOwnProperty("postOps")) {
                if (!Array.isArray(message.postOps))
                    return "postOps: array expected";
                for (let i = 0; i < message.postOps.length; ++i)
                    if (!$util.isString(message.postOps[i]))
                        return "postOps: string[] expected";
            }
            if (message.incrementalPreOps != null && message.hasOwnProperty("incrementalPreOps")) {
                if (!Array.isArray(message.incrementalPreOps))
                    return "incrementalPreOps: array expected";
                for (let i = 0; i < message.incrementalPreOps.length; ++i)
                    if (!$util.isString(message.incrementalPreOps[i]))
                        return "incrementalPreOps: string[] expected";
            }
            if (message.incrementalPostOps != null && message.hasOwnProperty("incrementalPostOps")) {
                if (!Array.isArray(message.incrementalPostOps))
                    return "incrementalPostOps: array expected";
                for (let i = 0; i < message.incrementalPostOps.length; ++i)
                    if (!$util.isString(message.incrementalPostOps[i]))
                        return "incrementalPostOps: string[] expected";
            }
            if (message.redshift != null && message.hasOwnProperty("redshift")) {
                let error = $root.dataform.RedshiftOptions.verify(message.redshift);
                if (error)
                    return "redshift." + error;
            }
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.BigQueryOptions.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            if (message.snowflake != null && message.hasOwnProperty("snowflake")) {
                let error = $root.dataform.SnowflakeOptions.verify(message.snowflake);
                if (error)
                    return "snowflake." + error;
            }
            if (message.sqlDataWarehouse != null && message.hasOwnProperty("sqlDataWarehouse")) {
                let error = $root.dataform.SQLDataWarehouseOptions.verify(message.sqlDataWarehouse);
                if (error)
                    return "sqlDataWarehouse." + error;
            }
            if (message.presto != null && message.hasOwnProperty("presto")) {
                let error = $root.dataform.PrestoOptions.verify(message.presto);
                if (error)
                    return "presto." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.deprecatedParsedColumns != null && message.hasOwnProperty("deprecatedParsedColumns")) {
                if (!Array.isArray(message.deprecatedParsedColumns))
                    return "deprecatedParsedColumns: array expected";
                for (let i = 0; i < message.deprecatedParsedColumns.length; ++i)
                    if (!$util.isString(message.deprecatedParsedColumns[i]))
                        return "deprecatedParsedColumns: string[] expected";
            }
            if (message.deprecatedValidationErrors != null && message.hasOwnProperty("deprecatedValidationErrors")) {
                if (!Array.isArray(message.deprecatedValidationErrors))
                    return "deprecatedValidationErrors: array expected";
                for (let i = 0; i < message.deprecatedValidationErrors.length; ++i) {
                    let error = $root.dataform.ValidationError.verify(message.deprecatedValidationErrors[i]);
                    if (error)
                        return "deprecatedValidationErrors." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                if (!Array.isArray(message.dependencies))
                    return "dependencies: array expected";
                for (let i = 0; i < message.dependencies.length; ++i)
                    if (!$util.isString(message.dependencies[i]))
                        return "dependencies: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Table message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Table
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Table} Table
         */
        Table.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Table)
                return object;
            let message = new $root.dataform.Table();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Table.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Table.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Table.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Table.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.type != null)
                message.type = String(object.type);
            if (object.query != null)
                message.query = String(object.query);
            if (object["protected"] != null)
                message["protected"] = Boolean(object["protected"]);
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Table.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Table.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.where != null)
                message.where = String(object.where);
            if (object.incrementalQuery != null)
                message.incrementalQuery = String(object.incrementalQuery);
            if (object.uniqueKey) {
                if (!Array.isArray(object.uniqueKey))
                    throw TypeError(".dataform.Table.uniqueKey: array expected");
                message.uniqueKey = [];
                for (let i = 0; i < object.uniqueKey.length; ++i)
                    message.uniqueKey[i] = String(object.uniqueKey[i]);
            }
            if (object.preOps) {
                if (!Array.isArray(object.preOps))
                    throw TypeError(".dataform.Table.preOps: array expected");
                message.preOps = [];
                for (let i = 0; i < object.preOps.length; ++i)
                    message.preOps[i] = String(object.preOps[i]);
            }
            if (object.postOps) {
                if (!Array.isArray(object.postOps))
                    throw TypeError(".dataform.Table.postOps: array expected");
                message.postOps = [];
                for (let i = 0; i < object.postOps.length; ++i)
                    message.postOps[i] = String(object.postOps[i]);
            }
            if (object.incrementalPreOps) {
                if (!Array.isArray(object.incrementalPreOps))
                    throw TypeError(".dataform.Table.incrementalPreOps: array expected");
                message.incrementalPreOps = [];
                for (let i = 0; i < object.incrementalPreOps.length; ++i)
                    message.incrementalPreOps[i] = String(object.incrementalPreOps[i]);
            }
            if (object.incrementalPostOps) {
                if (!Array.isArray(object.incrementalPostOps))
                    throw TypeError(".dataform.Table.incrementalPostOps: array expected");
                message.incrementalPostOps = [];
                for (let i = 0; i < object.incrementalPostOps.length; ++i)
                    message.incrementalPostOps[i] = String(object.incrementalPostOps[i]);
            }
            if (object.redshift != null) {
                if (typeof object.redshift !== "object")
                    throw TypeError(".dataform.Table.redshift: object expected");
                message.redshift = $root.dataform.RedshiftOptions.fromObject(object.redshift);
            }
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.Table.bigquery: object expected");
                message.bigquery = $root.dataform.BigQueryOptions.fromObject(object.bigquery);
            }
            if (object.snowflake != null) {
                if (typeof object.snowflake !== "object")
                    throw TypeError(".dataform.Table.snowflake: object expected");
                message.snowflake = $root.dataform.SnowflakeOptions.fromObject(object.snowflake);
            }
            if (object.sqlDataWarehouse != null) {
                if (typeof object.sqlDataWarehouse !== "object")
                    throw TypeError(".dataform.Table.sqlDataWarehouse: object expected");
                message.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.fromObject(object.sqlDataWarehouse);
            }
            if (object.presto != null) {
                if (typeof object.presto !== "object")
                    throw TypeError(".dataform.Table.presto: object expected");
                message.presto = $root.dataform.PrestoOptions.fromObject(object.presto);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.deprecatedParsedColumns) {
                if (!Array.isArray(object.deprecatedParsedColumns))
                    throw TypeError(".dataform.Table.deprecatedParsedColumns: array expected");
                message.deprecatedParsedColumns = [];
                for (let i = 0; i < object.deprecatedParsedColumns.length; ++i)
                    message.deprecatedParsedColumns[i] = String(object.deprecatedParsedColumns[i]);
            }
            if (object.deprecatedValidationErrors) {
                if (!Array.isArray(object.deprecatedValidationErrors))
                    throw TypeError(".dataform.Table.deprecatedValidationErrors: array expected");
                message.deprecatedValidationErrors = [];
                for (let i = 0; i < object.deprecatedValidationErrors.length; ++i) {
                    if (typeof object.deprecatedValidationErrors[i] !== "object")
                        throw TypeError(".dataform.Table.deprecatedValidationErrors: object expected");
                    message.deprecatedValidationErrors[i] = $root.dataform.ValidationError.fromObject(object.deprecatedValidationErrors[i]);
                }
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.dependencies) {
                if (!Array.isArray(object.dependencies))
                    throw TypeError(".dataform.Table.dependencies: array expected");
                message.dependencies = [];
                for (let i = 0; i < object.dependencies.length; ++i)
                    message.dependencies[i] = String(object.dependencies[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Table message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Table
         * @static
         * @param {dataform.Table} message Table
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Table.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.dependencies = [];
                object.deprecatedValidationErrors = [];
                object.deprecatedParsedColumns = [];
                object.preOps = [];
                object.postOps = [];
                object.tags = [];
                object.dependencyTargets = [];
                object.incrementalPreOps = [];
                object.incrementalPostOps = [];
                object.uniqueKey = [];
            }
            if (options.defaults) {
                object.name = "";
                object.type = "";
                object.target = null;
                object.query = "";
                object.disabled = false;
                object.where = "";
                object["protected"] = false;
                object.fileName = "";
                object.redshift = null;
                object.bigquery = null;
                object.actionDescriptor = null;
                object.sqlDataWarehouse = null;
                object.incrementalQuery = "";
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.snowflake = null;
                object.presto = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.dependencies && message.dependencies.length) {
                object.dependencies = [];
                for (let j = 0; j < message.dependencies.length; ++j)
                    object.dependencies[j] = message.dependencies[j];
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.deprecatedValidationErrors && message.deprecatedValidationErrors.length) {
                object.deprecatedValidationErrors = [];
                for (let j = 0; j < message.deprecatedValidationErrors.length; ++j)
                    object.deprecatedValidationErrors[j] = $root.dataform.ValidationError.toObject(message.deprecatedValidationErrors[j], options);
            }
            if (message.where != null && message.hasOwnProperty("where"))
                object.where = message.where;
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                object["protected"] = message["protected"];
            if (message.deprecatedParsedColumns && message.deprecatedParsedColumns.length) {
                object.deprecatedParsedColumns = [];
                for (let j = 0; j < message.deprecatedParsedColumns.length; ++j)
                    object.deprecatedParsedColumns[j] = message.deprecatedParsedColumns[j];
            }
            if (message.preOps && message.preOps.length) {
                object.preOps = [];
                for (let j = 0; j < message.preOps.length; ++j)
                    object.preOps[j] = message.preOps[j];
            }
            if (message.postOps && message.postOps.length) {
                object.postOps = [];
                for (let j = 0; j < message.postOps.length; ++j)
                    object.postOps[j] = message.postOps[j];
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.redshift != null && message.hasOwnProperty("redshift"))
                object.redshift = $root.dataform.RedshiftOptions.toObject(message.redshift, options);
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.BigQueryOptions.toObject(message.bigquery, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.sqlDataWarehouse != null && message.hasOwnProperty("sqlDataWarehouse"))
                object.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.toObject(message.sqlDataWarehouse, options);
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                object.incrementalQuery = message.incrementalQuery;
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.incrementalPreOps && message.incrementalPreOps.length) {
                object.incrementalPreOps = [];
                for (let j = 0; j < message.incrementalPreOps.length; ++j)
                    object.incrementalPreOps[j] = message.incrementalPreOps[j];
            }
            if (message.incrementalPostOps && message.incrementalPostOps.length) {
                object.incrementalPostOps = [];
                for (let j = 0; j < message.incrementalPostOps.length; ++j)
                    object.incrementalPostOps[j] = message.incrementalPostOps[j];
            }
            if (message.uniqueKey && message.uniqueKey.length) {
                object.uniqueKey = [];
                for (let j = 0; j < message.uniqueKey.length; ++j)
                    object.uniqueKey[j] = message.uniqueKey[j];
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.snowflake != null && message.hasOwnProperty("snowflake"))
                object.snowflake = $root.dataform.SnowflakeOptions.toObject(message.snowflake, options);
            if (message.presto != null && message.hasOwnProperty("presto"))
                object.presto = $root.dataform.PrestoOptions.toObject(message.presto, options);
            return object;
        };

        /**
         * Converts this Table to JSON.
         * @function toJSON
         * @memberof dataform.Table
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Table.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Table;
    })();

    dataform.Operation = (function() {

        /**
         * Properties of an Operation.
         * @memberof dataform
         * @interface IOperation
         * @property {dataform.ITarget|null} [target] Operation target
         * @property {dataform.ITarget|null} [canonicalTarget] Operation canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Operation dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Operation hermeticity
         * @property {boolean|null} [disabled] Operation disabled
         * @property {Array.<string>|null} [queries] Operation queries
         * @property {boolean|null} [hasOutput] Operation hasOutput
         * @property {Array.<string>|null} [tags] Operation tags
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Operation actionDescriptor
         * @property {string|null} [fileName] Operation fileName
         * @property {string|null} [name] Operation name
         * @property {Array.<string>|null} [dependencies] Operation dependencies
         */

        /**
         * Constructs a new Operation.
         * @memberof dataform
         * @classdesc Represents an Operation.
         * @implements IOperation
         * @constructor
         * @param {dataform.IOperation=} [properties] Properties to set
         */
        function Operation(properties) {
            this.dependencyTargets = [];
            this.queries = [];
            this.tags = [];
            this.dependencies = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Operation target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.target = null;

        /**
         * Operation canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.canonicalTarget = null;

        /**
         * Operation dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Operation hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.hermeticity = 0;

        /**
         * Operation disabled.
         * @member {boolean} disabled
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.disabled = false;

        /**
         * Operation queries.
         * @member {Array.<string>} queries
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.queries = $util.emptyArray;

        /**
         * Operation hasOutput.
         * @member {boolean} hasOutput
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.hasOutput = false;

        /**
         * Operation tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.tags = $util.emptyArray;

        /**
         * Operation actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.actionDescriptor = null;

        /**
         * Operation fileName.
         * @member {string} fileName
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.fileName = "";

        /**
         * Operation name.
         * @member {string} name
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.name = "";

        /**
         * Operation dependencies.
         * @member {Array.<string>} dependencies
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.dependencies = $util.emptyArray;

        /**
         * Creates a new Operation instance using the specified properties.
         * @function create
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation=} [properties] Properties to set
         * @returns {dataform.Operation} Operation instance
         */
        Operation.create = function create(properties) {
            return new Operation(properties);
        };

        /**
         * Encodes the specified Operation message. Does not implicitly {@link dataform.Operation.verify|verify} messages.
         * @function encode
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation} message Operation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Operation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.dependencies != null && message.dependencies.length)
                for (let i = 0; i < message.dependencies.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dependencies[i]);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.queries != null && message.queries.length)
                for (let i = 0; i < message.queries.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.queries[i]);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasOutput);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags[i]);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.hermeticity);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.disabled);
            return writer;
        };

        /**
         * Encodes the specified Operation message, length delimited. Does not implicitly {@link dataform.Operation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation} message Operation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Operation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Operation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Operation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Operation} Operation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Operation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Operation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.dependencyTargets && message.dependencyTargets.length))
                        message.dependencyTargets = [];
                    message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.hermeticity = reader.int32();
                    break;
                case 14:
                    message.disabled = reader.bool();
                    break;
                case 6:
                    if (!(message.queries && message.queries.length))
                        message.queries = [];
                    message.queries.push(reader.string());
                    break;
                case 8:
                    message.hasOutput = reader.bool();
                    break;
                case 9:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 10:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.fileName = reader.string();
                    break;
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.dependencies && message.dependencies.length))
                        message.dependencies = [];
                    message.dependencies.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Operation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Operation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Operation} Operation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Operation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Operation message.
         * @function verify
         * @memberof dataform.Operation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Operation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.queries != null && message.hasOwnProperty("queries")) {
                if (!Array.isArray(message.queries))
                    return "queries: array expected";
                for (let i = 0; i < message.queries.length; ++i)
                    if (!$util.isString(message.queries[i]))
                        return "queries: string[] expected";
            }
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                if (typeof message.hasOutput !== "boolean")
                    return "hasOutput: boolean expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                if (!Array.isArray(message.dependencies))
                    return "dependencies: array expected";
                for (let i = 0; i < message.dependencies.length; ++i)
                    if (!$util.isString(message.dependencies[i]))
                        return "dependencies: string[] expected";
            }
            return null;
        };

        /**
         * Creates an Operation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Operation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Operation} Operation
         */
        Operation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Operation)
                return object;
            let message = new $root.dataform.Operation();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Operation.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Operation.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Operation.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Operation.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.queries) {
                if (!Array.isArray(object.queries))
                    throw TypeError(".dataform.Operation.queries: array expected");
                message.queries = [];
                for (let i = 0; i < object.queries.length; ++i)
                    message.queries[i] = String(object.queries[i]);
            }
            if (object.hasOutput != null)
                message.hasOutput = Boolean(object.hasOutput);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Operation.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Operation.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.name != null)
                message.name = String(object.name);
            if (object.dependencies) {
                if (!Array.isArray(object.dependencies))
                    throw TypeError(".dataform.Operation.dependencies: array expected");
                message.dependencies = [];
                for (let i = 0; i < object.dependencies.length; ++i)
                    message.dependencies[i] = String(object.dependencies[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an Operation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Operation
         * @static
         * @param {dataform.Operation} message Operation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Operation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.dependencies = [];
                object.queries = [];
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.name = "";
                object.target = null;
                object.fileName = "";
                object.hasOutput = false;
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.disabled = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.dependencies && message.dependencies.length) {
                object.dependencies = [];
                for (let j = 0; j < message.dependencies.length; ++j)
                    object.dependencies[j] = message.dependencies[j];
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.queries && message.queries.length) {
                object.queries = [];
                for (let j = 0; j < message.queries.length; ++j)
                    object.queries[j] = message.queries[j];
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                object.hasOutput = message.hasOutput;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            return object;
        };

        /**
         * Converts this Operation to JSON.
         * @function toJSON
         * @memberof dataform.Operation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Operation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Operation;
    })();

    dataform.Assertion = (function() {

        /**
         * Properties of an Assertion.
         * @memberof dataform
         * @interface IAssertion
         * @property {dataform.ITarget|null} [target] Assertion target
         * @property {dataform.ITarget|null} [canonicalTarget] Assertion canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Assertion dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Assertion hermeticity
         * @property {boolean|null} [disabled] Assertion disabled
         * @property {string|null} [query] Assertion query
         * @property {Array.<string>|null} [tags] Assertion tags
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Assertion actionDescriptor
         * @property {dataform.ITarget|null} [parentAction] Assertion parentAction
         * @property {string|null} [fileName] Assertion fileName
         * @property {string|null} [name] Assertion name
         * @property {Array.<string>|null} [dependencies] Assertion dependencies
         */

        /**
         * Constructs a new Assertion.
         * @memberof dataform
         * @classdesc Represents an Assertion.
         * @implements IAssertion
         * @constructor
         * @param {dataform.IAssertion=} [properties] Properties to set
         */
        function Assertion(properties) {
            this.dependencyTargets = [];
            this.tags = [];
            this.dependencies = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Assertion target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.target = null;

        /**
         * Assertion canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.canonicalTarget = null;

        /**
         * Assertion dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Assertion hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.hermeticity = 0;

        /**
         * Assertion disabled.
         * @member {boolean} disabled
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.disabled = false;

        /**
         * Assertion query.
         * @member {string} query
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.query = "";

        /**
         * Assertion tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.tags = $util.emptyArray;

        /**
         * Assertion actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.actionDescriptor = null;

        /**
         * Assertion parentAction.
         * @member {dataform.ITarget|null|undefined} parentAction
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.parentAction = null;

        /**
         * Assertion fileName.
         * @member {string} fileName
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.fileName = "";

        /**
         * Assertion name.
         * @member {string} name
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.name = "";

        /**
         * Assertion dependencies.
         * @member {Array.<string>} dependencies
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.dependencies = $util.emptyArray;

        /**
         * Creates a new Assertion instance using the specified properties.
         * @function create
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion=} [properties] Properties to set
         * @returns {dataform.Assertion} Assertion instance
         */
        Assertion.create = function create(properties) {
            return new Assertion(properties);
        };

        /**
         * Encodes the specified Assertion message. Does not implicitly {@link dataform.Assertion.verify|verify} messages.
         * @function encode
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion} message Assertion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Assertion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.dependencies != null && message.dependencies.length)
                for (let i = 0; i < message.dependencies.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dependencies[i]);
            if (message.query != null && message.hasOwnProperty("query"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.query);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags[i]);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.hermeticity);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.disabled);
            if (message.parentAction != null && message.hasOwnProperty("parentAction"))
                $root.dataform.Target.encode(message.parentAction, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Assertion message, length delimited. Does not implicitly {@link dataform.Assertion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion} message Assertion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Assertion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Assertion message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Assertion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Assertion} Assertion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Assertion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Assertion();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 8:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.dependencyTargets && message.dependencyTargets.length))
                        message.dependencyTargets = [];
                    message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.hermeticity = reader.int32();
                    break;
                case 14:
                    message.disabled = reader.bool();
                    break;
                case 3:
                    message.query = reader.string();
                    break;
                case 9:
                    if (!(message.tags && message.tags.length))
                        message.tags = [];
                    message.tags.push(reader.string());
                    break;
                case 10:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.parentAction = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.fileName = reader.string();
                    break;
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    if (!(message.dependencies && message.dependencies.length))
                        message.dependencies = [];
                    message.dependencies.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Assertion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Assertion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Assertion} Assertion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Assertion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Assertion message.
         * @function verify
         * @memberof dataform.Assertion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Assertion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.parentAction != null && message.hasOwnProperty("parentAction")) {
                let error = $root.dataform.Target.verify(message.parentAction);
                if (error)
                    return "parentAction." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                if (!Array.isArray(message.dependencies))
                    return "dependencies: array expected";
                for (let i = 0; i < message.dependencies.length; ++i)
                    if (!$util.isString(message.dependencies[i]))
                        return "dependencies: string[] expected";
            }
            return null;
        };

        /**
         * Creates an Assertion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Assertion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Assertion} Assertion
         */
        Assertion.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Assertion)
                return object;
            let message = new $root.dataform.Assertion();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Assertion.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Assertion.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Assertion.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Assertion.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.query != null)
                message.query = String(object.query);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Assertion.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Assertion.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.parentAction != null) {
                if (typeof object.parentAction !== "object")
                    throw TypeError(".dataform.Assertion.parentAction: object expected");
                message.parentAction = $root.dataform.Target.fromObject(object.parentAction);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.name != null)
                message.name = String(object.name);
            if (object.dependencies) {
                if (!Array.isArray(object.dependencies))
                    throw TypeError(".dataform.Assertion.dependencies: array expected");
                message.dependencies = [];
                for (let i = 0; i < object.dependencies.length; ++i)
                    message.dependencies[i] = String(object.dependencies[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an Assertion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.Assertion} message Assertion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Assertion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.dependencies = [];
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.name = "";
                object.query = "";
                object.fileName = "";
                object.target = null;
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.disabled = false;
                object.parentAction = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.dependencies && message.dependencies.length) {
                object.dependencies = [];
                for (let j = 0; j < message.dependencies.length; ++j)
                    object.dependencies[j] = message.dependencies[j];
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.parentAction != null && message.hasOwnProperty("parentAction"))
                object.parentAction = $root.dataform.Target.toObject(message.parentAction, options);
            return object;
        };

        /**
         * Converts this Assertion to JSON.
         * @function toJSON
         * @memberof dataform.Assertion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Assertion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Assertion;
    })();

    /**
     * ActionHermeticity enum.
     * @name dataform.ActionHermeticity
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} HERMETIC=1 HERMETIC value
     * @property {number} NON_HERMETIC=2 NON_HERMETIC value
     */
    dataform.ActionHermeticity = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "HERMETIC"] = 1;
        values[valuesById[2] = "NON_HERMETIC"] = 2;
        return values;
    })();

    dataform.Declaration = (function() {

        /**
         * Properties of a Declaration.
         * @memberof dataform
         * @interface IDeclaration
         * @property {string|null} [name] Declaration name
         * @property {dataform.ITarget|null} [target] Declaration target
         * @property {dataform.ITarget|null} [canonicalTarget] Declaration canonicalTarget
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Declaration actionDescriptor
         * @property {string|null} [fileName] Declaration fileName
         */

        /**
         * Constructs a new Declaration.
         * @memberof dataform
         * @classdesc Represents a Declaration.
         * @implements IDeclaration
         * @constructor
         * @param {dataform.IDeclaration=} [properties] Properties to set
         */
        function Declaration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Declaration name.
         * @member {string} name
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.name = "";

        /**
         * Declaration target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.target = null;

        /**
         * Declaration canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.canonicalTarget = null;

        /**
         * Declaration actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.actionDescriptor = null;

        /**
         * Declaration fileName.
         * @member {string} fileName
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.fileName = "";

        /**
         * Creates a new Declaration instance using the specified properties.
         * @function create
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration=} [properties] Properties to set
         * @returns {dataform.Declaration} Declaration instance
         */
        Declaration.create = function create(properties) {
            return new Declaration(properties);
        };

        /**
         * Encodes the specified Declaration message. Does not implicitly {@link dataform.Declaration.verify|verify} messages.
         * @function encode
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration} message Declaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Declaration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Declaration message, length delimited. Does not implicitly {@link dataform.Declaration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration} message Declaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Declaration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Declaration message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Declaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Declaration} Declaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Declaration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Declaration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.fileName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Declaration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Declaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Declaration} Declaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Declaration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Declaration message.
         * @function verify
         * @memberof dataform.Declaration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Declaration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Declaration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Declaration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Declaration} Declaration
         */
        Declaration.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Declaration)
                return object;
            let message = new $root.dataform.Declaration();
            if (object.name != null)
                message.name = String(object.name);
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Declaration.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Declaration.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Declaration.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Declaration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.Declaration} message Declaration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Declaration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.target = null;
                object.actionDescriptor = null;
                object.fileName = "";
                object.canonicalTarget = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            return object;
        };

        /**
         * Converts this Declaration to JSON.
         * @function toJSON
         * @memberof dataform.Declaration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Declaration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Declaration;
    })();

    dataform.Test = (function() {

        /**
         * Properties of a Test.
         * @memberof dataform
         * @interface ITest
         * @property {string|null} [name] Test name
         * @property {string|null} [testQuery] Test testQuery
         * @property {string|null} [expectedOutputQuery] Test expectedOutputQuery
         * @property {string|null} [fileName] Test fileName
         */

        /**
         * Constructs a new Test.
         * @memberof dataform
         * @classdesc Represents a Test.
         * @implements ITest
         * @constructor
         * @param {dataform.ITest=} [properties] Properties to set
         */
        function Test(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Test name.
         * @member {string} name
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.name = "";

        /**
         * Test testQuery.
         * @member {string} testQuery
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.testQuery = "";

        /**
         * Test expectedOutputQuery.
         * @member {string} expectedOutputQuery
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.expectedOutputQuery = "";

        /**
         * Test fileName.
         * @member {string} fileName
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.fileName = "";

        /**
         * Creates a new Test instance using the specified properties.
         * @function create
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest=} [properties] Properties to set
         * @returns {dataform.Test} Test instance
         */
        Test.create = function create(properties) {
            return new Test(properties);
        };

        /**
         * Encodes the specified Test message. Does not implicitly {@link dataform.Test.verify|verify} messages.
         * @function encode
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest} message Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testQuery);
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.expectedOutputQuery);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            return writer;
        };

        /**
         * Encodes the specified Test message, length delimited. Does not implicitly {@link dataform.Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest} message Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Test message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Test();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.testQuery = reader.string();
                    break;
                case 3:
                    message.expectedOutputQuery = reader.string();
                    break;
                case 4:
                    message.fileName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Test message.
         * @function verify
         * @memberof dataform.Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                if (!$util.isString(message.testQuery))
                    return "testQuery: string expected";
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                if (!$util.isString(message.expectedOutputQuery))
                    return "expectedOutputQuery: string expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Test} Test
         */
        Test.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Test)
                return object;
            let message = new $root.dataform.Test();
            if (object.name != null)
                message.name = String(object.name);
            if (object.testQuery != null)
                message.testQuery = String(object.testQuery);
            if (object.expectedOutputQuery != null)
                message.expectedOutputQuery = String(object.expectedOutputQuery);
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Test
         * @static
         * @param {dataform.Test} message Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.testQuery = "";
                object.expectedOutputQuery = "";
                object.fileName = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                object.testQuery = message.testQuery;
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                object.expectedOutputQuery = message.expectedOutputQuery;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            return object;
        };

        /**
         * Converts this Test to JSON.
         * @function toJSON
         * @memberof dataform.Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Test;
    })();

    dataform.CompiledGraph = (function() {

        /**
         * Properties of a CompiledGraph.
         * @memberof dataform
         * @interface ICompiledGraph
         * @property {dataform.IProjectConfig|null} [projectConfig] CompiledGraph projectConfig
         * @property {Array.<dataform.ITable>|null} [tables] CompiledGraph tables
         * @property {Array.<dataform.IOperation>|null} [operations] CompiledGraph operations
         * @property {Array.<dataform.IAssertion>|null} [assertions] CompiledGraph assertions
         * @property {Array.<dataform.IDeclaration>|null} [declarations] CompiledGraph declarations
         * @property {Array.<dataform.ITest>|null} [tests] CompiledGraph tests
         * @property {dataform.IGraphErrors|null} [graphErrors] CompiledGraph graphErrors
         * @property {string|null} [dataformCoreVersion] CompiledGraph dataformCoreVersion
         * @property {Array.<dataform.ITarget>|null} [targets] CompiledGraph targets
         */

        /**
         * Constructs a new CompiledGraph.
         * @memberof dataform
         * @classdesc Represents a CompiledGraph.
         * @implements ICompiledGraph
         * @constructor
         * @param {dataform.ICompiledGraph=} [properties] Properties to set
         */
        function CompiledGraph(properties) {
            this.tables = [];
            this.operations = [];
            this.assertions = [];
            this.declarations = [];
            this.tests = [];
            this.targets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompiledGraph projectConfig.
         * @member {dataform.IProjectConfig|null|undefined} projectConfig
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.projectConfig = null;

        /**
         * CompiledGraph tables.
         * @member {Array.<dataform.ITable>} tables
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.tables = $util.emptyArray;

        /**
         * CompiledGraph operations.
         * @member {Array.<dataform.IOperation>} operations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.operations = $util.emptyArray;

        /**
         * CompiledGraph assertions.
         * @member {Array.<dataform.IAssertion>} assertions
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.assertions = $util.emptyArray;

        /**
         * CompiledGraph declarations.
         * @member {Array.<dataform.IDeclaration>} declarations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.declarations = $util.emptyArray;

        /**
         * CompiledGraph tests.
         * @member {Array.<dataform.ITest>} tests
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.tests = $util.emptyArray;

        /**
         * CompiledGraph graphErrors.
         * @member {dataform.IGraphErrors|null|undefined} graphErrors
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.graphErrors = null;

        /**
         * CompiledGraph dataformCoreVersion.
         * @member {string} dataformCoreVersion
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.dataformCoreVersion = "";

        /**
         * CompiledGraph targets.
         * @member {Array.<dataform.ITarget>} targets
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.targets = $util.emptyArray;

        /**
         * Creates a new CompiledGraph instance using the specified properties.
         * @function create
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph=} [properties] Properties to set
         * @returns {dataform.CompiledGraph} CompiledGraph instance
         */
        CompiledGraph.create = function create(properties) {
            return new CompiledGraph(properties);
        };

        /**
         * Encodes the specified CompiledGraph message. Does not implicitly {@link dataform.CompiledGraph.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph} message CompiledGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompiledGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (let i = 0; i < message.tables.length; ++i)
                    $root.dataform.Table.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.operations != null && message.operations.length)
                for (let i = 0; i < message.operations.length; ++i)
                    $root.dataform.Operation.encode(message.operations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.assertions != null && message.assertions.length)
                for (let i = 0; i < message.assertions.length; ++i)
                    $root.dataform.Assertion.encode(message.assertions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                $root.dataform.ProjectConfig.encode(message.projectConfig, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors"))
                $root.dataform.GraphErrors.encode(message.graphErrors, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.tests != null && message.tests.length)
                for (let i = 0; i < message.tests.length; ++i)
                    $root.dataform.Test.encode(message.tests[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.declarations != null && message.declarations.length)
                for (let i = 0; i < message.declarations.length; ++i)
                    $root.dataform.Declaration.encode(message.declarations[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.dataformCoreVersion);
            if (message.targets != null && message.targets.length)
                for (let i = 0; i < message.targets.length; ++i)
                    $root.dataform.Target.encode(message.targets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompiledGraph message, length delimited. Does not implicitly {@link dataform.CompiledGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph} message CompiledGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompiledGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompiledGraph message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompiledGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompiledGraph} CompiledGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompiledGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompiledGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.projectConfig = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                    break;
                case 1:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push($root.dataform.Table.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.operations && message.operations.length))
                        message.operations = [];
                    message.operations.push($root.dataform.Operation.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.assertions && message.assertions.length))
                        message.assertions = [];
                    message.assertions.push($root.dataform.Assertion.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.declarations && message.declarations.length))
                        message.declarations = [];
                    message.declarations.push($root.dataform.Declaration.decode(reader, reader.uint32()));
                    break;
                case 8:
                    if (!(message.tests && message.tests.length))
                        message.tests = [];
                    message.tests.push($root.dataform.Test.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.graphErrors = $root.dataform.GraphErrors.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.dataformCoreVersion = reader.string();
                    break;
                case 11:
                    if (!(message.targets && message.targets.length))
                        message.targets = [];
                    message.targets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompiledGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompiledGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompiledGraph} CompiledGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompiledGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompiledGraph message.
         * @function verify
         * @memberof dataform.CompiledGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompiledGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfig);
                if (error)
                    return "projectConfig." + error;
            }
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (let i = 0; i < message.tables.length; ++i) {
                    let error = $root.dataform.Table.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            if (message.operations != null && message.hasOwnProperty("operations")) {
                if (!Array.isArray(message.operations))
                    return "operations: array expected";
                for (let i = 0; i < message.operations.length; ++i) {
                    let error = $root.dataform.Operation.verify(message.operations[i]);
                    if (error)
                        return "operations." + error;
                }
            }
            if (message.assertions != null && message.hasOwnProperty("assertions")) {
                if (!Array.isArray(message.assertions))
                    return "assertions: array expected";
                for (let i = 0; i < message.assertions.length; ++i) {
                    let error = $root.dataform.Assertion.verify(message.assertions[i]);
                    if (error)
                        return "assertions." + error;
                }
            }
            if (message.declarations != null && message.hasOwnProperty("declarations")) {
                if (!Array.isArray(message.declarations))
                    return "declarations: array expected";
                for (let i = 0; i < message.declarations.length; ++i) {
                    let error = $root.dataform.Declaration.verify(message.declarations[i]);
                    if (error)
                        return "declarations." + error;
                }
            }
            if (message.tests != null && message.hasOwnProperty("tests")) {
                if (!Array.isArray(message.tests))
                    return "tests: array expected";
                for (let i = 0; i < message.tests.length; ++i) {
                    let error = $root.dataform.Test.verify(message.tests[i]);
                    if (error)
                        return "tests." + error;
                }
            }
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors")) {
                let error = $root.dataform.GraphErrors.verify(message.graphErrors);
                if (error)
                    return "graphErrors." + error;
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                if (!$util.isString(message.dataformCoreVersion))
                    return "dataformCoreVersion: string expected";
            if (message.targets != null && message.hasOwnProperty("targets")) {
                if (!Array.isArray(message.targets))
                    return "targets: array expected";
                for (let i = 0; i < message.targets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.targets[i]);
                    if (error)
                        return "targets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CompiledGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompiledGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompiledGraph} CompiledGraph
         */
        CompiledGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompiledGraph)
                return object;
            let message = new $root.dataform.CompiledGraph();
            if (object.projectConfig != null) {
                if (typeof object.projectConfig !== "object")
                    throw TypeError(".dataform.CompiledGraph.projectConfig: object expected");
                message.projectConfig = $root.dataform.ProjectConfig.fromObject(object.projectConfig);
            }
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".dataform.CompiledGraph.tables: array expected");
                message.tables = [];
                for (let i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.tables: object expected");
                    message.tables[i] = $root.dataform.Table.fromObject(object.tables[i]);
                }
            }
            if (object.operations) {
                if (!Array.isArray(object.operations))
                    throw TypeError(".dataform.CompiledGraph.operations: array expected");
                message.operations = [];
                for (let i = 0; i < object.operations.length; ++i) {
                    if (typeof object.operations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.operations: object expected");
                    message.operations[i] = $root.dataform.Operation.fromObject(object.operations[i]);
                }
            }
            if (object.assertions) {
                if (!Array.isArray(object.assertions))
                    throw TypeError(".dataform.CompiledGraph.assertions: array expected");
                message.assertions = [];
                for (let i = 0; i < object.assertions.length; ++i) {
                    if (typeof object.assertions[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.assertions: object expected");
                    message.assertions[i] = $root.dataform.Assertion.fromObject(object.assertions[i]);
                }
            }
            if (object.declarations) {
                if (!Array.isArray(object.declarations))
                    throw TypeError(".dataform.CompiledGraph.declarations: array expected");
                message.declarations = [];
                for (let i = 0; i < object.declarations.length; ++i) {
                    if (typeof object.declarations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.declarations: object expected");
                    message.declarations[i] = $root.dataform.Declaration.fromObject(object.declarations[i]);
                }
            }
            if (object.tests) {
                if (!Array.isArray(object.tests))
                    throw TypeError(".dataform.CompiledGraph.tests: array expected");
                message.tests = [];
                for (let i = 0; i < object.tests.length; ++i) {
                    if (typeof object.tests[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.tests: object expected");
                    message.tests[i] = $root.dataform.Test.fromObject(object.tests[i]);
                }
            }
            if (object.graphErrors != null) {
                if (typeof object.graphErrors !== "object")
                    throw TypeError(".dataform.CompiledGraph.graphErrors: object expected");
                message.graphErrors = $root.dataform.GraphErrors.fromObject(object.graphErrors);
            }
            if (object.dataformCoreVersion != null)
                message.dataformCoreVersion = String(object.dataformCoreVersion);
            if (object.targets) {
                if (!Array.isArray(object.targets))
                    throw TypeError(".dataform.CompiledGraph.targets: array expected");
                message.targets = [];
                for (let i = 0; i < object.targets.length; ++i) {
                    if (typeof object.targets[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.targets: object expected");
                    message.targets[i] = $root.dataform.Target.fromObject(object.targets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CompiledGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.CompiledGraph} message CompiledGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompiledGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tables = [];
                object.operations = [];
                object.assertions = [];
                object.tests = [];
                object.declarations = [];
                object.targets = [];
            }
            if (options.defaults) {
                object.projectConfig = null;
                object.graphErrors = null;
                object.dataformCoreVersion = "";
            }
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (let j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.dataform.Table.toObject(message.tables[j], options);
            }
            if (message.operations && message.operations.length) {
                object.operations = [];
                for (let j = 0; j < message.operations.length; ++j)
                    object.operations[j] = $root.dataform.Operation.toObject(message.operations[j], options);
            }
            if (message.assertions && message.assertions.length) {
                object.assertions = [];
                for (let j = 0; j < message.assertions.length; ++j)
                    object.assertions[j] = $root.dataform.Assertion.toObject(message.assertions[j], options);
            }
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                object.projectConfig = $root.dataform.ProjectConfig.toObject(message.projectConfig, options);
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors"))
                object.graphErrors = $root.dataform.GraphErrors.toObject(message.graphErrors, options);
            if (message.tests && message.tests.length) {
                object.tests = [];
                for (let j = 0; j < message.tests.length; ++j)
                    object.tests[j] = $root.dataform.Test.toObject(message.tests[j], options);
            }
            if (message.declarations && message.declarations.length) {
                object.declarations = [];
                for (let j = 0; j < message.declarations.length; ++j)
                    object.declarations[j] = $root.dataform.Declaration.toObject(message.declarations[j], options);
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                object.dataformCoreVersion = message.dataformCoreVersion;
            if (message.targets && message.targets.length) {
                object.targets = [];
                for (let j = 0; j < message.targets.length; ++j)
                    object.targets[j] = $root.dataform.Target.toObject(message.targets[j], options);
            }
            return object;
        };

        /**
         * Converts this CompiledGraph to JSON.
         * @function toJSON
         * @memberof dataform.CompiledGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompiledGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CompiledGraph;
    })();

    dataform.ExecutionTask = (function() {

        /**
         * Properties of an ExecutionTask.
         * @memberof dataform
         * @interface IExecutionTask
         * @property {string|null} [type] ExecutionTask type
         * @property {string|null} [statement] ExecutionTask statement
         */

        /**
         * Constructs a new ExecutionTask.
         * @memberof dataform
         * @classdesc Represents an ExecutionTask.
         * @implements IExecutionTask
         * @constructor
         * @param {dataform.IExecutionTask=} [properties] Properties to set
         */
        function ExecutionTask(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionTask type.
         * @member {string} type
         * @memberof dataform.ExecutionTask
         * @instance
         */
        ExecutionTask.prototype.type = "";

        /**
         * ExecutionTask statement.
         * @member {string} statement
         * @memberof dataform.ExecutionTask
         * @instance
         */
        ExecutionTask.prototype.statement = "";

        /**
         * Creates a new ExecutionTask instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask=} [properties] Properties to set
         * @returns {dataform.ExecutionTask} ExecutionTask instance
         */
        ExecutionTask.create = function create(properties) {
            return new ExecutionTask(properties);
        };

        /**
         * Encodes the specified ExecutionTask message. Does not implicitly {@link dataform.ExecutionTask.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask} message ExecutionTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionTask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.statement != null && message.hasOwnProperty("statement"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.statement);
            return writer;
        };

        /**
         * Encodes the specified ExecutionTask message, length delimited. Does not implicitly {@link dataform.ExecutionTask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask} message ExecutionTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionTask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionTask message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionTask} ExecutionTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionTask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionTask();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.statement = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionTask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionTask} ExecutionTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionTask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionTask message.
         * @function verify
         * @memberof dataform.ExecutionTask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionTask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.statement != null && message.hasOwnProperty("statement"))
                if (!$util.isString(message.statement))
                    return "statement: string expected";
            return null;
        };

        /**
         * Creates an ExecutionTask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionTask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionTask} ExecutionTask
         */
        ExecutionTask.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionTask)
                return object;
            let message = new $root.dataform.ExecutionTask();
            if (object.type != null)
                message.type = String(object.type);
            if (object.statement != null)
                message.statement = String(object.statement);
            return message;
        };

        /**
         * Creates a plain object from an ExecutionTask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.ExecutionTask} message ExecutionTask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionTask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = "";
                object.statement = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.statement != null && message.hasOwnProperty("statement"))
                object.statement = message.statement;
            return object;
        };

        /**
         * Converts this ExecutionTask to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionTask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionTask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutionTask;
    })();

    dataform.ExecutionAction = (function() {

        /**
         * Properties of an ExecutionAction.
         * @memberof dataform
         * @interface IExecutionAction
         * @property {string|null} [name] ExecutionAction name
         * @property {dataform.ITarget|null} [target] ExecutionAction target
         * @property {string|null} [fileName] ExecutionAction fileName
         * @property {string|null} [type] ExecutionAction type
         * @property {string|null} [tableType] ExecutionAction tableType
         * @property {Array.<string>|null} [dependencies] ExecutionAction dependencies
         * @property {Array.<dataform.ITarget>|null} [transitiveInputs] ExecutionAction transitiveInputs
         * @property {dataform.ActionHermeticity|null} [hermeticity] ExecutionAction hermeticity
         * @property {Array.<dataform.IExecutionTask>|null} [tasks] ExecutionAction tasks
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] ExecutionAction actionDescriptor
         */

        /**
         * Constructs a new ExecutionAction.
         * @memberof dataform
         * @classdesc Represents an ExecutionAction.
         * @implements IExecutionAction
         * @constructor
         * @param {dataform.IExecutionAction=} [properties] Properties to set
         */
        function ExecutionAction(properties) {
            this.dependencies = [];
            this.transitiveInputs = [];
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionAction name.
         * @member {string} name
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.name = "";

        /**
         * ExecutionAction target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.target = null;

        /**
         * ExecutionAction fileName.
         * @member {string} fileName
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.fileName = "";

        /**
         * ExecutionAction type.
         * @member {string} type
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.type = "";

        /**
         * ExecutionAction tableType.
         * @member {string} tableType
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.tableType = "";

        /**
         * ExecutionAction dependencies.
         * @member {Array.<string>} dependencies
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.dependencies = $util.emptyArray;

        /**
         * ExecutionAction transitiveInputs.
         * @member {Array.<dataform.ITarget>} transitiveInputs
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.transitiveInputs = $util.emptyArray;

        /**
         * ExecutionAction hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.hermeticity = 0;

        /**
         * ExecutionAction tasks.
         * @member {Array.<dataform.IExecutionTask>} tasks
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.tasks = $util.emptyArray;

        /**
         * ExecutionAction actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.actionDescriptor = null;

        /**
         * Creates a new ExecutionAction instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction=} [properties] Properties to set
         * @returns {dataform.ExecutionAction} ExecutionAction instance
         */
        ExecutionAction.create = function create(properties) {
            return new ExecutionAction(properties);
        };

        /**
         * Encodes the specified ExecutionAction message. Does not implicitly {@link dataform.ExecutionAction.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction} message ExecutionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.dataform.ExecutionTask.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.dependencies != null && message.dependencies.length)
                for (let i = 0; i < message.dependencies.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependencies[i]);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.tableType);
            if (message.transitiveInputs != null && message.transitiveInputs.length)
                for (let i = 0; i < message.transitiveInputs.length; ++i)
                    $root.dataform.Target.encode(message.transitiveInputs[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fileName);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.hermeticity);
            return writer;
        };

        /**
         * Encodes the specified ExecutionAction message, length delimited. Does not implicitly {@link dataform.ExecutionAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction} message ExecutionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionAction message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionAction} ExecutionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 5:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.fileName = reader.string();
                    break;
                case 4:
                    message.type = reader.string();
                    break;
                case 6:
                    message.tableType = reader.string();
                    break;
                case 3:
                    if (!(message.dependencies && message.dependencies.length))
                        message.dependencies = [];
                    message.dependencies.push(reader.string());
                    break;
                case 7:
                    if (!(message.transitiveInputs && message.transitiveInputs.length))
                        message.transitiveInputs = [];
                    message.transitiveInputs.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.hermeticity = reader.int32();
                    break;
                case 2:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.dataform.ExecutionTask.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionAction} ExecutionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionAction message.
         * @function verify
         * @memberof dataform.ExecutionAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                if (!$util.isString(message.tableType))
                    return "tableType: string expected";
            if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                if (!Array.isArray(message.dependencies))
                    return "dependencies: array expected";
                for (let i = 0; i < message.dependencies.length; ++i)
                    if (!$util.isString(message.dependencies[i]))
                        return "dependencies: string[] expected";
            }
            if (message.transitiveInputs != null && message.hasOwnProperty("transitiveInputs")) {
                if (!Array.isArray(message.transitiveInputs))
                    return "transitiveInputs: array expected";
                for (let i = 0; i < message.transitiveInputs.length; ++i) {
                    let error = $root.dataform.Target.verify(message.transitiveInputs[i]);
                    if (error)
                        return "transitiveInputs." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.dataform.ExecutionTask.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionAction} ExecutionAction
         */
        ExecutionAction.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionAction)
                return object;
            let message = new $root.dataform.ExecutionAction();
            if (object.name != null)
                message.name = String(object.name);
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.ExecutionAction.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.type != null)
                message.type = String(object.type);
            if (object.tableType != null)
                message.tableType = String(object.tableType);
            if (object.dependencies) {
                if (!Array.isArray(object.dependencies))
                    throw TypeError(".dataform.ExecutionAction.dependencies: array expected");
                message.dependencies = [];
                for (let i = 0; i < object.dependencies.length; ++i)
                    message.dependencies[i] = String(object.dependencies[i]);
            }
            if (object.transitiveInputs) {
                if (!Array.isArray(object.transitiveInputs))
                    throw TypeError(".dataform.ExecutionAction.transitiveInputs: array expected");
                message.transitiveInputs = [];
                for (let i = 0; i < object.transitiveInputs.length; ++i) {
                    if (typeof object.transitiveInputs[i] !== "object")
                        throw TypeError(".dataform.ExecutionAction.transitiveInputs: object expected");
                    message.transitiveInputs[i] = $root.dataform.Target.fromObject(object.transitiveInputs[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".dataform.ExecutionAction.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".dataform.ExecutionAction.tasks: object expected");
                    message.tasks[i] = $root.dataform.ExecutionTask.fromObject(object.tasks[i]);
                }
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.ExecutionAction.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.ExecutionAction} message ExecutionAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tasks = [];
                object.dependencies = [];
                object.transitiveInputs = [];
            }
            if (options.defaults) {
                object.name = "";
                object.type = "";
                object.target = null;
                object.tableType = "";
                object.fileName = "";
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.dataform.ExecutionTask.toObject(message.tasks[j], options);
            }
            if (message.dependencies && message.dependencies.length) {
                object.dependencies = [];
                for (let j = 0; j < message.dependencies.length; ++j)
                    object.dependencies[j] = message.dependencies[j];
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                object.tableType = message.tableType;
            if (message.transitiveInputs && message.transitiveInputs.length) {
                object.transitiveInputs = [];
                for (let j = 0; j < message.transitiveInputs.length; ++j)
                    object.transitiveInputs[j] = $root.dataform.Target.toObject(message.transitiveInputs[j], options);
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            return object;
        };

        /**
         * Converts this ExecutionAction to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutionAction;
    })();

    dataform.WarehouseState = (function() {

        /**
         * Properties of a WarehouseState.
         * @memberof dataform
         * @interface IWarehouseState
         * @property {Array.<dataform.ITableMetadata>|null} [tables] WarehouseState tables
         */

        /**
         * Constructs a new WarehouseState.
         * @memberof dataform
         * @classdesc Represents a WarehouseState.
         * @implements IWarehouseState
         * @constructor
         * @param {dataform.IWarehouseState=} [properties] Properties to set
         */
        function WarehouseState(properties) {
            this.tables = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarehouseState tables.
         * @member {Array.<dataform.ITableMetadata>} tables
         * @memberof dataform.WarehouseState
         * @instance
         */
        WarehouseState.prototype.tables = $util.emptyArray;

        /**
         * Creates a new WarehouseState instance using the specified properties.
         * @function create
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState=} [properties] Properties to set
         * @returns {dataform.WarehouseState} WarehouseState instance
         */
        WarehouseState.create = function create(properties) {
            return new WarehouseState(properties);
        };

        /**
         * Encodes the specified WarehouseState message. Does not implicitly {@link dataform.WarehouseState.verify|verify} messages.
         * @function encode
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState} message WarehouseState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarehouseState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (let i = 0; i < message.tables.length; ++i)
                    $root.dataform.TableMetadata.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WarehouseState message, length delimited. Does not implicitly {@link dataform.WarehouseState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState} message WarehouseState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarehouseState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarehouseState message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.WarehouseState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.WarehouseState} WarehouseState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarehouseState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.WarehouseState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tables && message.tables.length))
                        message.tables = [];
                    message.tables.push($root.dataform.TableMetadata.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarehouseState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.WarehouseState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.WarehouseState} WarehouseState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarehouseState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarehouseState message.
         * @function verify
         * @memberof dataform.WarehouseState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarehouseState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (let i = 0; i < message.tables.length; ++i) {
                    let error = $root.dataform.TableMetadata.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WarehouseState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.WarehouseState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.WarehouseState} WarehouseState
         */
        WarehouseState.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.WarehouseState)
                return object;
            let message = new $root.dataform.WarehouseState();
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".dataform.WarehouseState.tables: array expected");
                message.tables = [];
                for (let i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".dataform.WarehouseState.tables: object expected");
                    message.tables[i] = $root.dataform.TableMetadata.fromObject(object.tables[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WarehouseState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.WarehouseState} message WarehouseState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarehouseState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tables = [];
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (let j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.dataform.TableMetadata.toObject(message.tables[j], options);
            }
            return object;
        };

        /**
         * Converts this WarehouseState to JSON.
         * @function toJSON
         * @memberof dataform.WarehouseState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarehouseState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WarehouseState;
    })();

    dataform.ExecutionGraph = (function() {

        /**
         * Properties of an ExecutionGraph.
         * @memberof dataform
         * @interface IExecutionGraph
         * @property {dataform.IProjectConfig|null} [projectConfig] ExecutionGraph projectConfig
         * @property {dataform.IRunConfig|null} [runConfig] ExecutionGraph runConfig
         * @property {dataform.IWarehouseState|null} [warehouseState] ExecutionGraph warehouseState
         * @property {Array.<dataform.ITarget>|null} [declarationTargets] ExecutionGraph declarationTargets
         * @property {Array.<dataform.IExecutionAction>|null} [actions] ExecutionGraph actions
         */

        /**
         * Constructs a new ExecutionGraph.
         * @memberof dataform
         * @classdesc Represents an ExecutionGraph.
         * @implements IExecutionGraph
         * @constructor
         * @param {dataform.IExecutionGraph=} [properties] Properties to set
         */
        function ExecutionGraph(properties) {
            this.declarationTargets = [];
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionGraph projectConfig.
         * @member {dataform.IProjectConfig|null|undefined} projectConfig
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.projectConfig = null;

        /**
         * ExecutionGraph runConfig.
         * @member {dataform.IRunConfig|null|undefined} runConfig
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.runConfig = null;

        /**
         * ExecutionGraph warehouseState.
         * @member {dataform.IWarehouseState|null|undefined} warehouseState
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.warehouseState = null;

        /**
         * ExecutionGraph declarationTargets.
         * @member {Array.<dataform.ITarget>} declarationTargets
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.declarationTargets = $util.emptyArray;

        /**
         * ExecutionGraph actions.
         * @member {Array.<dataform.IExecutionAction>} actions
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.actions = $util.emptyArray;

        /**
         * Creates a new ExecutionGraph instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph=} [properties] Properties to set
         * @returns {dataform.ExecutionGraph} ExecutionGraph instance
         */
        ExecutionGraph.create = function create(properties) {
            return new ExecutionGraph(properties);
        };

        /**
         * Encodes the specified ExecutionGraph message. Does not implicitly {@link dataform.ExecutionGraph.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph} message ExecutionGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                $root.dataform.ProjectConfig.encode(message.projectConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.runConfig != null && message.hasOwnProperty("runConfig"))
                $root.dataform.RunConfig.encode(message.runConfig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ExecutionAction.encode(message.actions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState"))
                $root.dataform.WarehouseState.encode(message.warehouseState, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.declarationTargets != null && message.declarationTargets.length)
                for (let i = 0; i < message.declarationTargets.length; ++i)
                    $root.dataform.Target.encode(message.declarationTargets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionGraph message, length delimited. Does not implicitly {@link dataform.ExecutionGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph} message ExecutionGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionGraph message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.projectConfig = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.runConfig = $root.dataform.RunConfig.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.warehouseState = $root.dataform.WarehouseState.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.declarationTargets && message.declarationTargets.length))
                        message.declarationTargets = [];
                    message.declarationTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.actions && message.actions.length))
                        message.actions = [];
                    message.actions.push($root.dataform.ExecutionAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionGraph message.
         * @function verify
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfig);
                if (error)
                    return "projectConfig." + error;
            }
            if (message.runConfig != null && message.hasOwnProperty("runConfig")) {
                let error = $root.dataform.RunConfig.verify(message.runConfig);
                if (error)
                    return "runConfig." + error;
            }
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState")) {
                let error = $root.dataform.WarehouseState.verify(message.warehouseState);
                if (error)
                    return "warehouseState." + error;
            }
            if (message.declarationTargets != null && message.hasOwnProperty("declarationTargets")) {
                if (!Array.isArray(message.declarationTargets))
                    return "declarationTargets: array expected";
                for (let i = 0; i < message.declarationTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.declarationTargets[i]);
                    if (error)
                        return "declarationTargets." + error;
                }
            }
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ExecutionAction.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExecutionGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         */
        ExecutionGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionGraph)
                return object;
            let message = new $root.dataform.ExecutionGraph();
            if (object.projectConfig != null) {
                if (typeof object.projectConfig !== "object")
                    throw TypeError(".dataform.ExecutionGraph.projectConfig: object expected");
                message.projectConfig = $root.dataform.ProjectConfig.fromObject(object.projectConfig);
            }
            if (object.runConfig != null) {
                if (typeof object.runConfig !== "object")
                    throw TypeError(".dataform.ExecutionGraph.runConfig: object expected");
                message.runConfig = $root.dataform.RunConfig.fromObject(object.runConfig);
            }
            if (object.warehouseState != null) {
                if (typeof object.warehouseState !== "object")
                    throw TypeError(".dataform.ExecutionGraph.warehouseState: object expected");
                message.warehouseState = $root.dataform.WarehouseState.fromObject(object.warehouseState);
            }
            if (object.declarationTargets) {
                if (!Array.isArray(object.declarationTargets))
                    throw TypeError(".dataform.ExecutionGraph.declarationTargets: array expected");
                message.declarationTargets = [];
                for (let i = 0; i < object.declarationTargets.length; ++i) {
                    if (typeof object.declarationTargets[i] !== "object")
                        throw TypeError(".dataform.ExecutionGraph.declarationTargets: object expected");
                    message.declarationTargets[i] = $root.dataform.Target.fromObject(object.declarationTargets[i]);
                }
            }
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.ExecutionGraph.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.ExecutionGraph.actions: object expected");
                    message.actions[i] = $root.dataform.ExecutionAction.fromObject(object.actions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.ExecutionGraph} message ExecutionGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.declarationTargets = [];
            }
            if (options.defaults) {
                object.projectConfig = null;
                object.runConfig = null;
                object.warehouseState = null;
            }
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                object.projectConfig = $root.dataform.ProjectConfig.toObject(message.projectConfig, options);
            if (message.runConfig != null && message.hasOwnProperty("runConfig"))
                object.runConfig = $root.dataform.RunConfig.toObject(message.runConfig, options);
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ExecutionAction.toObject(message.actions[j], options);
            }
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState"))
                object.warehouseState = $root.dataform.WarehouseState.toObject(message.warehouseState, options);
            if (message.declarationTargets && message.declarationTargets.length) {
                object.declarationTargets = [];
                for (let j = 0; j < message.declarationTargets.length; ++j)
                    object.declarationTargets[j] = $root.dataform.Target.toObject(message.declarationTargets[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecutionGraph to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExecutionGraph;
    })();

    dataform.Timing = (function() {

        /**
         * Properties of a Timing.
         * @memberof dataform
         * @interface ITiming
         * @property {Long|null} [startTimeMillis] Timing startTimeMillis
         * @property {Long|null} [endTimeMillis] Timing endTimeMillis
         */

        /**
         * Constructs a new Timing.
         * @memberof dataform
         * @classdesc Represents a Timing.
         * @implements ITiming
         * @constructor
         * @param {dataform.ITiming=} [properties] Properties to set
         */
        function Timing(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timing startTimeMillis.
         * @member {Long} startTimeMillis
         * @memberof dataform.Timing
         * @instance
         */
        Timing.prototype.startTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Timing endTimeMillis.
         * @member {Long} endTimeMillis
         * @memberof dataform.Timing
         * @instance
         */
        Timing.prototype.endTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Timing instance using the specified properties.
         * @function create
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming=} [properties] Properties to set
         * @returns {dataform.Timing} Timing instance
         */
        Timing.create = function create(properties) {
            return new Timing(properties);
        };

        /**
         * Encodes the specified Timing message. Does not implicitly {@link dataform.Timing.verify|verify} messages.
         * @function encode
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTimeMillis);
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endTimeMillis);
            return writer;
        };

        /**
         * Encodes the specified Timing message, length delimited. Does not implicitly {@link dataform.Timing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timing message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Timing();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startTimeMillis = reader.int64();
                    break;
                case 2:
                    message.endTimeMillis = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timing message.
         * @function verify
         * @memberof dataform.Timing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                if (!$util.isInteger(message.startTimeMillis) && !(message.startTimeMillis && $util.isInteger(message.startTimeMillis.low) && $util.isInteger(message.startTimeMillis.high)))
                    return "startTimeMillis: integer|Long expected";
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                if (!$util.isInteger(message.endTimeMillis) && !(message.endTimeMillis && $util.isInteger(message.endTimeMillis.low) && $util.isInteger(message.endTimeMillis.high)))
                    return "endTimeMillis: integer|Long expected";
            return null;
        };

        /**
         * Creates a Timing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Timing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Timing} Timing
         */
        Timing.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Timing)
                return object;
            let message = new $root.dataform.Timing();
            if (object.startTimeMillis != null)
                if ($util.Long)
                    (message.startTimeMillis = $util.Long.fromValue(object.startTimeMillis)).unsigned = false;
                else if (typeof object.startTimeMillis === "string")
                    message.startTimeMillis = parseInt(object.startTimeMillis, 10);
                else if (typeof object.startTimeMillis === "number")
                    message.startTimeMillis = object.startTimeMillis;
                else if (typeof object.startTimeMillis === "object")
                    message.startTimeMillis = new $util.LongBits(object.startTimeMillis.low >>> 0, object.startTimeMillis.high >>> 0).toNumber();
            if (object.endTimeMillis != null)
                if ($util.Long)
                    (message.endTimeMillis = $util.Long.fromValue(object.endTimeMillis)).unsigned = false;
                else if (typeof object.endTimeMillis === "string")
                    message.endTimeMillis = parseInt(object.endTimeMillis, 10);
                else if (typeof object.endTimeMillis === "number")
                    message.endTimeMillis = object.endTimeMillis;
                else if (typeof object.endTimeMillis === "object")
                    message.endTimeMillis = new $util.LongBits(object.endTimeMillis.low >>> 0, object.endTimeMillis.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Timing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Timing
         * @static
         * @param {dataform.Timing} message Timing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.startTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTimeMillis = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.endTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTimeMillis = options.longs === String ? "0" : 0;
            }
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                if (typeof message.startTimeMillis === "number")
                    object.startTimeMillis = options.longs === String ? String(message.startTimeMillis) : message.startTimeMillis;
                else
                    object.startTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeMillis) : options.longs === Number ? new $util.LongBits(message.startTimeMillis.low >>> 0, message.startTimeMillis.high >>> 0).toNumber() : message.startTimeMillis;
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                if (typeof message.endTimeMillis === "number")
                    object.endTimeMillis = options.longs === String ? String(message.endTimeMillis) : message.endTimeMillis;
                else
                    object.endTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeMillis) : options.longs === Number ? new $util.LongBits(message.endTimeMillis.low >>> 0, message.endTimeMillis.high >>> 0).toNumber() : message.endTimeMillis;
            return object;
        };

        /**
         * Converts this Timing to JSON.
         * @function toJSON
         * @memberof dataform.Timing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Timing;
    })();

    dataform.RunResult = (function() {

        /**
         * Properties of a RunResult.
         * @memberof dataform
         * @interface IRunResult
         * @property {dataform.RunResult.ExecutionStatus|null} [status] RunResult status
         * @property {Array.<dataform.IActionResult>|null} [actions] RunResult actions
         * @property {dataform.ITiming|null} [timing] RunResult timing
         */

        /**
         * Constructs a new RunResult.
         * @memberof dataform
         * @classdesc Represents a RunResult.
         * @implements IRunResult
         * @constructor
         * @param {dataform.IRunResult=} [properties] Properties to set
         */
        function RunResult(properties) {
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RunResult status.
         * @member {dataform.RunResult.ExecutionStatus} status
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.status = 0;

        /**
         * RunResult actions.
         * @member {Array.<dataform.IActionResult>} actions
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.actions = $util.emptyArray;

        /**
         * RunResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.timing = null;

        /**
         * Creates a new RunResult instance using the specified properties.
         * @function create
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult=} [properties] Properties to set
         * @returns {dataform.RunResult} RunResult instance
         */
        RunResult.create = function create(properties) {
            return new RunResult(properties);
        };

        /**
         * Encodes the specified RunResult message. Does not implicitly {@link dataform.RunResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult} message RunResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ActionResult.encode(message.actions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timing != null && message.hasOwnProperty("timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RunResult message, length delimited. Does not implicitly {@link dataform.RunResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult} message RunResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RunResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RunResult} RunResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RunResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    if (!(message.actions && message.actions.length))
                        message.actions = [];
                    message.actions.push($root.dataform.ActionResult.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RunResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RunResult} RunResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunResult message.
         * @function verify
         * @memberof dataform.RunResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ActionResult.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            return null;
        };

        /**
         * Creates a RunResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RunResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RunResult} RunResult
         */
        RunResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RunResult)
                return object;
            let message = new $root.dataform.RunResult();
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "CANCELLED":
            case 4:
                message.status = 4;
                break;
            case "TIMED_OUT":
            case 5:
                message.status = 5;
                break;
            }
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.RunResult.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.RunResult.actions: object expected");
                    message.actions[i] = $root.dataform.ActionResult.fromObject(object.actions[i]);
                }
            }
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.RunResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            return message;
        };

        /**
         * Creates a plain object from a RunResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.RunResult} message RunResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.timing = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.RunResult.ExecutionStatus[message.status] : message.status;
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ActionResult.toObject(message.actions[j], options);
            }
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            return object;
        };

        /**
         * Converts this RunResult to JSON.
         * @function toJSON
         * @memberof dataform.RunResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.RunResult.ExecutionStatus
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} CANCELLED=4 CANCELLED value
         * @property {number} TIMED_OUT=5 TIMED_OUT value
         */
        RunResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "CANCELLED"] = 4;
            values[valuesById[5] = "TIMED_OUT"] = 5;
            return values;
        })();

        return RunResult;
    })();

    dataform.ActionResult = (function() {

        /**
         * Properties of an ActionResult.
         * @memberof dataform
         * @interface IActionResult
         * @property {string|null} [name] ActionResult name
         * @property {dataform.ITarget|null} [target] ActionResult target
         * @property {Array.<dataform.ActionResult.IInput>|null} [inputs] ActionResult inputs
         * @property {dataform.ActionResult.ExecutionStatus|null} [status] ActionResult status
         * @property {Array.<dataform.ITaskResult>|null} [tasks] ActionResult tasks
         * @property {dataform.ITiming|null} [timing] ActionResult timing
         * @property {Long|null} [postExecutionTimestampMillis] ActionResult postExecutionTimestampMillis
         */

        /**
         * Constructs a new ActionResult.
         * @memberof dataform
         * @classdesc Represents an ActionResult.
         * @implements IActionResult
         * @constructor
         * @param {dataform.IActionResult=} [properties] Properties to set
         */
        function ActionResult(properties) {
            this.inputs = [];
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionResult name.
         * @member {string} name
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.name = "";

        /**
         * ActionResult target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.target = null;

        /**
         * ActionResult inputs.
         * @member {Array.<dataform.ActionResult.IInput>} inputs
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.inputs = $util.emptyArray;

        /**
         * ActionResult status.
         * @member {dataform.ActionResult.ExecutionStatus} status
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.status = 0;

        /**
         * ActionResult tasks.
         * @member {Array.<dataform.ITaskResult>} tasks
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.tasks = $util.emptyArray;

        /**
         * ActionResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.timing = null;

        /**
         * ActionResult postExecutionTimestampMillis.
         * @member {Long} postExecutionTimestampMillis
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.postExecutionTimestampMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ActionResult instance using the specified properties.
         * @function create
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult=} [properties] Properties to set
         * @returns {dataform.ActionResult} ActionResult instance
         */
        ActionResult.create = function create(properties) {
            return new ActionResult(properties);
        };

        /**
         * Encodes the specified ActionResult message. Does not implicitly {@link dataform.ActionResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult} message ActionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.dataform.TaskResult.encode(message.tasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timing != null && message.hasOwnProperty("timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.inputs != null && message.inputs.length)
                for (let i = 0; i < message.inputs.length; ++i)
                    $root.dataform.ActionResult.Input.encode(message.inputs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.postExecutionTimestampMillis != null && message.hasOwnProperty("postExecutionTimestampMillis"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.postExecutionTimestampMillis);
            return writer;
        };

        /**
         * Encodes the specified ActionResult message, length delimited. Does not implicitly {@link dataform.ActionResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult} message ActionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionResult} ActionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 5:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.inputs && message.inputs.length))
                        message.inputs = [];
                    message.inputs.push($root.dataform.ActionResult.Input.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.dataform.TaskResult.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.postExecutionTimestampMillis = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionResult} ActionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionResult message.
         * @function verify
         * @memberof dataform.ActionResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.inputs != null && message.hasOwnProperty("inputs")) {
                if (!Array.isArray(message.inputs))
                    return "inputs: array expected";
                for (let i = 0; i < message.inputs.length; ++i) {
                    let error = $root.dataform.ActionResult.Input.verify(message.inputs[i]);
                    if (error)
                        return "inputs." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.dataform.TaskResult.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            if (message.postExecutionTimestampMillis != null && message.hasOwnProperty("postExecutionTimestampMillis"))
                if (!$util.isInteger(message.postExecutionTimestampMillis) && !(message.postExecutionTimestampMillis && $util.isInteger(message.postExecutionTimestampMillis.low) && $util.isInteger(message.postExecutionTimestampMillis.high)))
                    return "postExecutionTimestampMillis: integer|Long expected";
            return null;
        };

        /**
         * Creates an ActionResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionResult} ActionResult
         */
        ActionResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionResult)
                return object;
            let message = new $root.dataform.ActionResult();
            if (object.name != null)
                message.name = String(object.name);
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.ActionResult.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.inputs) {
                if (!Array.isArray(object.inputs))
                    throw TypeError(".dataform.ActionResult.inputs: array expected");
                message.inputs = [];
                for (let i = 0; i < object.inputs.length; ++i) {
                    if (typeof object.inputs[i] !== "object")
                        throw TypeError(".dataform.ActionResult.inputs: object expected");
                    message.inputs[i] = $root.dataform.ActionResult.Input.fromObject(object.inputs[i]);
                }
            }
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "SKIPPED":
            case 4:
                message.status = 4;
                break;
            case "DISABLED":
            case 5:
                message.status = 5;
                break;
            case "CANCELLED":
            case 6:
                message.status = 6;
                break;
            case "CACHE_SKIPPED":
            case 7:
                message.status = 7;
                break;
            }
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".dataform.ActionResult.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".dataform.ActionResult.tasks: object expected");
                    message.tasks[i] = $root.dataform.TaskResult.fromObject(object.tasks[i]);
                }
            }
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.ActionResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            if (object.postExecutionTimestampMillis != null)
                if ($util.Long)
                    (message.postExecutionTimestampMillis = $util.Long.fromValue(object.postExecutionTimestampMillis)).unsigned = false;
                else if (typeof object.postExecutionTimestampMillis === "string")
                    message.postExecutionTimestampMillis = parseInt(object.postExecutionTimestampMillis, 10);
                else if (typeof object.postExecutionTimestampMillis === "number")
                    message.postExecutionTimestampMillis = object.postExecutionTimestampMillis;
                else if (typeof object.postExecutionTimestampMillis === "object")
                    message.postExecutionTimestampMillis = new $util.LongBits(object.postExecutionTimestampMillis.low >>> 0, object.postExecutionTimestampMillis.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ActionResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.ActionResult} message ActionResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tasks = [];
                object.inputs = [];
            }
            if (options.defaults) {
                object.name = "";
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.timing = null;
                object.target = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.postExecutionTimestampMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.postExecutionTimestampMillis = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.ActionResult.ExecutionStatus[message.status] : message.status;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.dataform.TaskResult.toObject(message.tasks[j], options);
            }
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.inputs && message.inputs.length) {
                object.inputs = [];
                for (let j = 0; j < message.inputs.length; ++j)
                    object.inputs[j] = $root.dataform.ActionResult.Input.toObject(message.inputs[j], options);
            }
            if (message.postExecutionTimestampMillis != null && message.hasOwnProperty("postExecutionTimestampMillis"))
                if (typeof message.postExecutionTimestampMillis === "number")
                    object.postExecutionTimestampMillis = options.longs === String ? String(message.postExecutionTimestampMillis) : message.postExecutionTimestampMillis;
                else
                    object.postExecutionTimestampMillis = options.longs === String ? $util.Long.prototype.toString.call(message.postExecutionTimestampMillis) : options.longs === Number ? new $util.LongBits(message.postExecutionTimestampMillis.low >>> 0, message.postExecutionTimestampMillis.high >>> 0).toNumber() : message.postExecutionTimestampMillis;
            return object;
        };

        /**
         * Converts this ActionResult to JSON.
         * @function toJSON
         * @memberof dataform.ActionResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ActionResult.Input = (function() {

            /**
             * Properties of an Input.
             * @memberof dataform.ActionResult
             * @interface IInput
             * @property {dataform.ITarget|null} [target] Input target
             * @property {dataform.ActionResult.Input.IMetadata|null} [metadata] Input metadata
             */

            /**
             * Constructs a new Input.
             * @memberof dataform.ActionResult
             * @classdesc Represents an Input.
             * @implements IInput
             * @constructor
             * @param {dataform.ActionResult.IInput=} [properties] Properties to set
             */
            function Input(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Input target.
             * @member {dataform.ITarget|null|undefined} target
             * @memberof dataform.ActionResult.Input
             * @instance
             */
            Input.prototype.target = null;

            /**
             * Input metadata.
             * @member {dataform.ActionResult.Input.IMetadata|null|undefined} metadata
             * @memberof dataform.ActionResult.Input
             * @instance
             */
            Input.prototype.metadata = null;

            /**
             * Creates a new Input instance using the specified properties.
             * @function create
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {dataform.ActionResult.IInput=} [properties] Properties to set
             * @returns {dataform.ActionResult.Input} Input instance
             */
            Input.create = function create(properties) {
                return new Input(properties);
            };

            /**
             * Encodes the specified Input message. Does not implicitly {@link dataform.ActionResult.Input.verify|verify} messages.
             * @function encode
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {dataform.ActionResult.IInput} message Input message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Input.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && message.hasOwnProperty("target"))
                    $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    $root.dataform.ActionResult.Input.Metadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Input message, length delimited. Does not implicitly {@link dataform.ActionResult.Input.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {dataform.ActionResult.IInput} message Input message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Input.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Input message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ActionResult.Input} Input
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Input.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionResult.Input();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.metadata = $root.dataform.ActionResult.Input.Metadata.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Input message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ActionResult.Input} Input
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Input.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Input message.
             * @function verify
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Input.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target")) {
                    let error = $root.dataform.Target.verify(message.target);
                    if (error)
                        return "target." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    let error = $root.dataform.ActionResult.Input.Metadata.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                return null;
            };

            /**
             * Creates an Input message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ActionResult.Input} Input
             */
            Input.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ActionResult.Input)
                    return object;
                let message = new $root.dataform.ActionResult.Input();
                if (object.target != null) {
                    if (typeof object.target !== "object")
                        throw TypeError(".dataform.ActionResult.Input.target: object expected");
                    message.target = $root.dataform.Target.fromObject(object.target);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".dataform.ActionResult.Input.metadata: object expected");
                    message.metadata = $root.dataform.ActionResult.Input.Metadata.fromObject(object.metadata);
                }
                return message;
            };

            /**
             * Creates a plain object from an Input message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ActionResult.Input
             * @static
             * @param {dataform.ActionResult.Input} message Input
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Input.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.target = null;
                    object.metadata = null;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    object.target = $root.dataform.Target.toObject(message.target, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.dataform.ActionResult.Input.Metadata.toObject(message.metadata, options);
                return object;
            };

            /**
             * Converts this Input to JSON.
             * @function toJSON
             * @memberof dataform.ActionResult.Input
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Input.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Input.Metadata = (function() {

                /**
                 * Properties of a Metadata.
                 * @memberof dataform.ActionResult.Input
                 * @interface IMetadata
                 * @property {Long|null} [lastModifiedTimestampMillis] Metadata lastModifiedTimestampMillis
                 */

                /**
                 * Constructs a new Metadata.
                 * @memberof dataform.ActionResult.Input
                 * @classdesc Represents a Metadata.
                 * @implements IMetadata
                 * @constructor
                 * @param {dataform.ActionResult.Input.IMetadata=} [properties] Properties to set
                 */
                function Metadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Metadata lastModifiedTimestampMillis.
                 * @member {Long} lastModifiedTimestampMillis
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @instance
                 */
                Metadata.prototype.lastModifiedTimestampMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new Metadata instance using the specified properties.
                 * @function create
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {dataform.ActionResult.Input.IMetadata=} [properties] Properties to set
                 * @returns {dataform.ActionResult.Input.Metadata} Metadata instance
                 */
                Metadata.create = function create(properties) {
                    return new Metadata(properties);
                };

                /**
                 * Encodes the specified Metadata message. Does not implicitly {@link dataform.ActionResult.Input.Metadata.verify|verify} messages.
                 * @function encode
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {dataform.ActionResult.Input.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.lastModifiedTimestampMillis != null && message.hasOwnProperty("lastModifiedTimestampMillis"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.lastModifiedTimestampMillis);
                    return writer;
                };

                /**
                 * Encodes the specified Metadata message, length delimited. Does not implicitly {@link dataform.ActionResult.Input.Metadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {dataform.ActionResult.Input.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Metadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {dataform.ActionResult.Input.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionResult.Input.Metadata();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.lastModifiedTimestampMillis = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Metadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {dataform.ActionResult.Input.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Metadata message.
                 * @function verify
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Metadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.lastModifiedTimestampMillis != null && message.hasOwnProperty("lastModifiedTimestampMillis"))
                        if (!$util.isInteger(message.lastModifiedTimestampMillis) && !(message.lastModifiedTimestampMillis && $util.isInteger(message.lastModifiedTimestampMillis.low) && $util.isInteger(message.lastModifiedTimestampMillis.high)))
                            return "lastModifiedTimestampMillis: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {dataform.ActionResult.Input.Metadata} Metadata
                 */
                Metadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.dataform.ActionResult.Input.Metadata)
                        return object;
                    let message = new $root.dataform.ActionResult.Input.Metadata();
                    if (object.lastModifiedTimestampMillis != null)
                        if ($util.Long)
                            (message.lastModifiedTimestampMillis = $util.Long.fromValue(object.lastModifiedTimestampMillis)).unsigned = false;
                        else if (typeof object.lastModifiedTimestampMillis === "string")
                            message.lastModifiedTimestampMillis = parseInt(object.lastModifiedTimestampMillis, 10);
                        else if (typeof object.lastModifiedTimestampMillis === "number")
                            message.lastModifiedTimestampMillis = object.lastModifiedTimestampMillis;
                        else if (typeof object.lastModifiedTimestampMillis === "object")
                            message.lastModifiedTimestampMillis = new $util.LongBits(object.lastModifiedTimestampMillis.low >>> 0, object.lastModifiedTimestampMillis.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a Metadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @static
                 * @param {dataform.ActionResult.Input.Metadata} message Metadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Metadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.lastModifiedTimestampMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lastModifiedTimestampMillis = options.longs === String ? "0" : 0;
                    if (message.lastModifiedTimestampMillis != null && message.hasOwnProperty("lastModifiedTimestampMillis"))
                        if (typeof message.lastModifiedTimestampMillis === "number")
                            object.lastModifiedTimestampMillis = options.longs === String ? String(message.lastModifiedTimestampMillis) : message.lastModifiedTimestampMillis;
                        else
                            object.lastModifiedTimestampMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastModifiedTimestampMillis) : options.longs === Number ? new $util.LongBits(message.lastModifiedTimestampMillis.low >>> 0, message.lastModifiedTimestampMillis.high >>> 0).toNumber() : message.lastModifiedTimestampMillis;
                    return object;
                };

                /**
                 * Converts this Metadata to JSON.
                 * @function toJSON
                 * @memberof dataform.ActionResult.Input.Metadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Metadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Metadata;
            })();

            return Input;
        })();

        /**
         * ExecutionStatus enum.
         * @name dataform.ActionResult.ExecutionStatus
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SKIPPED=4 SKIPPED value
         * @property {number} DISABLED=5 DISABLED value
         * @property {number} CANCELLED=6 CANCELLED value
         * @property {number} CACHE_SKIPPED=7 CACHE_SKIPPED value
         */
        ActionResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SKIPPED"] = 4;
            values[valuesById[5] = "DISABLED"] = 5;
            values[valuesById[6] = "CANCELLED"] = 6;
            values[valuesById[7] = "CACHE_SKIPPED"] = 7;
            return values;
        })();

        return ActionResult;
    })();

    dataform.ExecutionMetadata = (function() {

        /**
         * Properties of an ExecutionMetadata.
         * @memberof dataform
         * @interface IExecutionMetadata
         * @property {dataform.ExecutionMetadata.IBigqueryMetadata|null} [bigquery] ExecutionMetadata bigquery
         */

        /**
         * Constructs a new ExecutionMetadata.
         * @memberof dataform
         * @classdesc Represents an ExecutionMetadata.
         * @implements IExecutionMetadata
         * @constructor
         * @param {dataform.IExecutionMetadata=} [properties] Properties to set
         */
        function ExecutionMetadata(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionMetadata bigquery.
         * @member {dataform.ExecutionMetadata.IBigqueryMetadata|null|undefined} bigquery
         * @memberof dataform.ExecutionMetadata
         * @instance
         */
        ExecutionMetadata.prototype.bigquery = null;

        /**
         * Creates a new ExecutionMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata=} [properties] Properties to set
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata instance
         */
        ExecutionMetadata.create = function create(properties) {
            return new ExecutionMetadata(properties);
        };

        /**
         * Encodes the specified ExecutionMetadata message. Does not implicitly {@link dataform.ExecutionMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                $root.dataform.ExecutionMetadata.BigqueryMetadata.encode(message.bigquery, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionMetadata message, length delimited. Does not implicitly {@link dataform.ExecutionMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionMetadata();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionMetadata message.
         * @function verify
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.ExecutionMetadata.BigqueryMetadata.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         */
        ExecutionMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionMetadata)
                return object;
            let message = new $root.dataform.ExecutionMetadata();
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.ExecutionMetadata.bigquery: object expected");
                message.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.fromObject(object.bigquery);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.ExecutionMetadata} message ExecutionMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.bigquery = null;
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.toObject(message.bigquery, options);
            return object;
        };

        /**
         * Converts this ExecutionMetadata to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ExecutionMetadata.BigqueryMetadata = (function() {

            /**
             * Properties of a BigqueryMetadata.
             * @memberof dataform.ExecutionMetadata
             * @interface IBigqueryMetadata
             * @property {string|null} [jobId] BigqueryMetadata jobId
             * @property {Long|null} [totalBytesProcessed] BigqueryMetadata totalBytesProcessed
             * @property {Long|null} [totalBytesBilled] BigqueryMetadata totalBytesBilled
             */

            /**
             * Constructs a new BigqueryMetadata.
             * @memberof dataform.ExecutionMetadata
             * @classdesc Represents a BigqueryMetadata.
             * @implements IBigqueryMetadata
             * @constructor
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata=} [properties] Properties to set
             */
            function BigqueryMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BigqueryMetadata jobId.
             * @member {string} jobId
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.jobId = "";

            /**
             * BigqueryMetadata totalBytesProcessed.
             * @member {Long} totalBytesProcessed
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.totalBytesProcessed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * BigqueryMetadata totalBytesBilled.
             * @member {Long} totalBytesBilled
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.totalBytesBilled = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BigqueryMetadata instance using the specified properties.
             * @function create
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata=} [properties] Properties to set
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata instance
             */
            BigqueryMetadata.create = function create(properties) {
                return new BigqueryMetadata(properties);
            };

            /**
             * Encodes the specified BigqueryMetadata message. Does not implicitly {@link dataform.ExecutionMetadata.BigqueryMetadata.verify|verify} messages.
             * @function encode
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata} message BigqueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigqueryMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.jobId);
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalBytesProcessed);
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalBytesBilled);
                return writer;
            };

            /**
             * Encodes the specified BigqueryMetadata message, length delimited. Does not implicitly {@link dataform.ExecutionMetadata.BigqueryMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata} message BigqueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigqueryMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BigqueryMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigqueryMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionMetadata.BigqueryMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.jobId = reader.string();
                        break;
                    case 2:
                        message.totalBytesProcessed = reader.int64();
                        break;
                    case 3:
                        message.totalBytesBilled = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BigqueryMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigqueryMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BigqueryMetadata message.
             * @function verify
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BigqueryMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    if (!$util.isString(message.jobId))
                        return "jobId: string expected";
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    if (!$util.isInteger(message.totalBytesProcessed) && !(message.totalBytesProcessed && $util.isInteger(message.totalBytesProcessed.low) && $util.isInteger(message.totalBytesProcessed.high)))
                        return "totalBytesProcessed: integer|Long expected";
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    if (!$util.isInteger(message.totalBytesBilled) && !(message.totalBytesBilled && $util.isInteger(message.totalBytesBilled.low) && $util.isInteger(message.totalBytesBilled.high)))
                        return "totalBytesBilled: integer|Long expected";
                return null;
            };

            /**
             * Creates a BigqueryMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             */
            BigqueryMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ExecutionMetadata.BigqueryMetadata)
                    return object;
                let message = new $root.dataform.ExecutionMetadata.BigqueryMetadata();
                if (object.jobId != null)
                    message.jobId = String(object.jobId);
                if (object.totalBytesProcessed != null)
                    if ($util.Long)
                        (message.totalBytesProcessed = $util.Long.fromValue(object.totalBytesProcessed)).unsigned = false;
                    else if (typeof object.totalBytesProcessed === "string")
                        message.totalBytesProcessed = parseInt(object.totalBytesProcessed, 10);
                    else if (typeof object.totalBytesProcessed === "number")
                        message.totalBytesProcessed = object.totalBytesProcessed;
                    else if (typeof object.totalBytesProcessed === "object")
                        message.totalBytesProcessed = new $util.LongBits(object.totalBytesProcessed.low >>> 0, object.totalBytesProcessed.high >>> 0).toNumber();
                if (object.totalBytesBilled != null)
                    if ($util.Long)
                        (message.totalBytesBilled = $util.Long.fromValue(object.totalBytesBilled)).unsigned = false;
                    else if (typeof object.totalBytesBilled === "string")
                        message.totalBytesBilled = parseInt(object.totalBytesBilled, 10);
                    else if (typeof object.totalBytesBilled === "number")
                        message.totalBytesBilled = object.totalBytesBilled;
                    else if (typeof object.totalBytesBilled === "object")
                        message.totalBytesBilled = new $util.LongBits(object.totalBytesBilled.low >>> 0, object.totalBytesBilled.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BigqueryMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.BigqueryMetadata} message BigqueryMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BigqueryMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.jobId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.totalBytesProcessed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalBytesProcessed = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.totalBytesBilled = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalBytesBilled = options.longs === String ? "0" : 0;
                }
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    object.jobId = message.jobId;
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    if (typeof message.totalBytesProcessed === "number")
                        object.totalBytesProcessed = options.longs === String ? String(message.totalBytesProcessed) : message.totalBytesProcessed;
                    else
                        object.totalBytesProcessed = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytesProcessed) : options.longs === Number ? new $util.LongBits(message.totalBytesProcessed.low >>> 0, message.totalBytesProcessed.high >>> 0).toNumber() : message.totalBytesProcessed;
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    if (typeof message.totalBytesBilled === "number")
                        object.totalBytesBilled = options.longs === String ? String(message.totalBytesBilled) : message.totalBytesBilled;
                    else
                        object.totalBytesBilled = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytesBilled) : options.longs === Number ? new $util.LongBits(message.totalBytesBilled.low >>> 0, message.totalBytesBilled.high >>> 0).toNumber() : message.totalBytesBilled;
                return object;
            };

            /**
             * Converts this BigqueryMetadata to JSON.
             * @function toJSON
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BigqueryMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BigqueryMetadata;
        })();

        return ExecutionMetadata;
    })();

    dataform.TaskResult = (function() {

        /**
         * Properties of a TaskResult.
         * @memberof dataform
         * @interface ITaskResult
         * @property {dataform.TaskResult.ExecutionStatus|null} [status] TaskResult status
         * @property {string|null} [errorMessage] TaskResult errorMessage
         * @property {dataform.ITiming|null} [timing] TaskResult timing
         * @property {dataform.IExecutionMetadata|null} [metadata] TaskResult metadata
         */

        /**
         * Constructs a new TaskResult.
         * @memberof dataform
         * @classdesc Represents a TaskResult.
         * @implements ITaskResult
         * @constructor
         * @param {dataform.ITaskResult=} [properties] Properties to set
         */
        function TaskResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskResult status.
         * @member {dataform.TaskResult.ExecutionStatus} status
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.status = 0;

        /**
         * TaskResult errorMessage.
         * @member {string} errorMessage
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.errorMessage = "";

        /**
         * TaskResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.timing = null;

        /**
         * TaskResult metadata.
         * @member {dataform.IExecutionMetadata|null|undefined} metadata
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.metadata = null;

        /**
         * Creates a new TaskResult instance using the specified properties.
         * @function create
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult=} [properties] Properties to set
         * @returns {dataform.TaskResult} TaskResult instance
         */
        TaskResult.create = function create(properties) {
            return new TaskResult(properties);
        };

        /**
         * Encodes the specified TaskResult message. Does not implicitly {@link dataform.TaskResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
            if (message.timing != null && message.hasOwnProperty("timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.dataform.ExecutionMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TaskResult message, length delimited. Does not implicitly {@link dataform.TaskResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TaskResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                case 2:
                    message.errorMessage = reader.string();
                    break;
                case 3:
                    message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.metadata = $root.dataform.ExecutionMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskResult message.
         * @function verify
         * @memberof dataform.TaskResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                let error = $root.dataform.ExecutionMetadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            return null;
        };

        /**
         * Creates a TaskResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TaskResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TaskResult} TaskResult
         */
        TaskResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TaskResult)
                return object;
            let message = new $root.dataform.TaskResult();
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "SKIPPED":
            case 4:
                message.status = 4;
                break;
            case "CANCELLED":
            case 5:
                message.status = 5;
                break;
            }
            if (object.errorMessage != null)
                message.errorMessage = String(object.errorMessage);
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.TaskResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".dataform.TaskResult.metadata: object expected");
                message.metadata = $root.dataform.ExecutionMetadata.fromObject(object.metadata);
            }
            return message;
        };

        /**
         * Creates a plain object from a TaskResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.TaskResult} message TaskResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.errorMessage = "";
                object.timing = null;
                object.metadata = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.TaskResult.ExecutionStatus[message.status] : message.status;
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                object.errorMessage = message.errorMessage;
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.dataform.ExecutionMetadata.toObject(message.metadata, options);
            return object;
        };

        /**
         * Converts this TaskResult to JSON.
         * @function toJSON
         * @memberof dataform.TaskResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.TaskResult.ExecutionStatus
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SKIPPED=4 SKIPPED value
         * @property {number} CANCELLED=5 CANCELLED value
         */
        TaskResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SKIPPED"] = 4;
            values[valuesById[5] = "CANCELLED"] = 5;
            return values;
        })();

        return TaskResult;
    })();

    dataform.TestResult = (function() {

        /**
         * Properties of a TestResult.
         * @memberof dataform
         * @interface ITestResult
         * @property {string|null} [name] TestResult name
         * @property {boolean|null} [successful] TestResult successful
         * @property {Array.<string>|null} [messages] TestResult messages
         */

        /**
         * Constructs a new TestResult.
         * @memberof dataform
         * @classdesc Represents a TestResult.
         * @implements ITestResult
         * @constructor
         * @param {dataform.ITestResult=} [properties] Properties to set
         */
        function TestResult(properties) {
            this.messages = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestResult name.
         * @member {string} name
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.name = "";

        /**
         * TestResult successful.
         * @member {boolean} successful
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.successful = false;

        /**
         * TestResult messages.
         * @member {Array.<string>} messages
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.messages = $util.emptyArray;

        /**
         * Creates a new TestResult instance using the specified properties.
         * @function create
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult=} [properties] Properties to set
         * @returns {dataform.TestResult} TestResult instance
         */
        TestResult.create = function create(properties) {
            return new TestResult(properties);
        };

        /**
         * Encodes the specified TestResult message. Does not implicitly {@link dataform.TestResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult} message TestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.successful != null && message.hasOwnProperty("successful"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.successful);
            if (message.messages != null && message.messages.length)
                for (let i = 0; i < message.messages.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.messages[i]);
            return writer;
        };

        /**
         * Encodes the specified TestResult message, length delimited. Does not implicitly {@link dataform.TestResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult} message TestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TestResult} TestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TestResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.successful = reader.bool();
                    break;
                case 3:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TestResult} TestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestResult message.
         * @function verify
         * @memberof dataform.TestResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.successful != null && message.hasOwnProperty("successful"))
                if (typeof message.successful !== "boolean")
                    return "successful: boolean expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (let i = 0; i < message.messages.length; ++i)
                    if (!$util.isString(message.messages[i]))
                        return "messages: string[] expected";
            }
            return null;
        };

        /**
         * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TestResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TestResult} TestResult
         */
        TestResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TestResult)
                return object;
            let message = new $root.dataform.TestResult();
            if (object.name != null)
                message.name = String(object.name);
            if (object.successful != null)
                message.successful = Boolean(object.successful);
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".dataform.TestResult.messages: array expected");
                message.messages = [];
                for (let i = 0; i < object.messages.length; ++i)
                    message.messages[i] = String(object.messages[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.TestResult} message TestResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (options.defaults) {
                object.name = "";
                object.successful = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.successful != null && message.hasOwnProperty("successful"))
                object.successful = message.successful;
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (let j = 0; j < message.messages.length; ++j)
                    object.messages[j] = message.messages[j];
            }
            return object;
        };

        /**
         * Converts this TestResult to JSON.
         * @function toJSON
         * @memberof dataform.TestResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TestResult;
    })();

    dataform.Field = (function() {

        /**
         * Properties of a Field.
         * @memberof dataform
         * @interface IField
         * @property {string|null} [name] Field name
         * @property {Array.<dataform.Field.Flag>|null} [flags] Field flags
         * @property {dataform.Field.Primitive|null} [primitive] Field primitive
         * @property {dataform.IFields|null} [struct] Field struct
         * @property {string|null} [description] Field description
         * @property {Array.<string>|null} [flagsDeprecated] Field flagsDeprecated
         */

        /**
         * Constructs a new Field.
         * @memberof dataform
         * @classdesc Represents a Field.
         * @implements IField
         * @constructor
         * @param {dataform.IField=} [properties] Properties to set
         */
        function Field(properties) {
            this.flags = [];
            this.flagsDeprecated = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Field name.
         * @member {string} name
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.name = "";

        /**
         * Field flags.
         * @member {Array.<dataform.Field.Flag>} flags
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.flags = $util.emptyArray;

        /**
         * Field primitive.
         * @member {dataform.Field.Primitive} primitive
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.primitive = 0;

        /**
         * Field struct.
         * @member {dataform.IFields|null|undefined} struct
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.struct = null;

        /**
         * Field description.
         * @member {string} description
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.description = "";

        /**
         * Field flagsDeprecated.
         * @member {Array.<string>} flagsDeprecated
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.flagsDeprecated = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Field type.
         * @member {"primitive"|"struct"|undefined} type
         * @memberof dataform.Field
         * @instance
         */
        Object.defineProperty(Field.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["primitive", "struct"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Field instance using the specified properties.
         * @function create
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField=} [properties] Properties to set
         * @returns {dataform.Field} Field instance
         */
        Field.create = function create(properties) {
            return new Field(properties);
        };

        /**
         * Encodes the specified Field message. Does not implicitly {@link dataform.Field.verify|verify} messages.
         * @function encode
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.struct != null && message.hasOwnProperty("struct"))
                $root.dataform.Fields.encode(message.struct, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.flagsDeprecated != null && message.flagsDeprecated.length)
                for (let i = 0; i < message.flagsDeprecated.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.flagsDeprecated[i]);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.flags != null && message.flags.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (let i = 0; i < message.flags.length; ++i)
                    writer.int32(message.flags[i]);
                writer.ldelim();
            }
            if (message.primitive != null && message.hasOwnProperty("primitive"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.primitive);
            return writer;
        };

        /**
         * Encodes the specified Field message, length delimited. Does not implicitly {@link dataform.Field.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Field message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Field();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 6:
                    if (!(message.flags && message.flags.length))
                        message.flags = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.flags.push(reader.int32());
                    } else
                        message.flags.push(reader.int32());
                    break;
                case 7:
                    message.primitive = reader.int32();
                    break;
                case 3:
                    message.struct = $root.dataform.Fields.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                case 4:
                    if (!(message.flagsDeprecated && message.flagsDeprecated.length))
                        message.flagsDeprecated = [];
                    message.flagsDeprecated.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Field message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Field message.
         * @function verify
         * @memberof dataform.Field
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Field.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (let i = 0; i < message.flags.length; ++i)
                    switch (message.flags[i]) {
                    default:
                        return "flags: enum value[] expected";
                    case 0:
                    case 1:
                        break;
                    }
            }
            if (message.primitive != null && message.hasOwnProperty("primitive")) {
                properties.type = 1;
                switch (message.primitive) {
                default:
                    return "primitive: enum value expected";
                case 0:
                case 1:
                case 2:
                case 5:
                case 3:
                case 4:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            }
            if (message.struct != null && message.hasOwnProperty("struct")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.dataform.Fields.verify(message.struct);
                    if (error)
                        return "struct." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.flagsDeprecated != null && message.hasOwnProperty("flagsDeprecated")) {
                if (!Array.isArray(message.flagsDeprecated))
                    return "flagsDeprecated: array expected";
                for (let i = 0; i < message.flagsDeprecated.length; ++i)
                    if (!$util.isString(message.flagsDeprecated[i]))
                        return "flagsDeprecated: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Field message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Field
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Field} Field
         */
        Field.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Field)
                return object;
            let message = new $root.dataform.Field();
            if (object.name != null)
                message.name = String(object.name);
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".dataform.Field.flags: array expected");
                message.flags = [];
                for (let i = 0; i < object.flags.length; ++i)
                    switch (object.flags[i]) {
                    default:
                    case "UNKNOWN_FLAG":
                    case 0:
                        message.flags[i] = 0;
                        break;
                    case "REPEATED":
                    case 1:
                        message.flags[i] = 1;
                        break;
                    }
            }
            switch (object.primitive) {
            case "UNKNOWN":
            case 0:
                message.primitive = 0;
                break;
            case "INTEGER":
            case 1:
                message.primitive = 1;
                break;
            case "FLOAT":
            case 2:
                message.primitive = 2;
                break;
            case "NUMERIC":
            case 5:
                message.primitive = 5;
                break;
            case "BOOLEAN":
            case 3:
                message.primitive = 3;
                break;
            case "STRING":
            case 4:
                message.primitive = 4;
                break;
            case "DATE":
            case 6:
                message.primitive = 6;
                break;
            case "DATETIME":
            case 7:
                message.primitive = 7;
                break;
            case "TIMESTAMP":
            case 8:
                message.primitive = 8;
                break;
            case "TIME":
            case 9:
                message.primitive = 9;
                break;
            case "BYTES":
            case 10:
                message.primitive = 10;
                break;
            case "ANY":
            case 11:
                message.primitive = 11;
                break;
            case "GEOGRAPHY":
            case 12:
                message.primitive = 12;
                break;
            }
            if (object.struct != null) {
                if (typeof object.struct !== "object")
                    throw TypeError(".dataform.Field.struct: object expected");
                message.struct = $root.dataform.Fields.fromObject(object.struct);
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.flagsDeprecated) {
                if (!Array.isArray(object.flagsDeprecated))
                    throw TypeError(".dataform.Field.flagsDeprecated: array expected");
                message.flagsDeprecated = [];
                for (let i = 0; i < object.flagsDeprecated.length; ++i)
                    message.flagsDeprecated[i] = String(object.flagsDeprecated[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Field message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Field
         * @static
         * @param {dataform.Field} message Field
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Field.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.flagsDeprecated = [];
                object.flags = [];
            }
            if (options.defaults) {
                object.name = "";
                object.description = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.struct != null && message.hasOwnProperty("struct")) {
                object.struct = $root.dataform.Fields.toObject(message.struct, options);
                if (options.oneofs)
                    object.type = "struct";
            }
            if (message.flagsDeprecated && message.flagsDeprecated.length) {
                object.flagsDeprecated = [];
                for (let j = 0; j < message.flagsDeprecated.length; ++j)
                    object.flagsDeprecated[j] = message.flagsDeprecated[j];
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (let j = 0; j < message.flags.length; ++j)
                    object.flags[j] = options.enums === String ? $root.dataform.Field.Flag[message.flags[j]] : message.flags[j];
            }
            if (message.primitive != null && message.hasOwnProperty("primitive")) {
                object.primitive = options.enums === String ? $root.dataform.Field.Primitive[message.primitive] : message.primitive;
                if (options.oneofs)
                    object.type = "primitive";
            }
            return object;
        };

        /**
         * Converts this Field to JSON.
         * @function toJSON
         * @memberof dataform.Field
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Field.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Primitive enum.
         * @name dataform.Field.Primitive
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} INTEGER=1 INTEGER value
         * @property {number} FLOAT=2 FLOAT value
         * @property {number} NUMERIC=5 NUMERIC value
         * @property {number} BOOLEAN=3 BOOLEAN value
         * @property {number} STRING=4 STRING value
         * @property {number} DATE=6 DATE value
         * @property {number} DATETIME=7 DATETIME value
         * @property {number} TIMESTAMP=8 TIMESTAMP value
         * @property {number} TIME=9 TIME value
         * @property {number} BYTES=10 BYTES value
         * @property {number} ANY=11 ANY value
         * @property {number} GEOGRAPHY=12 GEOGRAPHY value
         */
        Field.Primitive = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "INTEGER"] = 1;
            values[valuesById[2] = "FLOAT"] = 2;
            values[valuesById[5] = "NUMERIC"] = 5;
            values[valuesById[3] = "BOOLEAN"] = 3;
            values[valuesById[4] = "STRING"] = 4;
            values[valuesById[6] = "DATE"] = 6;
            values[valuesById[7] = "DATETIME"] = 7;
            values[valuesById[8] = "TIMESTAMP"] = 8;
            values[valuesById[9] = "TIME"] = 9;
            values[valuesById[10] = "BYTES"] = 10;
            values[valuesById[11] = "ANY"] = 11;
            values[valuesById[12] = "GEOGRAPHY"] = 12;
            return values;
        })();

        /**
         * Flag enum.
         * @name dataform.Field.Flag
         * @enum {string}
         * @property {number} UNKNOWN_FLAG=0 UNKNOWN_FLAG value
         * @property {number} REPEATED=1 REPEATED value
         */
        Field.Flag = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_FLAG"] = 0;
            values[valuesById[1] = "REPEATED"] = 1;
            return values;
        })();

        return Field;
    })();

    dataform.Fields = (function() {

        /**
         * Properties of a Fields.
         * @memberof dataform
         * @interface IFields
         * @property {Array.<dataform.IField>|null} [fields] Fields fields
         */

        /**
         * Constructs a new Fields.
         * @memberof dataform
         * @classdesc Represents a Fields.
         * @implements IFields
         * @constructor
         * @param {dataform.IFields=} [properties] Properties to set
         */
        function Fields(properties) {
            this.fields = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fields fields.
         * @member {Array.<dataform.IField>} fields
         * @memberof dataform.Fields
         * @instance
         */
        Fields.prototype.fields = $util.emptyArray;

        /**
         * Creates a new Fields instance using the specified properties.
         * @function create
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields=} [properties] Properties to set
         * @returns {dataform.Fields} Fields instance
         */
        Fields.create = function create(properties) {
            return new Fields(properties);
        };

        /**
         * Encodes the specified Fields message. Does not implicitly {@link dataform.Fields.verify|verify} messages.
         * @function encode
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields} message Fields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fields != null && message.fields.length)
                for (let i = 0; i < message.fields.length; ++i)
                    $root.dataform.Field.encode(message.fields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Fields message, length delimited. Does not implicitly {@link dataform.Fields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields} message Fields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fields message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Fields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Fields} Fields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Fields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.dataform.Field.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Fields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Fields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Fields} Fields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fields message.
         * @function verify
         * @memberof dataform.Fields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (let i = 0; i < message.fields.length; ++i) {
                    let error = $root.dataform.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Fields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Fields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Fields} Fields
         */
        Fields.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Fields)
                return object;
            let message = new $root.dataform.Fields();
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".dataform.Fields.fields: array expected");
                message.fields = [];
                for (let i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".dataform.Fields.fields: object expected");
                    message.fields[i] = $root.dataform.Field.fromObject(object.fields[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Fields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Fields
         * @static
         * @param {dataform.Fields} message Fields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (let j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.dataform.Field.toObject(message.fields[j], options);
            }
            return object;
        };

        /**
         * Converts this Fields to JSON.
         * @function toJSON
         * @memberof dataform.Fields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fields;
    })();

    dataform.TableMetadata = (function() {

        /**
         * Properties of a TableMetadata.
         * @memberof dataform
         * @interface ITableMetadata
         * @property {dataform.ITarget|null} [target] TableMetadata target
         * @property {dataform.TableMetadata.Type|null} [type] TableMetadata type
         * @property {Array.<dataform.IField>|null} [fields] TableMetadata fields
         * @property {string|null} [description] TableMetadata description
         * @property {Object.<string,string>|null} [labels] TableMetadata labels
         * @property {Long|null} [lastUpdatedMillis] TableMetadata lastUpdatedMillis
         * @property {dataform.TableMetadata.IBigQuery|null} [bigquery] TableMetadata bigquery
         * @property {string|null} [typeDeprecated] TableMetadata typeDeprecated
         */

        /**
         * Constructs a new TableMetadata.
         * @memberof dataform
         * @classdesc Represents a TableMetadata.
         * @implements ITableMetadata
         * @constructor
         * @param {dataform.ITableMetadata=} [properties] Properties to set
         */
        function TableMetadata(properties) {
            this.fields = [];
            this.labels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TableMetadata target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.target = null;

        /**
         * TableMetadata type.
         * @member {dataform.TableMetadata.Type} type
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.type = 0;

        /**
         * TableMetadata fields.
         * @member {Array.<dataform.IField>} fields
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.fields = $util.emptyArray;

        /**
         * TableMetadata description.
         * @member {string} description
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.description = "";

        /**
         * TableMetadata labels.
         * @member {Object.<string,string>} labels
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.labels = $util.emptyObject;

        /**
         * TableMetadata lastUpdatedMillis.
         * @member {Long} lastUpdatedMillis
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.lastUpdatedMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TableMetadata bigquery.
         * @member {dataform.TableMetadata.IBigQuery|null|undefined} bigquery
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.bigquery = null;

        /**
         * TableMetadata typeDeprecated.
         * @member {string} typeDeprecated
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.typeDeprecated = "";

        /**
         * Creates a new TableMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata=} [properties] Properties to set
         * @returns {dataform.TableMetadata} TableMetadata instance
         */
        TableMetadata.create = function create(properties) {
            return new TableMetadata(properties);
        };

        /**
         * Encodes the specified TableMetadata message. Does not implicitly {@link dataform.TableMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata} message TableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.typeDeprecated != null && message.hasOwnProperty("typeDeprecated"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.typeDeprecated);
            if (message.fields != null && message.fields.length)
                for (let i = 0; i < message.fields.length; ++i)
                    $root.dataform.Field.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lastUpdatedMillis);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            if (message.labels != null && message.hasOwnProperty("labels"))
                for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                $root.dataform.TableMetadata.BigQuery.encode(message.bigquery, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TableMetadata message, length delimited. Does not implicitly {@link dataform.TableMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata} message TableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TableMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TableMetadata} TableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TableMetadata(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                case 3:
                    if (!(message.fields && message.fields.length))
                        message.fields = [];
                    message.fields.push($root.dataform.Field.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                case 7:
                    reader.skip().pos++;
                    if (message.labels === $util.emptyObject)
                        message.labels = {};
                    key = reader.string();
                    reader.pos++;
                    message.labels[key] = reader.string();
                    break;
                case 4:
                    message.lastUpdatedMillis = reader.int64();
                    break;
                case 8:
                    message.bigquery = $root.dataform.TableMetadata.BigQuery.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.typeDeprecated = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TableMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TableMetadata} TableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TableMetadata message.
         * @function verify
         * @memberof dataform.TableMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TableMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (let i = 0; i < message.fields.length; ++i) {
                    let error = $root.dataform.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!$util.isObject(message.labels))
                    return "labels: object expected";
                let key = Object.keys(message.labels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.labels[key[i]]))
                        return "labels: string{k:string} expected";
            }
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (!$util.isInteger(message.lastUpdatedMillis) && !(message.lastUpdatedMillis && $util.isInteger(message.lastUpdatedMillis.low) && $util.isInteger(message.lastUpdatedMillis.high)))
                    return "lastUpdatedMillis: integer|Long expected";
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.TableMetadata.BigQuery.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            if (message.typeDeprecated != null && message.hasOwnProperty("typeDeprecated"))
                if (!$util.isString(message.typeDeprecated))
                    return "typeDeprecated: string expected";
            return null;
        };

        /**
         * Creates a TableMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TableMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TableMetadata} TableMetadata
         */
        TableMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TableMetadata)
                return object;
            let message = new $root.dataform.TableMetadata();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.TableMetadata.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "TABLE":
            case 1:
                message.type = 1;
                break;
            case "VIEW":
            case 2:
                message.type = 2;
                break;
            }
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".dataform.TableMetadata.fields: array expected");
                message.fields = [];
                for (let i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".dataform.TableMetadata.fields: object expected");
                    message.fields[i] = $root.dataform.Field.fromObject(object.fields[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.labels) {
                if (typeof object.labels !== "object")
                    throw TypeError(".dataform.TableMetadata.labels: object expected");
                message.labels = {};
                for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                    message.labels[keys[i]] = String(object.labels[keys[i]]);
            }
            if (object.lastUpdatedMillis != null)
                if ($util.Long)
                    (message.lastUpdatedMillis = $util.Long.fromValue(object.lastUpdatedMillis)).unsigned = false;
                else if (typeof object.lastUpdatedMillis === "string")
                    message.lastUpdatedMillis = parseInt(object.lastUpdatedMillis, 10);
                else if (typeof object.lastUpdatedMillis === "number")
                    message.lastUpdatedMillis = object.lastUpdatedMillis;
                else if (typeof object.lastUpdatedMillis === "object")
                    message.lastUpdatedMillis = new $util.LongBits(object.lastUpdatedMillis.low >>> 0, object.lastUpdatedMillis.high >>> 0).toNumber();
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.TableMetadata.bigquery: object expected");
                message.bigquery = $root.dataform.TableMetadata.BigQuery.fromObject(object.bigquery);
            }
            if (object.typeDeprecated != null)
                message.typeDeprecated = String(object.typeDeprecated);
            return message;
        };

        /**
         * Creates a plain object from a TableMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.TableMetadata} message TableMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TableMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (options.objects || options.defaults)
                object.labels = {};
            if (options.defaults) {
                object.target = null;
                object.typeDeprecated = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lastUpdatedMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastUpdatedMillis = options.longs === String ? "0" : 0;
                object.description = "";
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.bigquery = null;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.typeDeprecated != null && message.hasOwnProperty("typeDeprecated"))
                object.typeDeprecated = message.typeDeprecated;
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (let j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.dataform.Field.toObject(message.fields[j], options);
            }
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (typeof message.lastUpdatedMillis === "number")
                    object.lastUpdatedMillis = options.longs === String ? String(message.lastUpdatedMillis) : message.lastUpdatedMillis;
                else
                    object.lastUpdatedMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdatedMillis) : options.longs === Number ? new $util.LongBits(message.lastUpdatedMillis.low >>> 0, message.lastUpdatedMillis.high >>> 0).toNumber() : message.lastUpdatedMillis;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.dataform.TableMetadata.Type[message.type] : message.type;
            let keys2;
            if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                object.labels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.labels[keys2[j]] = message.labels[keys2[j]];
            }
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.TableMetadata.BigQuery.toObject(message.bigquery, options);
            return object;
        };

        /**
         * Converts this TableMetadata to JSON.
         * @function toJSON
         * @memberof dataform.TableMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TableMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name dataform.TableMetadata.Type
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} TABLE=1 TABLE value
         * @property {number} VIEW=2 VIEW value
         */
        TableMetadata.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "TABLE"] = 1;
            values[valuesById[2] = "VIEW"] = 2;
            return values;
        })();

        TableMetadata.BigQuery = (function() {

            /**
             * Properties of a BigQuery.
             * @memberof dataform.TableMetadata
             * @interface IBigQuery
             * @property {boolean|null} [hasStreamingBuffer] BigQuery hasStreamingBuffer
             */

            /**
             * Constructs a new BigQuery.
             * @memberof dataform.TableMetadata
             * @classdesc Represents a BigQuery.
             * @implements IBigQuery
             * @constructor
             * @param {dataform.TableMetadata.IBigQuery=} [properties] Properties to set
             */
            function BigQuery(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BigQuery hasStreamingBuffer.
             * @member {boolean} hasStreamingBuffer
             * @memberof dataform.TableMetadata.BigQuery
             * @instance
             */
            BigQuery.prototype.hasStreamingBuffer = false;

            /**
             * Creates a new BigQuery instance using the specified properties.
             * @function create
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery=} [properties] Properties to set
             * @returns {dataform.TableMetadata.BigQuery} BigQuery instance
             */
            BigQuery.create = function create(properties) {
                return new BigQuery(properties);
            };

            /**
             * Encodes the specified BigQuery message. Does not implicitly {@link dataform.TableMetadata.BigQuery.verify|verify} messages.
             * @function encode
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery} message BigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hasStreamingBuffer);
                return writer;
            };

            /**
             * Encodes the specified BigQuery message, length delimited. Does not implicitly {@link dataform.TableMetadata.BigQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery} message BigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BigQuery message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TableMetadata.BigQuery();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hasStreamingBuffer = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BigQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BigQuery message.
             * @function verify
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BigQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    if (typeof message.hasStreamingBuffer !== "boolean")
                        return "hasStreamingBuffer: boolean expected";
                return null;
            };

            /**
             * Creates a BigQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             */
            BigQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.TableMetadata.BigQuery)
                    return object;
                let message = new $root.dataform.TableMetadata.BigQuery();
                if (object.hasStreamingBuffer != null)
                    message.hasStreamingBuffer = Boolean(object.hasStreamingBuffer);
                return message;
            };

            /**
             * Creates a plain object from a BigQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.BigQuery} message BigQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BigQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.hasStreamingBuffer = false;
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    object.hasStreamingBuffer = message.hasStreamingBuffer;
                return object;
            };

            /**
             * Converts this BigQuery to JSON.
             * @function toJSON
             * @memberof dataform.TableMetadata.BigQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BigQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BigQuery;
        })();

        return TableMetadata;
    })();

    dataform.PersistedTableMetadata = (function() {

        /**
         * Properties of a PersistedTableMetadata.
         * @memberof dataform
         * @interface IPersistedTableMetadata
         * @property {dataform.ITarget|null} [target] PersistedTableMetadata target
         * @property {string|null} [definitionHash] PersistedTableMetadata definitionHash
         * @property {Long|null} [lastUpdatedMillis] PersistedTableMetadata lastUpdatedMillis
         * @property {Array.<dataform.PersistedTableMetadata.ITransitiveInputMetadata>|null} [transitiveInputTables] PersistedTableMetadata transitiveInputTables
         */

        /**
         * Constructs a new PersistedTableMetadata.
         * @memberof dataform
         * @classdesc Represents a PersistedTableMetadata.
         * @implements IPersistedTableMetadata
         * @constructor
         * @param {dataform.IPersistedTableMetadata=} [properties] Properties to set
         */
        function PersistedTableMetadata(properties) {
            this.transitiveInputTables = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PersistedTableMetadata target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.PersistedTableMetadata
         * @instance
         */
        PersistedTableMetadata.prototype.target = null;

        /**
         * PersistedTableMetadata definitionHash.
         * @member {string} definitionHash
         * @memberof dataform.PersistedTableMetadata
         * @instance
         */
        PersistedTableMetadata.prototype.definitionHash = "";

        /**
         * PersistedTableMetadata lastUpdatedMillis.
         * @member {Long} lastUpdatedMillis
         * @memberof dataform.PersistedTableMetadata
         * @instance
         */
        PersistedTableMetadata.prototype.lastUpdatedMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PersistedTableMetadata transitiveInputTables.
         * @member {Array.<dataform.PersistedTableMetadata.ITransitiveInputMetadata>} transitiveInputTables
         * @memberof dataform.PersistedTableMetadata
         * @instance
         */
        PersistedTableMetadata.prototype.transitiveInputTables = $util.emptyArray;

        /**
         * Creates a new PersistedTableMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {dataform.IPersistedTableMetadata=} [properties] Properties to set
         * @returns {dataform.PersistedTableMetadata} PersistedTableMetadata instance
         */
        PersistedTableMetadata.create = function create(properties) {
            return new PersistedTableMetadata(properties);
        };

        /**
         * Encodes the specified PersistedTableMetadata message. Does not implicitly {@link dataform.PersistedTableMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {dataform.IPersistedTableMetadata} message PersistedTableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PersistedTableMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && message.hasOwnProperty("target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.definitionHash != null && message.hasOwnProperty("definitionHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.definitionHash);
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastUpdatedMillis);
            if (message.transitiveInputTables != null && message.transitiveInputTables.length)
                for (let i = 0; i < message.transitiveInputTables.length; ++i)
                    $root.dataform.PersistedTableMetadata.TransitiveInputMetadata.encode(message.transitiveInputTables[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PersistedTableMetadata message, length delimited. Does not implicitly {@link dataform.PersistedTableMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {dataform.IPersistedTableMetadata} message PersistedTableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PersistedTableMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PersistedTableMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.PersistedTableMetadata} PersistedTableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersistedTableMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.PersistedTableMetadata();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.target = $root.dataform.Target.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.definitionHash = reader.string();
                    break;
                case 3:
                    message.lastUpdatedMillis = reader.int64();
                    break;
                case 7:
                    if (!(message.transitiveInputTables && message.transitiveInputTables.length))
                        message.transitiveInputTables = [];
                    message.transitiveInputTables.push($root.dataform.PersistedTableMetadata.TransitiveInputMetadata.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PersistedTableMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.PersistedTableMetadata} PersistedTableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersistedTableMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PersistedTableMetadata message.
         * @function verify
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PersistedTableMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.definitionHash != null && message.hasOwnProperty("definitionHash"))
                if (!$util.isString(message.definitionHash))
                    return "definitionHash: string expected";
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (!$util.isInteger(message.lastUpdatedMillis) && !(message.lastUpdatedMillis && $util.isInteger(message.lastUpdatedMillis.low) && $util.isInteger(message.lastUpdatedMillis.high)))
                    return "lastUpdatedMillis: integer|Long expected";
            if (message.transitiveInputTables != null && message.hasOwnProperty("transitiveInputTables")) {
                if (!Array.isArray(message.transitiveInputTables))
                    return "transitiveInputTables: array expected";
                for (let i = 0; i < message.transitiveInputTables.length; ++i) {
                    let error = $root.dataform.PersistedTableMetadata.TransitiveInputMetadata.verify(message.transitiveInputTables[i]);
                    if (error)
                        return "transitiveInputTables." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PersistedTableMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.PersistedTableMetadata} PersistedTableMetadata
         */
        PersistedTableMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.PersistedTableMetadata)
                return object;
            let message = new $root.dataform.PersistedTableMetadata();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.PersistedTableMetadata.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.definitionHash != null)
                message.definitionHash = String(object.definitionHash);
            if (object.lastUpdatedMillis != null)
                if ($util.Long)
                    (message.lastUpdatedMillis = $util.Long.fromValue(object.lastUpdatedMillis)).unsigned = false;
                else if (typeof object.lastUpdatedMillis === "string")
                    message.lastUpdatedMillis = parseInt(object.lastUpdatedMillis, 10);
                else if (typeof object.lastUpdatedMillis === "number")
                    message.lastUpdatedMillis = object.lastUpdatedMillis;
                else if (typeof object.lastUpdatedMillis === "object")
                    message.lastUpdatedMillis = new $util.LongBits(object.lastUpdatedMillis.low >>> 0, object.lastUpdatedMillis.high >>> 0).toNumber();
            if (object.transitiveInputTables) {
                if (!Array.isArray(object.transitiveInputTables))
                    throw TypeError(".dataform.PersistedTableMetadata.transitiveInputTables: array expected");
                message.transitiveInputTables = [];
                for (let i = 0; i < object.transitiveInputTables.length; ++i) {
                    if (typeof object.transitiveInputTables[i] !== "object")
                        throw TypeError(".dataform.PersistedTableMetadata.transitiveInputTables: object expected");
                    message.transitiveInputTables[i] = $root.dataform.PersistedTableMetadata.TransitiveInputMetadata.fromObject(object.transitiveInputTables[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PersistedTableMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.PersistedTableMetadata
         * @static
         * @param {dataform.PersistedTableMetadata} message PersistedTableMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PersistedTableMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.transitiveInputTables = [];
            if (options.defaults) {
                object.target = null;
                object.definitionHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lastUpdatedMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastUpdatedMillis = options.longs === String ? "0" : 0;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.definitionHash != null && message.hasOwnProperty("definitionHash"))
                object.definitionHash = message.definitionHash;
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (typeof message.lastUpdatedMillis === "number")
                    object.lastUpdatedMillis = options.longs === String ? String(message.lastUpdatedMillis) : message.lastUpdatedMillis;
                else
                    object.lastUpdatedMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdatedMillis) : options.longs === Number ? new $util.LongBits(message.lastUpdatedMillis.low >>> 0, message.lastUpdatedMillis.high >>> 0).toNumber() : message.lastUpdatedMillis;
            if (message.transitiveInputTables && message.transitiveInputTables.length) {
                object.transitiveInputTables = [];
                for (let j = 0; j < message.transitiveInputTables.length; ++j)
                    object.transitiveInputTables[j] = $root.dataform.PersistedTableMetadata.TransitiveInputMetadata.toObject(message.transitiveInputTables[j], options);
            }
            return object;
        };

        /**
         * Converts this PersistedTableMetadata to JSON.
         * @function toJSON
         * @memberof dataform.PersistedTableMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PersistedTableMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        PersistedTableMetadata.TransitiveInputMetadata = (function() {

            /**
             * Properties of a TransitiveInputMetadata.
             * @memberof dataform.PersistedTableMetadata
             * @interface ITransitiveInputMetadata
             * @property {dataform.ITarget|null} [target] TransitiveInputMetadata target
             * @property {Long|null} [lastUpdatedMillis] TransitiveInputMetadata lastUpdatedMillis
             */

            /**
             * Constructs a new TransitiveInputMetadata.
             * @memberof dataform.PersistedTableMetadata
             * @classdesc Represents a TransitiveInputMetadata.
             * @implements ITransitiveInputMetadata
             * @constructor
             * @param {dataform.PersistedTableMetadata.ITransitiveInputMetadata=} [properties] Properties to set
             */
            function TransitiveInputMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransitiveInputMetadata target.
             * @member {dataform.ITarget|null|undefined} target
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @instance
             */
            TransitiveInputMetadata.prototype.target = null;

            /**
             * TransitiveInputMetadata lastUpdatedMillis.
             * @member {Long} lastUpdatedMillis
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @instance
             */
            TransitiveInputMetadata.prototype.lastUpdatedMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new TransitiveInputMetadata instance using the specified properties.
             * @function create
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {dataform.PersistedTableMetadata.ITransitiveInputMetadata=} [properties] Properties to set
             * @returns {dataform.PersistedTableMetadata.TransitiveInputMetadata} TransitiveInputMetadata instance
             */
            TransitiveInputMetadata.create = function create(properties) {
                return new TransitiveInputMetadata(properties);
            };

            /**
             * Encodes the specified TransitiveInputMetadata message. Does not implicitly {@link dataform.PersistedTableMetadata.TransitiveInputMetadata.verify|verify} messages.
             * @function encode
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {dataform.PersistedTableMetadata.ITransitiveInputMetadata} message TransitiveInputMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransitiveInputMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && message.hasOwnProperty("target"))
                    $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.lastUpdatedMillis);
                return writer;
            };

            /**
             * Encodes the specified TransitiveInputMetadata message, length delimited. Does not implicitly {@link dataform.PersistedTableMetadata.TransitiveInputMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {dataform.PersistedTableMetadata.ITransitiveInputMetadata} message TransitiveInputMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransitiveInputMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransitiveInputMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.PersistedTableMetadata.TransitiveInputMetadata} TransitiveInputMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransitiveInputMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.PersistedTableMetadata.TransitiveInputMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.lastUpdatedMillis = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransitiveInputMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.PersistedTableMetadata.TransitiveInputMetadata} TransitiveInputMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransitiveInputMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransitiveInputMetadata message.
             * @function verify
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransitiveInputMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target")) {
                    let error = $root.dataform.Target.verify(message.target);
                    if (error)
                        return "target." + error;
                }
                if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                    if (!$util.isInteger(message.lastUpdatedMillis) && !(message.lastUpdatedMillis && $util.isInteger(message.lastUpdatedMillis.low) && $util.isInteger(message.lastUpdatedMillis.high)))
                        return "lastUpdatedMillis: integer|Long expected";
                return null;
            };

            /**
             * Creates a TransitiveInputMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.PersistedTableMetadata.TransitiveInputMetadata} TransitiveInputMetadata
             */
            TransitiveInputMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.PersistedTableMetadata.TransitiveInputMetadata)
                    return object;
                let message = new $root.dataform.PersistedTableMetadata.TransitiveInputMetadata();
                if (object.target != null) {
                    if (typeof object.target !== "object")
                        throw TypeError(".dataform.PersistedTableMetadata.TransitiveInputMetadata.target: object expected");
                    message.target = $root.dataform.Target.fromObject(object.target);
                }
                if (object.lastUpdatedMillis != null)
                    if ($util.Long)
                        (message.lastUpdatedMillis = $util.Long.fromValue(object.lastUpdatedMillis)).unsigned = false;
                    else if (typeof object.lastUpdatedMillis === "string")
                        message.lastUpdatedMillis = parseInt(object.lastUpdatedMillis, 10);
                    else if (typeof object.lastUpdatedMillis === "number")
                        message.lastUpdatedMillis = object.lastUpdatedMillis;
                    else if (typeof object.lastUpdatedMillis === "object")
                        message.lastUpdatedMillis = new $util.LongBits(object.lastUpdatedMillis.low >>> 0, object.lastUpdatedMillis.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a TransitiveInputMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @static
             * @param {dataform.PersistedTableMetadata.TransitiveInputMetadata} message TransitiveInputMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransitiveInputMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.target = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.lastUpdatedMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastUpdatedMillis = options.longs === String ? "0" : 0;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    object.target = $root.dataform.Target.toObject(message.target, options);
                if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                    if (typeof message.lastUpdatedMillis === "number")
                        object.lastUpdatedMillis = options.longs === String ? String(message.lastUpdatedMillis) : message.lastUpdatedMillis;
                    else
                        object.lastUpdatedMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdatedMillis) : options.longs === Number ? new $util.LongBits(message.lastUpdatedMillis.low >>> 0, message.lastUpdatedMillis.high >>> 0).toNumber() : message.lastUpdatedMillis;
                return object;
            };

            /**
             * Converts this TransitiveInputMetadata to JSON.
             * @function toJSON
             * @memberof dataform.PersistedTableMetadata.TransitiveInputMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransitiveInputMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransitiveInputMetadata;
        })();

        return PersistedTableMetadata;
    })();

    dataform.JDBC = (function() {

        /**
         * Properties of a JDBC.
         * @memberof dataform
         * @interface IJDBC
         * @property {string|null} [host] JDBC host
         * @property {number|null} [port] JDBC port
         * @property {string|null} [username] JDBC username
         * @property {string|null} [password] JDBC password
         * @property {string|null} [databaseName] JDBC databaseName
         * @property {dataform.JDBC.ISslConfiguration|null} [ssl] JDBC ssl
         * @property {dataform.JDBC.ISshTunnel|null} [sshTunnel] JDBC sshTunnel
         */

        /**
         * Constructs a new JDBC.
         * @memberof dataform
         * @classdesc Represents a JDBC.
         * @implements IJDBC
         * @constructor
         * @param {dataform.IJDBC=} [properties] Properties to set
         */
        function JDBC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JDBC host.
         * @member {string} host
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.host = "";

        /**
         * JDBC port.
         * @member {number} port
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.port = 0;

        /**
         * JDBC username.
         * @member {string} username
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.username = "";

        /**
         * JDBC password.
         * @member {string} password
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.password = "";

        /**
         * JDBC databaseName.
         * @member {string} databaseName
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.databaseName = "";

        /**
         * JDBC ssl.
         * @member {dataform.JDBC.ISslConfiguration|null|undefined} ssl
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.ssl = null;

        /**
         * JDBC sshTunnel.
         * @member {dataform.JDBC.ISshTunnel|null|undefined} sshTunnel
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.sshTunnel = null;

        /**
         * Creates a new JDBC instance using the specified properties.
         * @function create
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC=} [properties] Properties to set
         * @returns {dataform.JDBC} JDBC instance
         */
        JDBC.create = function create(properties) {
            return new JDBC(properties);
        };

        /**
         * Encodes the specified JDBC message. Does not implicitly {@link dataform.JDBC.verify|verify} messages.
         * @function encode
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC} message JDBC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JDBC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && message.hasOwnProperty("host"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
            if (message.port != null && message.hasOwnProperty("port"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.port);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.username);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.databaseName);
            if (message.sshTunnel != null && message.hasOwnProperty("sshTunnel"))
                $root.dataform.JDBC.SshTunnel.encode(message.sshTunnel, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.ssl != null && message.hasOwnProperty("ssl"))
                $root.dataform.JDBC.SslConfiguration.encode(message.ssl, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified JDBC message, length delimited. Does not implicitly {@link dataform.JDBC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC} message JDBC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JDBC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JDBC message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.JDBC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.JDBC} JDBC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JDBC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.host = reader.string();
                    break;
                case 3:
                    message.port = reader.int32();
                    break;
                case 4:
                    message.username = reader.string();
                    break;
                case 5:
                    message.password = reader.string();
                    break;
                case 6:
                    message.databaseName = reader.string();
                    break;
                case 8:
                    message.ssl = $root.dataform.JDBC.SslConfiguration.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.sshTunnel = $root.dataform.JDBC.SshTunnel.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JDBC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.JDBC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.JDBC} JDBC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JDBC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JDBC message.
         * @function verify
         * @memberof dataform.JDBC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JDBC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                if (!$util.isString(message.databaseName))
                    return "databaseName: string expected";
            if (message.ssl != null && message.hasOwnProperty("ssl")) {
                let error = $root.dataform.JDBC.SslConfiguration.verify(message.ssl);
                if (error)
                    return "ssl." + error;
            }
            if (message.sshTunnel != null && message.hasOwnProperty("sshTunnel")) {
                let error = $root.dataform.JDBC.SshTunnel.verify(message.sshTunnel);
                if (error)
                    return "sshTunnel." + error;
            }
            return null;
        };

        /**
         * Creates a JDBC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.JDBC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.JDBC} JDBC
         */
        JDBC.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.JDBC)
                return object;
            let message = new $root.dataform.JDBC();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.databaseName != null)
                message.databaseName = String(object.databaseName);
            if (object.ssl != null) {
                if (typeof object.ssl !== "object")
                    throw TypeError(".dataform.JDBC.ssl: object expected");
                message.ssl = $root.dataform.JDBC.SslConfiguration.fromObject(object.ssl);
            }
            if (object.sshTunnel != null) {
                if (typeof object.sshTunnel !== "object")
                    throw TypeError(".dataform.JDBC.sshTunnel: object expected");
                message.sshTunnel = $root.dataform.JDBC.SshTunnel.fromObject(object.sshTunnel);
            }
            return message;
        };

        /**
         * Creates a plain object from a JDBC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.JDBC} message JDBC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JDBC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.username = "";
                object.password = "";
                object.databaseName = "";
                object.sshTunnel = null;
                object.ssl = null;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                object.databaseName = message.databaseName;
            if (message.sshTunnel != null && message.hasOwnProperty("sshTunnel"))
                object.sshTunnel = $root.dataform.JDBC.SshTunnel.toObject(message.sshTunnel, options);
            if (message.ssl != null && message.hasOwnProperty("ssl"))
                object.ssl = $root.dataform.JDBC.SslConfiguration.toObject(message.ssl, options);
            return object;
        };

        /**
         * Converts this JDBC to JSON.
         * @function toJSON
         * @memberof dataform.JDBC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JDBC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        JDBC.SslConfiguration = (function() {

            /**
             * Properties of a SslConfiguration.
             * @memberof dataform.JDBC
             * @interface ISslConfiguration
             * @property {string|null} [serverCertificate] SslConfiguration serverCertificate
             * @property {string|null} [clientCertificate] SslConfiguration clientCertificate
             * @property {string|null} [clientPrivateKey] SslConfiguration clientPrivateKey
             */

            /**
             * Constructs a new SslConfiguration.
             * @memberof dataform.JDBC
             * @classdesc Represents a SslConfiguration.
             * @implements ISslConfiguration
             * @constructor
             * @param {dataform.JDBC.ISslConfiguration=} [properties] Properties to set
             */
            function SslConfiguration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SslConfiguration serverCertificate.
             * @member {string} serverCertificate
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.serverCertificate = "";

            /**
             * SslConfiguration clientCertificate.
             * @member {string} clientCertificate
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.clientCertificate = "";

            /**
             * SslConfiguration clientPrivateKey.
             * @member {string} clientPrivateKey
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.clientPrivateKey = "";

            /**
             * Creates a new SslConfiguration instance using the specified properties.
             * @function create
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration=} [properties] Properties to set
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration instance
             */
            SslConfiguration.create = function create(properties) {
                return new SslConfiguration(properties);
            };

            /**
             * Encodes the specified SslConfiguration message. Does not implicitly {@link dataform.JDBC.SslConfiguration.verify|verify} messages.
             * @function encode
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration} message SslConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SslConfiguration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serverCertificate != null && message.hasOwnProperty("serverCertificate"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverCertificate);
                if (message.clientCertificate != null && message.hasOwnProperty("clientCertificate"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientCertificate);
                if (message.clientPrivateKey != null && message.hasOwnProperty("clientPrivateKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientPrivateKey);
                return writer;
            };

            /**
             * Encodes the specified SslConfiguration message, length delimited. Does not implicitly {@link dataform.JDBC.SslConfiguration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration} message SslConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SslConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SslConfiguration message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SslConfiguration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC.SslConfiguration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serverCertificate = reader.string();
                        break;
                    case 2:
                        message.clientCertificate = reader.string();
                        break;
                    case 3:
                        message.clientPrivateKey = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SslConfiguration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SslConfiguration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SslConfiguration message.
             * @function verify
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SslConfiguration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serverCertificate != null && message.hasOwnProperty("serverCertificate"))
                    if (!$util.isString(message.serverCertificate))
                        return "serverCertificate: string expected";
                if (message.clientCertificate != null && message.hasOwnProperty("clientCertificate"))
                    if (!$util.isString(message.clientCertificate))
                        return "clientCertificate: string expected";
                if (message.clientPrivateKey != null && message.hasOwnProperty("clientPrivateKey"))
                    if (!$util.isString(message.clientPrivateKey))
                        return "clientPrivateKey: string expected";
                return null;
            };

            /**
             * Creates a SslConfiguration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             */
            SslConfiguration.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.JDBC.SslConfiguration)
                    return object;
                let message = new $root.dataform.JDBC.SslConfiguration();
                if (object.serverCertificate != null)
                    message.serverCertificate = String(object.serverCertificate);
                if (object.clientCertificate != null)
                    message.clientCertificate = String(object.clientCertificate);
                if (object.clientPrivateKey != null)
                    message.clientPrivateKey = String(object.clientPrivateKey);
                return message;
            };

            /**
             * Creates a plain object from a SslConfiguration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.SslConfiguration} message SslConfiguration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SslConfiguration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.serverCertificate = "";
                    object.clientCertificate = "";
                    object.clientPrivateKey = "";
                }
                if (message.serverCertificate != null && message.hasOwnProperty("serverCertificate"))
                    object.serverCertificate = message.serverCertificate;
                if (message.clientCertificate != null && message.hasOwnProperty("clientCertificate"))
                    object.clientCertificate = message.clientCertificate;
                if (message.clientPrivateKey != null && message.hasOwnProperty("clientPrivateKey"))
                    object.clientPrivateKey = message.clientPrivateKey;
                return object;
            };

            /**
             * Converts this SslConfiguration to JSON.
             * @function toJSON
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SslConfiguration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SslConfiguration;
        })();

        JDBC.SshTunnel = (function() {

            /**
             * Properties of a SshTunnel.
             * @memberof dataform.JDBC
             * @interface ISshTunnel
             * @property {string|null} [privateKey] SshTunnel privateKey
             * @property {string|null} [username] SshTunnel username
             * @property {string|null} [password] SshTunnel password
             * @property {string|null} [host] SshTunnel host
             * @property {number|null} [port] SshTunnel port
             */

            /**
             * Constructs a new SshTunnel.
             * @memberof dataform.JDBC
             * @classdesc Represents a SshTunnel.
             * @implements ISshTunnel
             * @constructor
             * @param {dataform.JDBC.ISshTunnel=} [properties] Properties to set
             */
            function SshTunnel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SshTunnel privateKey.
             * @member {string} privateKey
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.privateKey = "";

            /**
             * SshTunnel username.
             * @member {string} username
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.username = "";

            /**
             * SshTunnel password.
             * @member {string} password
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.password = "";

            /**
             * SshTunnel host.
             * @member {string} host
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.host = "";

            /**
             * SshTunnel port.
             * @member {number} port
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.port = 0;

            /**
             * Creates a new SshTunnel instance using the specified properties.
             * @function create
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel=} [properties] Properties to set
             * @returns {dataform.JDBC.SshTunnel} SshTunnel instance
             */
            SshTunnel.create = function create(properties) {
                return new SshTunnel(properties);
            };

            /**
             * Encodes the specified SshTunnel message. Does not implicitly {@link dataform.JDBC.SshTunnel.verify|verify} messages.
             * @function encode
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel} message SshTunnel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SshTunnel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.privateKey);
                if (message.username != null && message.hasOwnProperty("username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && message.hasOwnProperty("password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.port);
                return writer;
            };

            /**
             * Encodes the specified SshTunnel message, length delimited. Does not implicitly {@link dataform.JDBC.SshTunnel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel} message SshTunnel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SshTunnel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SshTunnel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SshTunnel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC.SshTunnel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.privateKey = reader.string();
                        break;
                    case 2:
                        message.username = reader.string();
                        break;
                    case 3:
                        message.password = reader.string();
                        break;
                    case 4:
                        message.host = reader.string();
                        break;
                    case 5:
                        message.port = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SshTunnel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SshTunnel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SshTunnel message.
             * @function verify
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SshTunnel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    if (!$util.isString(message.privateKey))
                        return "privateKey: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                return null;
            };

            /**
             * Creates a SshTunnel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             */
            SshTunnel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.JDBC.SshTunnel)
                    return object;
                let message = new $root.dataform.JDBC.SshTunnel();
                if (object.privateKey != null)
                    message.privateKey = String(object.privateKey);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                return message;
            };

            /**
             * Creates a plain object from a SshTunnel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.SshTunnel} message SshTunnel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SshTunnel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.privateKey = "";
                    object.username = "";
                    object.password = "";
                    object.host = "";
                    object.port = 0;
                }
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    object.privateKey = message.privateKey;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };

            /**
             * Converts this SshTunnel to JSON.
             * @function toJSON
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SshTunnel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SshTunnel;
        })();

        return JDBC;
    })();

    dataform.Snowflake = (function() {

        /**
         * Properties of a Snowflake.
         * @memberof dataform
         * @interface ISnowflake
         * @property {string|null} [accountId] Snowflake accountId
         * @property {string|null} [username] Snowflake username
         * @property {string|null} [password] Snowflake password
         * @property {string|null} [role] Snowflake role
         * @property {string|null} [databaseName] Snowflake databaseName
         * @property {string|null} [warehouse] Snowflake warehouse
         */

        /**
         * Constructs a new Snowflake.
         * @memberof dataform
         * @classdesc Represents a Snowflake.
         * @implements ISnowflake
         * @constructor
         * @param {dataform.ISnowflake=} [properties] Properties to set
         */
        function Snowflake(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Snowflake accountId.
         * @member {string} accountId
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.accountId = "";

        /**
         * Snowflake username.
         * @member {string} username
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.username = "";

        /**
         * Snowflake password.
         * @member {string} password
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.password = "";

        /**
         * Snowflake role.
         * @member {string} role
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.role = "";

        /**
         * Snowflake databaseName.
         * @member {string} databaseName
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.databaseName = "";

        /**
         * Snowflake warehouse.
         * @member {string} warehouse
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.warehouse = "";

        /**
         * Creates a new Snowflake instance using the specified properties.
         * @function create
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake=} [properties] Properties to set
         * @returns {dataform.Snowflake} Snowflake instance
         */
        Snowflake.create = function create(properties) {
            return new Snowflake(properties);
        };

        /**
         * Encodes the specified Snowflake message. Does not implicitly {@link dataform.Snowflake.verify|verify} messages.
         * @function encode
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake} message Snowflake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snowflake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.accountId);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            if (message.role != null && message.hasOwnProperty("role"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.role);
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.databaseName);
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.warehouse);
            return writer;
        };

        /**
         * Encodes the specified Snowflake message, length delimited. Does not implicitly {@link dataform.Snowflake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake} message Snowflake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snowflake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Snowflake message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Snowflake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Snowflake} Snowflake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snowflake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Snowflake();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.accountId = reader.string();
                    break;
                case 3:
                    message.username = reader.string();
                    break;
                case 4:
                    message.password = reader.string();
                    break;
                case 5:
                    message.role = reader.string();
                    break;
                case 6:
                    message.databaseName = reader.string();
                    break;
                case 7:
                    message.warehouse = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Snowflake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Snowflake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Snowflake} Snowflake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snowflake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Snowflake message.
         * @function verify
         * @memberof dataform.Snowflake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Snowflake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!$util.isString(message.accountId))
                    return "accountId: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isString(message.role))
                    return "role: string expected";
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                if (!$util.isString(message.databaseName))
                    return "databaseName: string expected";
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                if (!$util.isString(message.warehouse))
                    return "warehouse: string expected";
            return null;
        };

        /**
         * Creates a Snowflake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Snowflake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Snowflake} Snowflake
         */
        Snowflake.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Snowflake)
                return object;
            let message = new $root.dataform.Snowflake();
            if (object.accountId != null)
                message.accountId = String(object.accountId);
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.role != null)
                message.role = String(object.role);
            if (object.databaseName != null)
                message.databaseName = String(object.databaseName);
            if (object.warehouse != null)
                message.warehouse = String(object.warehouse);
            return message;
        };

        /**
         * Creates a plain object from a Snowflake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.Snowflake} message Snowflake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Snowflake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.accountId = "";
                object.username = "";
                object.password = "";
                object.role = "";
                object.databaseName = "";
                object.warehouse = "";
            }
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                object.accountId = message.accountId;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                object.databaseName = message.databaseName;
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                object.warehouse = message.warehouse;
            return object;
        };

        /**
         * Converts this Snowflake to JSON.
         * @function toJSON
         * @memberof dataform.Snowflake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Snowflake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Snowflake;
    })();

    dataform.BigQuery = (function() {

        /**
         * Properties of a BigQuery.
         * @memberof dataform
         * @interface IBigQuery
         * @property {string|null} [projectId] BigQuery projectId
         * @property {string|null} [credentials] BigQuery credentials
         * @property {string|null} [location] BigQuery location
         */

        /**
         * Constructs a new BigQuery.
         * @memberof dataform
         * @classdesc Represents a BigQuery.
         * @implements IBigQuery
         * @constructor
         * @param {dataform.IBigQuery=} [properties] Properties to set
         */
        function BigQuery(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigQuery projectId.
         * @member {string} projectId
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.projectId = "";

        /**
         * BigQuery credentials.
         * @member {string} credentials
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.credentials = "";

        /**
         * BigQuery location.
         * @member {string} location
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.location = "";

        /**
         * Creates a new BigQuery instance using the specified properties.
         * @function create
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery=} [properties] Properties to set
         * @returns {dataform.BigQuery} BigQuery instance
         */
        BigQuery.create = function create(properties) {
            return new BigQuery(properties);
        };

        /**
         * Encodes the specified BigQuery message. Does not implicitly {@link dataform.BigQuery.verify|verify} messages.
         * @function encode
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery} message BigQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectId);
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.credentials);
            if (message.location != null && message.hasOwnProperty("location"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.location);
            return writer;
        };

        /**
         * Encodes the specified BigQuery message, length delimited. Does not implicitly {@link dataform.BigQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery} message BigQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BigQuery message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.BigQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.BigQuery} BigQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.BigQuery();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.projectId = reader.string();
                    break;
                case 3:
                    message.credentials = reader.string();
                    break;
                case 4:
                    message.location = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BigQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.BigQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.BigQuery} BigQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BigQuery message.
         * @function verify
         * @memberof dataform.BigQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BigQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                if (!$util.isString(message.projectId))
                    return "projectId: string expected";
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                if (!$util.isString(message.credentials))
                    return "credentials: string expected";
            if (message.location != null && message.hasOwnProperty("location"))
                if (!$util.isString(message.location))
                    return "location: string expected";
            return null;
        };

        /**
         * Creates a BigQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.BigQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.BigQuery} BigQuery
         */
        BigQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.BigQuery)
                return object;
            let message = new $root.dataform.BigQuery();
            if (object.projectId != null)
                message.projectId = String(object.projectId);
            if (object.credentials != null)
                message.credentials = String(object.credentials);
            if (object.location != null)
                message.location = String(object.location);
            return message;
        };

        /**
         * Creates a plain object from a BigQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.BigQuery} message BigQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BigQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.projectId = "";
                object.credentials = "";
                object.location = "";
            }
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                object.projectId = message.projectId;
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                object.credentials = message.credentials;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = message.location;
            return object;
        };

        /**
         * Converts this BigQuery to JSON.
         * @function toJSON
         * @memberof dataform.BigQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BigQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BigQuery;
    })();

    dataform.SQLDataWarehouse = (function() {

        /**
         * Properties of a SQLDataWarehouse.
         * @memberof dataform
         * @interface ISQLDataWarehouse
         * @property {string|null} [server] SQLDataWarehouse server
         * @property {number|null} [port] SQLDataWarehouse port
         * @property {string|null} [username] SQLDataWarehouse username
         * @property {string|null} [password] SQLDataWarehouse password
         * @property {string|null} [database] SQLDataWarehouse database
         */

        /**
         * Constructs a new SQLDataWarehouse.
         * @memberof dataform
         * @classdesc Represents a SQLDataWarehouse.
         * @implements ISQLDataWarehouse
         * @constructor
         * @param {dataform.ISQLDataWarehouse=} [properties] Properties to set
         */
        function SQLDataWarehouse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SQLDataWarehouse server.
         * @member {string} server
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.server = "";

        /**
         * SQLDataWarehouse port.
         * @member {number} port
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.port = 0;

        /**
         * SQLDataWarehouse username.
         * @member {string} username
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.username = "";

        /**
         * SQLDataWarehouse password.
         * @member {string} password
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.password = "";

        /**
         * SQLDataWarehouse database.
         * @member {string} database
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.database = "";

        /**
         * Creates a new SQLDataWarehouse instance using the specified properties.
         * @function create
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse=} [properties] Properties to set
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse instance
         */
        SQLDataWarehouse.create = function create(properties) {
            return new SQLDataWarehouse(properties);
        };

        /**
         * Encodes the specified SQLDataWarehouse message. Does not implicitly {@link dataform.SQLDataWarehouse.verify|verify} messages.
         * @function encode
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse} message SQLDataWarehouse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.server != null && message.hasOwnProperty("server"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.server);
            if (message.port != null && message.hasOwnProperty("port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            if (message.database != null && message.hasOwnProperty("database"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.database);
            return writer;
        };

        /**
         * Encodes the specified SQLDataWarehouse message, length delimited. Does not implicitly {@link dataform.SQLDataWarehouse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse} message SQLDataWarehouse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SQLDataWarehouse message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SQLDataWarehouse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.server = reader.string();
                    break;
                case 2:
                    message.port = reader.int32();
                    break;
                case 3:
                    message.username = reader.string();
                    break;
                case 4:
                    message.password = reader.string();
                    break;
                case 5:
                    message.database = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SQLDataWarehouse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SQLDataWarehouse message.
         * @function verify
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SQLDataWarehouse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.server != null && message.hasOwnProperty("server"))
                if (!$util.isString(message.server))
                    return "server: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            return null;
        };

        /**
         * Creates a SQLDataWarehouse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         */
        SQLDataWarehouse.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SQLDataWarehouse)
                return object;
            let message = new $root.dataform.SQLDataWarehouse();
            if (object.server != null)
                message.server = String(object.server);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.database != null)
                message.database = String(object.database);
            return message;
        };

        /**
         * Creates a plain object from a SQLDataWarehouse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.SQLDataWarehouse} message SQLDataWarehouse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SQLDataWarehouse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.server = "";
                object.port = 0;
                object.username = "";
                object.password = "";
                object.database = "";
            }
            if (message.server != null && message.hasOwnProperty("server"))
                object.server = message.server;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            return object;
        };

        /**
         * Converts this SQLDataWarehouse to JSON.
         * @function toJSON
         * @memberof dataform.SQLDataWarehouse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SQLDataWarehouse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SQLDataWarehouse;
    })();

    dataform.Presto = (function() {

        /**
         * Properties of a Presto.
         * @memberof dataform
         * @interface IPresto
         * @property {string|null} [host] Presto host
         * @property {number|null} [port] Presto port
         * @property {string|null} [user] Presto user
         * @property {string|null} [catalog] Presto catalog
         * @property {string|null} [schema] Presto schema
         */

        /**
         * Constructs a new Presto.
         * @memberof dataform
         * @classdesc Represents a Presto.
         * @implements IPresto
         * @constructor
         * @param {dataform.IPresto=} [properties] Properties to set
         */
        function Presto(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Presto host.
         * @member {string} host
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.host = "";

        /**
         * Presto port.
         * @member {number} port
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.port = 0;

        /**
         * Presto user.
         * @member {string} user
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.user = "";

        /**
         * Presto catalog.
         * @member {string} catalog
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.catalog = "";

        /**
         * Presto schema.
         * @member {string} schema
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.schema = "";

        /**
         * Creates a new Presto instance using the specified properties.
         * @function create
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto=} [properties] Properties to set
         * @returns {dataform.Presto} Presto instance
         */
        Presto.create = function create(properties) {
            return new Presto(properties);
        };

        /**
         * Encodes the specified Presto message. Does not implicitly {@link dataform.Presto.verify|verify} messages.
         * @function encode
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto} message Presto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && message.hasOwnProperty("host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && message.hasOwnProperty("port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            if (message.user != null && message.hasOwnProperty("user"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.user);
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.catalog);
            if (message.schema != null && message.hasOwnProperty("schema"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.schema);
            return writer;
        };

        /**
         * Encodes the specified Presto message, length delimited. Does not implicitly {@link dataform.Presto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto} message Presto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Presto message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Presto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Presto} Presto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Presto();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.port = reader.int32();
                    break;
                case 3:
                    message.user = reader.string();
                    break;
                case 4:
                    message.catalog = reader.string();
                    break;
                case 5:
                    message.schema = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Presto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Presto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Presto} Presto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Presto message.
         * @function verify
         * @memberof dataform.Presto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Presto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.user != null && message.hasOwnProperty("user"))
                if (!$util.isString(message.user))
                    return "user: string expected";
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                if (!$util.isString(message.catalog))
                    return "catalog: string expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isString(message.schema))
                    return "schema: string expected";
            return null;
        };

        /**
         * Creates a Presto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Presto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Presto} Presto
         */
        Presto.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Presto)
                return object;
            let message = new $root.dataform.Presto();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.user != null)
                message.user = String(object.user);
            if (object.catalog != null)
                message.catalog = String(object.catalog);
            if (object.schema != null)
                message.schema = String(object.schema);
            return message;
        };

        /**
         * Creates a plain object from a Presto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Presto
         * @static
         * @param {dataform.Presto} message Presto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Presto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.user = "";
                object.catalog = "";
                object.schema = "";
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                object.catalog = message.catalog;
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            return object;
        };

        /**
         * Converts this Presto to JSON.
         * @function toJSON
         * @memberof dataform.Presto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Presto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Presto;
    })();

    dataform.schedules = (function() {

        /**
         * Namespace schedules.
         * @memberof dataform
         * @namespace
         */
        const schedules = {};

        /**
         * NotificationEventType enum.
         * @name dataform.schedules.NotificationEventType
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} SUCCESS=1 SUCCESS value
         * @property {number} FAILURE=2 FAILURE value
         */
        schedules.NotificationEventType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "SUCCESS"] = 1;
            values[valuesById[2] = "FAILURE"] = 2;
            return values;
        })();

        schedules.EmailNotificationChannel = (function() {

            /**
             * Properties of an EmailNotificationChannel.
             * @memberof dataform.schedules
             * @interface IEmailNotificationChannel
             * @property {Array.<string>|null} [to] EmailNotificationChannel to
             */

            /**
             * Constructs a new EmailNotificationChannel.
             * @memberof dataform.schedules
             * @classdesc Represents an EmailNotificationChannel.
             * @implements IEmailNotificationChannel
             * @constructor
             * @param {dataform.schedules.IEmailNotificationChannel=} [properties] Properties to set
             */
            function EmailNotificationChannel(properties) {
                this.to = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmailNotificationChannel to.
             * @member {Array.<string>} to
             * @memberof dataform.schedules.EmailNotificationChannel
             * @instance
             */
            EmailNotificationChannel.prototype.to = $util.emptyArray;

            /**
             * Creates a new EmailNotificationChannel instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {dataform.schedules.IEmailNotificationChannel=} [properties] Properties to set
             * @returns {dataform.schedules.EmailNotificationChannel} EmailNotificationChannel instance
             */
            EmailNotificationChannel.create = function create(properties) {
                return new EmailNotificationChannel(properties);
            };

            /**
             * Encodes the specified EmailNotificationChannel message. Does not implicitly {@link dataform.schedules.EmailNotificationChannel.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {dataform.schedules.IEmailNotificationChannel} message EmailNotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailNotificationChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.to != null && message.to.length)
                    for (let i = 0; i < message.to.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.to[i]);
                return writer;
            };

            /**
             * Encodes the specified EmailNotificationChannel message, length delimited. Does not implicitly {@link dataform.schedules.EmailNotificationChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {dataform.schedules.IEmailNotificationChannel} message EmailNotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmailNotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmailNotificationChannel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.EmailNotificationChannel} EmailNotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailNotificationChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.EmailNotificationChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.to && message.to.length))
                            message.to = [];
                        message.to.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EmailNotificationChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.EmailNotificationChannel} EmailNotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmailNotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmailNotificationChannel message.
             * @function verify
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmailNotificationChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.to != null && message.hasOwnProperty("to")) {
                    if (!Array.isArray(message.to))
                        return "to: array expected";
                    for (let i = 0; i < message.to.length; ++i)
                        if (!$util.isString(message.to[i]))
                            return "to: string[] expected";
                }
                return null;
            };

            /**
             * Creates an EmailNotificationChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.EmailNotificationChannel} EmailNotificationChannel
             */
            EmailNotificationChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.EmailNotificationChannel)
                    return object;
                let message = new $root.dataform.schedules.EmailNotificationChannel();
                if (object.to) {
                    if (!Array.isArray(object.to))
                        throw TypeError(".dataform.schedules.EmailNotificationChannel.to: array expected");
                    message.to = [];
                    for (let i = 0; i < object.to.length; ++i)
                        message.to[i] = String(object.to[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an EmailNotificationChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.EmailNotificationChannel
             * @static
             * @param {dataform.schedules.EmailNotificationChannel} message EmailNotificationChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EmailNotificationChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.to = [];
                if (message.to && message.to.length) {
                    object.to = [];
                    for (let j = 0; j < message.to.length; ++j)
                        object.to[j] = message.to[j];
                }
                return object;
            };

            /**
             * Converts this EmailNotificationChannel to JSON.
             * @function toJSON
             * @memberof dataform.schedules.EmailNotificationChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EmailNotificationChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EmailNotificationChannel;
        })();

        schedules.SlackNotificationChannel = (function() {

            /**
             * Properties of a SlackNotificationChannel.
             * @memberof dataform.schedules
             * @interface ISlackNotificationChannel
             * @property {string|null} [webhookUrl] SlackNotificationChannel webhookUrl
             */

            /**
             * Constructs a new SlackNotificationChannel.
             * @memberof dataform.schedules
             * @classdesc Represents a SlackNotificationChannel.
             * @implements ISlackNotificationChannel
             * @constructor
             * @param {dataform.schedules.ISlackNotificationChannel=} [properties] Properties to set
             */
            function SlackNotificationChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SlackNotificationChannel webhookUrl.
             * @member {string} webhookUrl
             * @memberof dataform.schedules.SlackNotificationChannel
             * @instance
             */
            SlackNotificationChannel.prototype.webhookUrl = "";

            /**
             * Creates a new SlackNotificationChannel instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {dataform.schedules.ISlackNotificationChannel=} [properties] Properties to set
             * @returns {dataform.schedules.SlackNotificationChannel} SlackNotificationChannel instance
             */
            SlackNotificationChannel.create = function create(properties) {
                return new SlackNotificationChannel(properties);
            };

            /**
             * Encodes the specified SlackNotificationChannel message. Does not implicitly {@link dataform.schedules.SlackNotificationChannel.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {dataform.schedules.ISlackNotificationChannel} message SlackNotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlackNotificationChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.webhookUrl);
                return writer;
            };

            /**
             * Encodes the specified SlackNotificationChannel message, length delimited. Does not implicitly {@link dataform.schedules.SlackNotificationChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {dataform.schedules.ISlackNotificationChannel} message SlackNotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlackNotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SlackNotificationChannel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.SlackNotificationChannel} SlackNotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlackNotificationChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.SlackNotificationChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.webhookUrl = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SlackNotificationChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.SlackNotificationChannel} SlackNotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlackNotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SlackNotificationChannel message.
             * @function verify
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SlackNotificationChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                    if (!$util.isString(message.webhookUrl))
                        return "webhookUrl: string expected";
                return null;
            };

            /**
             * Creates a SlackNotificationChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.SlackNotificationChannel} SlackNotificationChannel
             */
            SlackNotificationChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.SlackNotificationChannel)
                    return object;
                let message = new $root.dataform.schedules.SlackNotificationChannel();
                if (object.webhookUrl != null)
                    message.webhookUrl = String(object.webhookUrl);
                return message;
            };

            /**
             * Creates a plain object from a SlackNotificationChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.SlackNotificationChannel
             * @static
             * @param {dataform.schedules.SlackNotificationChannel} message SlackNotificationChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SlackNotificationChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.webhookUrl = "";
                if (message.webhookUrl != null && message.hasOwnProperty("webhookUrl"))
                    object.webhookUrl = message.webhookUrl;
                return object;
            };

            /**
             * Converts this SlackNotificationChannel to JSON.
             * @function toJSON
             * @memberof dataform.schedules.SlackNotificationChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SlackNotificationChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SlackNotificationChannel;
        })();

        schedules.NotificationChannel = (function() {

            /**
             * Properties of a NotificationChannel.
             * @memberof dataform.schedules
             * @interface INotificationChannel
             * @property {string|null} [name] NotificationChannel name
             * @property {dataform.schedules.IEmailNotificationChannel|null} [email] NotificationChannel email
             * @property {dataform.schedules.ISlackNotificationChannel|null} [slack] NotificationChannel slack
             */

            /**
             * Constructs a new NotificationChannel.
             * @memberof dataform.schedules
             * @classdesc Represents a NotificationChannel.
             * @implements INotificationChannel
             * @constructor
             * @param {dataform.schedules.INotificationChannel=} [properties] Properties to set
             */
            function NotificationChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotificationChannel name.
             * @member {string} name
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.name = "";

            /**
             * NotificationChannel email.
             * @member {dataform.schedules.IEmailNotificationChannel|null|undefined} email
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.email = null;

            /**
             * NotificationChannel slack.
             * @member {dataform.schedules.ISlackNotificationChannel|null|undefined} slack
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             */
            NotificationChannel.prototype.slack = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NotificationChannel channel.
             * @member {"email"|"slack"|undefined} channel
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             */
            Object.defineProperty(NotificationChannel.prototype, "channel", {
                get: $util.oneOfGetter($oneOfFields = ["email", "slack"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NotificationChannel instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {dataform.schedules.INotificationChannel=} [properties] Properties to set
             * @returns {dataform.schedules.NotificationChannel} NotificationChannel instance
             */
            NotificationChannel.create = function create(properties) {
                return new NotificationChannel(properties);
            };

            /**
             * Encodes the specified NotificationChannel message. Does not implicitly {@link dataform.schedules.NotificationChannel.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {dataform.schedules.INotificationChannel} message NotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.email != null && message.hasOwnProperty("email"))
                    $root.dataform.schedules.EmailNotificationChannel.encode(message.email, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.slack != null && message.hasOwnProperty("slack"))
                    $root.dataform.schedules.SlackNotificationChannel.encode(message.slack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NotificationChannel message, length delimited. Does not implicitly {@link dataform.schedules.NotificationChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {dataform.schedules.INotificationChannel} message NotificationChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotificationChannel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.NotificationChannel} NotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.NotificationChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.email = $root.dataform.schedules.EmailNotificationChannel.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.slack = $root.dataform.schedules.SlackNotificationChannel.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotificationChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.NotificationChannel} NotificationChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotificationChannel message.
             * @function verify
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotificationChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties.channel = 1;
                    {
                        let error = $root.dataform.schedules.EmailNotificationChannel.verify(message.email);
                        if (error)
                            return "email." + error;
                    }
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    if (properties.channel === 1)
                        return "channel: multiple values";
                    properties.channel = 1;
                    {
                        let error = $root.dataform.schedules.SlackNotificationChannel.verify(message.slack);
                        if (error)
                            return "slack." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NotificationChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.NotificationChannel} NotificationChannel
             */
            NotificationChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.NotificationChannel)
                    return object;
                let message = new $root.dataform.schedules.NotificationChannel();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.email != null) {
                    if (typeof object.email !== "object")
                        throw TypeError(".dataform.schedules.NotificationChannel.email: object expected");
                    message.email = $root.dataform.schedules.EmailNotificationChannel.fromObject(object.email);
                }
                if (object.slack != null) {
                    if (typeof object.slack !== "object")
                        throw TypeError(".dataform.schedules.NotificationChannel.slack: object expected");
                    message.slack = $root.dataform.schedules.SlackNotificationChannel.fromObject(object.slack);
                }
                return message;
            };

            /**
             * Creates a plain object from a NotificationChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.NotificationChannel
             * @static
             * @param {dataform.schedules.NotificationChannel} message NotificationChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotificationChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.email != null && message.hasOwnProperty("email")) {
                    object.email = $root.dataform.schedules.EmailNotificationChannel.toObject(message.email, options);
                    if (options.oneofs)
                        object.channel = "email";
                }
                if (message.slack != null && message.hasOwnProperty("slack")) {
                    object.slack = $root.dataform.schedules.SlackNotificationChannel.toObject(message.slack, options);
                    if (options.oneofs)
                        object.channel = "slack";
                }
                return object;
            };

            /**
             * Converts this NotificationChannel to JSON.
             * @function toJSON
             * @memberof dataform.schedules.NotificationChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotificationChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NotificationChannel;
        })();

        schedules.ScheduleNotification = (function() {

            /**
             * Properties of a ScheduleNotification.
             * @memberof dataform.schedules
             * @interface IScheduleNotification
             * @property {Array.<string>|null} [environments] ScheduleNotification environments
             * @property {Array.<string>|null} [events] ScheduleNotification events
             * @property {Array.<string>|null} [channels] ScheduleNotification channels
             */

            /**
             * Constructs a new ScheduleNotification.
             * @memberof dataform.schedules
             * @classdesc Represents a ScheduleNotification.
             * @implements IScheduleNotification
             * @constructor
             * @param {dataform.schedules.IScheduleNotification=} [properties] Properties to set
             */
            function ScheduleNotification(properties) {
                this.environments = [];
                this.events = [];
                this.channels = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScheduleNotification environments.
             * @member {Array.<string>} environments
             * @memberof dataform.schedules.ScheduleNotification
             * @instance
             */
            ScheduleNotification.prototype.environments = $util.emptyArray;

            /**
             * ScheduleNotification events.
             * @member {Array.<string>} events
             * @memberof dataform.schedules.ScheduleNotification
             * @instance
             */
            ScheduleNotification.prototype.events = $util.emptyArray;

            /**
             * ScheduleNotification channels.
             * @member {Array.<string>} channels
             * @memberof dataform.schedules.ScheduleNotification
             * @instance
             */
            ScheduleNotification.prototype.channels = $util.emptyArray;

            /**
             * Creates a new ScheduleNotification instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {dataform.schedules.IScheduleNotification=} [properties] Properties to set
             * @returns {dataform.schedules.ScheduleNotification} ScheduleNotification instance
             */
            ScheduleNotification.create = function create(properties) {
                return new ScheduleNotification(properties);
            };

            /**
             * Encodes the specified ScheduleNotification message. Does not implicitly {@link dataform.schedules.ScheduleNotification.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {dataform.schedules.IScheduleNotification} message ScheduleNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduleNotification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.environments != null && message.environments.length)
                    for (let i = 0; i < message.environments.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.environments[i]);
                if (message.events != null && message.events.length)
                    for (let i = 0; i < message.events.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.events[i]);
                if (message.channels != null && message.channels.length)
                    for (let i = 0; i < message.channels.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.channels[i]);
                return writer;
            };

            /**
             * Encodes the specified ScheduleNotification message, length delimited. Does not implicitly {@link dataform.schedules.ScheduleNotification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {dataform.schedules.IScheduleNotification} message ScheduleNotification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduleNotification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScheduleNotification message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.ScheduleNotification} ScheduleNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduleNotification.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.ScheduleNotification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.environments && message.environments.length))
                            message.environments = [];
                        message.environments.push(reader.string());
                        break;
                    case 2:
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push(reader.string());
                        break;
                    case 3:
                        if (!(message.channels && message.channels.length))
                            message.channels = [];
                        message.channels.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScheduleNotification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.ScheduleNotification} ScheduleNotification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduleNotification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScheduleNotification message.
             * @function verify
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScheduleNotification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.environments != null && message.hasOwnProperty("environments")) {
                    if (!Array.isArray(message.environments))
                        return "environments: array expected";
                    for (let i = 0; i < message.environments.length; ++i)
                        if (!$util.isString(message.environments[i]))
                            return "environments: string[] expected";
                }
                if (message.events != null && message.hasOwnProperty("events")) {
                    if (!Array.isArray(message.events))
                        return "events: array expected";
                    for (let i = 0; i < message.events.length; ++i)
                        if (!$util.isString(message.events[i]))
                            return "events: string[] expected";
                }
                if (message.channels != null && message.hasOwnProperty("channels")) {
                    if (!Array.isArray(message.channels))
                        return "channels: array expected";
                    for (let i = 0; i < message.channels.length; ++i)
                        if (!$util.isString(message.channels[i]))
                            return "channels: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ScheduleNotification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.ScheduleNotification} ScheduleNotification
             */
            ScheduleNotification.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.ScheduleNotification)
                    return object;
                let message = new $root.dataform.schedules.ScheduleNotification();
                if (object.environments) {
                    if (!Array.isArray(object.environments))
                        throw TypeError(".dataform.schedules.ScheduleNotification.environments: array expected");
                    message.environments = [];
                    for (let i = 0; i < object.environments.length; ++i)
                        message.environments[i] = String(object.environments[i]);
                }
                if (object.events) {
                    if (!Array.isArray(object.events))
                        throw TypeError(".dataform.schedules.ScheduleNotification.events: array expected");
                    message.events = [];
                    for (let i = 0; i < object.events.length; ++i)
                        message.events[i] = String(object.events[i]);
                }
                if (object.channels) {
                    if (!Array.isArray(object.channels))
                        throw TypeError(".dataform.schedules.ScheduleNotification.channels: array expected");
                    message.channels = [];
                    for (let i = 0; i < object.channels.length; ++i)
                        message.channels[i] = String(object.channels[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ScheduleNotification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.ScheduleNotification
             * @static
             * @param {dataform.schedules.ScheduleNotification} message ScheduleNotification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScheduleNotification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.environments = [];
                    object.events = [];
                    object.channels = [];
                }
                if (message.environments && message.environments.length) {
                    object.environments = [];
                    for (let j = 0; j < message.environments.length; ++j)
                        object.environments[j] = message.environments[j];
                }
                if (message.events && message.events.length) {
                    object.events = [];
                    for (let j = 0; j < message.events.length; ++j)
                        object.events[j] = message.events[j];
                }
                if (message.channels && message.channels.length) {
                    object.channels = [];
                    for (let j = 0; j < message.channels.length; ++j)
                        object.channels[j] = message.channels[j];
                }
                return object;
            };

            /**
             * Converts this ScheduleNotification to JSON.
             * @function toJSON
             * @memberof dataform.schedules.ScheduleNotification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScheduleNotification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScheduleNotification;
        })();

        schedules.NotificationSettings = (function() {

            /**
             * Properties of a NotificationSettings.
             * @memberof dataform.schedules
             * @interface INotificationSettings
             * @property {Array.<string>|null} [emails] NotificationSettings emails
             * @property {boolean|null} [onSuccess] NotificationSettings onSuccess
             * @property {boolean|null} [onFailure] NotificationSettings onFailure
             */

            /**
             * Constructs a new NotificationSettings.
             * @memberof dataform.schedules
             * @classdesc Represents a NotificationSettings.
             * @implements INotificationSettings
             * @constructor
             * @param {dataform.schedules.INotificationSettings=} [properties] Properties to set
             */
            function NotificationSettings(properties) {
                this.emails = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotificationSettings emails.
             * @member {Array.<string>} emails
             * @memberof dataform.schedules.NotificationSettings
             * @instance
             */
            NotificationSettings.prototype.emails = $util.emptyArray;

            /**
             * NotificationSettings onSuccess.
             * @member {boolean} onSuccess
             * @memberof dataform.schedules.NotificationSettings
             * @instance
             */
            NotificationSettings.prototype.onSuccess = false;

            /**
             * NotificationSettings onFailure.
             * @member {boolean} onFailure
             * @memberof dataform.schedules.NotificationSettings
             * @instance
             */
            NotificationSettings.prototype.onFailure = false;

            /**
             * Creates a new NotificationSettings instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {dataform.schedules.INotificationSettings=} [properties] Properties to set
             * @returns {dataform.schedules.NotificationSettings} NotificationSettings instance
             */
            NotificationSettings.create = function create(properties) {
                return new NotificationSettings(properties);
            };

            /**
             * Encodes the specified NotificationSettings message. Does not implicitly {@link dataform.schedules.NotificationSettings.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {dataform.schedules.INotificationSettings} message NotificationSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.emails != null && message.emails.length)
                    for (let i = 0; i < message.emails.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.emails[i]);
                if (message.onSuccess != null && message.hasOwnProperty("onSuccess"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.onSuccess);
                if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.onFailure);
                return writer;
            };

            /**
             * Encodes the specified NotificationSettings message, length delimited. Does not implicitly {@link dataform.schedules.NotificationSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {dataform.schedules.INotificationSettings} message NotificationSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotificationSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotificationSettings message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.NotificationSettings} NotificationSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.NotificationSettings();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.emails && message.emails.length))
                            message.emails = [];
                        message.emails.push(reader.string());
                        break;
                    case 2:
                        message.onSuccess = reader.bool();
                        break;
                    case 3:
                        message.onFailure = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotificationSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.NotificationSettings} NotificationSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotificationSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotificationSettings message.
             * @function verify
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotificationSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.emails != null && message.hasOwnProperty("emails")) {
                    if (!Array.isArray(message.emails))
                        return "emails: array expected";
                    for (let i = 0; i < message.emails.length; ++i)
                        if (!$util.isString(message.emails[i]))
                            return "emails: string[] expected";
                }
                if (message.onSuccess != null && message.hasOwnProperty("onSuccess"))
                    if (typeof message.onSuccess !== "boolean")
                        return "onSuccess: boolean expected";
                if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                    if (typeof message.onFailure !== "boolean")
                        return "onFailure: boolean expected";
                return null;
            };

            /**
             * Creates a NotificationSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.NotificationSettings} NotificationSettings
             */
            NotificationSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.NotificationSettings)
                    return object;
                let message = new $root.dataform.schedules.NotificationSettings();
                if (object.emails) {
                    if (!Array.isArray(object.emails))
                        throw TypeError(".dataform.schedules.NotificationSettings.emails: array expected");
                    message.emails = [];
                    for (let i = 0; i < object.emails.length; ++i)
                        message.emails[i] = String(object.emails[i]);
                }
                if (object.onSuccess != null)
                    message.onSuccess = Boolean(object.onSuccess);
                if (object.onFailure != null)
                    message.onFailure = Boolean(object.onFailure);
                return message;
            };

            /**
             * Creates a plain object from a NotificationSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.NotificationSettings
             * @static
             * @param {dataform.schedules.NotificationSettings} message NotificationSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotificationSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.emails = [];
                if (options.defaults) {
                    object.onSuccess = false;
                    object.onFailure = false;
                }
                if (message.emails && message.emails.length) {
                    object.emails = [];
                    for (let j = 0; j < message.emails.length; ++j)
                        object.emails[j] = message.emails[j];
                }
                if (message.onSuccess != null && message.hasOwnProperty("onSuccess"))
                    object.onSuccess = message.onSuccess;
                if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                    object.onFailure = message.onFailure;
                return object;
            };

            /**
             * Converts this NotificationSettings to JSON.
             * @function toJSON
             * @memberof dataform.schedules.NotificationSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotificationSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NotificationSettings;
        })();

        schedules.ScheduleOptions = (function() {

            /**
             * Properties of a ScheduleOptions.
             * @memberof dataform.schedules
             * @interface IScheduleOptions
             * @property {Array.<string>|null} [actions] ScheduleOptions actions
             * @property {Array.<string>|null} [tags] ScheduleOptions tags
             * @property {boolean|null} [includeDependencies] ScheduleOptions includeDependencies
             * @property {boolean|null} [includeDependents] ScheduleOptions includeDependents
             * @property {boolean|null} [fullRefresh] ScheduleOptions fullRefresh
             */

            /**
             * Constructs a new ScheduleOptions.
             * @memberof dataform.schedules
             * @classdesc Represents a ScheduleOptions.
             * @implements IScheduleOptions
             * @constructor
             * @param {dataform.schedules.IScheduleOptions=} [properties] Properties to set
             */
            function ScheduleOptions(properties) {
                this.actions = [];
                this.tags = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScheduleOptions actions.
             * @member {Array.<string>} actions
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.actions = $util.emptyArray;

            /**
             * ScheduleOptions tags.
             * @member {Array.<string>} tags
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.tags = $util.emptyArray;

            /**
             * ScheduleOptions includeDependencies.
             * @member {boolean} includeDependencies
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.includeDependencies = false;

            /**
             * ScheduleOptions includeDependents.
             * @member {boolean} includeDependents
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.includeDependents = false;

            /**
             * ScheduleOptions fullRefresh.
             * @member {boolean} fullRefresh
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             */
            ScheduleOptions.prototype.fullRefresh = false;

            /**
             * Creates a new ScheduleOptions instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {dataform.schedules.IScheduleOptions=} [properties] Properties to set
             * @returns {dataform.schedules.ScheduleOptions} ScheduleOptions instance
             */
            ScheduleOptions.create = function create(properties) {
                return new ScheduleOptions(properties);
            };

            /**
             * Encodes the specified ScheduleOptions message. Does not implicitly {@link dataform.schedules.ScheduleOptions.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {dataform.schedules.IScheduleOptions} message ScheduleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduleOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actions != null && message.actions.length)
                    for (let i = 0; i < message.actions.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.actions[i]);
                if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includeDependencies);
                if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.fullRefresh);
                if (message.tags != null && message.tags.length)
                    for (let i = 0; i < message.tags.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.tags[i]);
                if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.includeDependents);
                return writer;
            };

            /**
             * Encodes the specified ScheduleOptions message, length delimited. Does not implicitly {@link dataform.schedules.ScheduleOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {dataform.schedules.IScheduleOptions} message ScheduleOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScheduleOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScheduleOptions message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.ScheduleOptions} ScheduleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduleOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.ScheduleOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push(reader.string());
                        break;
                    case 4:
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    case 2:
                        message.includeDependencies = reader.bool();
                        break;
                    case 5:
                        message.includeDependents = reader.bool();
                        break;
                    case 3:
                        message.fullRefresh = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScheduleOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.ScheduleOptions} ScheduleOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScheduleOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScheduleOptions message.
             * @function verify
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScheduleOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actions != null && message.hasOwnProperty("actions")) {
                    if (!Array.isArray(message.actions))
                        return "actions: array expected";
                    for (let i = 0; i < message.actions.length; ++i)
                        if (!$util.isString(message.actions[i]))
                            return "actions: string[] expected";
                }
                if (message.tags != null && message.hasOwnProperty("tags")) {
                    if (!Array.isArray(message.tags))
                        return "tags: array expected";
                    for (let i = 0; i < message.tags.length; ++i)
                        if (!$util.isString(message.tags[i]))
                            return "tags: string[] expected";
                }
                if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                    if (typeof message.includeDependencies !== "boolean")
                        return "includeDependencies: boolean expected";
                if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                    if (typeof message.includeDependents !== "boolean")
                        return "includeDependents: boolean expected";
                if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                    if (typeof message.fullRefresh !== "boolean")
                        return "fullRefresh: boolean expected";
                return null;
            };

            /**
             * Creates a ScheduleOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.ScheduleOptions} ScheduleOptions
             */
            ScheduleOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.ScheduleOptions)
                    return object;
                let message = new $root.dataform.schedules.ScheduleOptions();
                if (object.actions) {
                    if (!Array.isArray(object.actions))
                        throw TypeError(".dataform.schedules.ScheduleOptions.actions: array expected");
                    message.actions = [];
                    for (let i = 0; i < object.actions.length; ++i)
                        message.actions[i] = String(object.actions[i]);
                }
                if (object.tags) {
                    if (!Array.isArray(object.tags))
                        throw TypeError(".dataform.schedules.ScheduleOptions.tags: array expected");
                    message.tags = [];
                    for (let i = 0; i < object.tags.length; ++i)
                        message.tags[i] = String(object.tags[i]);
                }
                if (object.includeDependencies != null)
                    message.includeDependencies = Boolean(object.includeDependencies);
                if (object.includeDependents != null)
                    message.includeDependents = Boolean(object.includeDependents);
                if (object.fullRefresh != null)
                    message.fullRefresh = Boolean(object.fullRefresh);
                return message;
            };

            /**
             * Creates a plain object from a ScheduleOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.ScheduleOptions
             * @static
             * @param {dataform.schedules.ScheduleOptions} message ScheduleOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScheduleOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.actions = [];
                    object.tags = [];
                }
                if (options.defaults) {
                    object.includeDependencies = false;
                    object.fullRefresh = false;
                    object.includeDependents = false;
                }
                if (message.actions && message.actions.length) {
                    object.actions = [];
                    for (let j = 0; j < message.actions.length; ++j)
                        object.actions[j] = message.actions[j];
                }
                if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                    object.includeDependencies = message.includeDependencies;
                if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                    object.fullRefresh = message.fullRefresh;
                if (message.tags && message.tags.length) {
                    object.tags = [];
                    for (let j = 0; j < message.tags.length; ++j)
                        object.tags[j] = message.tags[j];
                }
                if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                    object.includeDependents = message.includeDependents;
                return object;
            };

            /**
             * Converts this ScheduleOptions to JSON.
             * @function toJSON
             * @memberof dataform.schedules.ScheduleOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScheduleOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ScheduleOptions;
        })();

        schedules.Schedule = (function() {

            /**
             * Properties of a Schedule.
             * @memberof dataform.schedules
             * @interface ISchedule
             * @property {string|null} [name] Schedule name
             * @property {boolean|null} [disabled] Schedule disabled
             * @property {dataform.schedules.IScheduleOptions|null} [options] Schedule options
             * @property {string|null} [cron] Schedule cron
             * @property {dataform.schedules.INotificationSettings|null} [notification] Schedule notification
             * @property {Array.<dataform.schedules.IScheduleNotification>|null} [notifications] Schedule notifications
             */

            /**
             * Constructs a new Schedule.
             * @memberof dataform.schedules
             * @classdesc Represents a Schedule.
             * @implements ISchedule
             * @constructor
             * @param {dataform.schedules.ISchedule=} [properties] Properties to set
             */
            function Schedule(properties) {
                this.notifications = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Schedule name.
             * @member {string} name
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.name = "";

            /**
             * Schedule disabled.
             * @member {boolean} disabled
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.disabled = false;

            /**
             * Schedule options.
             * @member {dataform.schedules.IScheduleOptions|null|undefined} options
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.options = null;

            /**
             * Schedule cron.
             * @member {string} cron
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.cron = "";

            /**
             * Schedule notification.
             * @member {dataform.schedules.INotificationSettings|null|undefined} notification
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.notification = null;

            /**
             * Schedule notifications.
             * @member {Array.<dataform.schedules.IScheduleNotification>} notifications
             * @memberof dataform.schedules.Schedule
             * @instance
             */
            Schedule.prototype.notifications = $util.emptyArray;

            /**
             * Creates a new Schedule instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {dataform.schedules.ISchedule=} [properties] Properties to set
             * @returns {dataform.schedules.Schedule} Schedule instance
             */
            Schedule.create = function create(properties) {
                return new Schedule(properties);
            };

            /**
             * Encodes the specified Schedule message. Does not implicitly {@link dataform.schedules.Schedule.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {dataform.schedules.ISchedule} message Schedule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Schedule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.disabled);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.dataform.schedules.ScheduleOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.cron != null && message.hasOwnProperty("cron"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.cron);
                if (message.notification != null && message.hasOwnProperty("notification"))
                    $root.dataform.schedules.NotificationSettings.encode(message.notification, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.notifications != null && message.notifications.length)
                    for (let i = 0; i < message.notifications.length; ++i)
                        $root.dataform.schedules.ScheduleNotification.encode(message.notifications[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Schedule message, length delimited. Does not implicitly {@link dataform.schedules.Schedule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {dataform.schedules.ISchedule} message Schedule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Schedule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Schedule message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.Schedule} Schedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Schedule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.Schedule();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.disabled = reader.bool();
                        break;
                    case 3:
                        message.options = $root.dataform.schedules.ScheduleOptions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.cron = reader.string();
                        break;
                    case 5:
                        message.notification = $root.dataform.schedules.NotificationSettings.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.notifications && message.notifications.length))
                            message.notifications = [];
                        message.notifications.push($root.dataform.schedules.ScheduleNotification.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Schedule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.Schedule} Schedule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Schedule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Schedule message.
             * @function verify
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Schedule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.dataform.schedules.ScheduleOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.cron != null && message.hasOwnProperty("cron"))
                    if (!$util.isString(message.cron))
                        return "cron: string expected";
                if (message.notification != null && message.hasOwnProperty("notification")) {
                    let error = $root.dataform.schedules.NotificationSettings.verify(message.notification);
                    if (error)
                        return "notification." + error;
                }
                if (message.notifications != null && message.hasOwnProperty("notifications")) {
                    if (!Array.isArray(message.notifications))
                        return "notifications: array expected";
                    for (let i = 0; i < message.notifications.length; ++i) {
                        let error = $root.dataform.schedules.ScheduleNotification.verify(message.notifications[i]);
                        if (error)
                            return "notifications." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Schedule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.Schedule} Schedule
             */
            Schedule.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.Schedule)
                    return object;
                let message = new $root.dataform.schedules.Schedule();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".dataform.schedules.Schedule.options: object expected");
                    message.options = $root.dataform.schedules.ScheduleOptions.fromObject(object.options);
                }
                if (object.cron != null)
                    message.cron = String(object.cron);
                if (object.notification != null) {
                    if (typeof object.notification !== "object")
                        throw TypeError(".dataform.schedules.Schedule.notification: object expected");
                    message.notification = $root.dataform.schedules.NotificationSettings.fromObject(object.notification);
                }
                if (object.notifications) {
                    if (!Array.isArray(object.notifications))
                        throw TypeError(".dataform.schedules.Schedule.notifications: array expected");
                    message.notifications = [];
                    for (let i = 0; i < object.notifications.length; ++i) {
                        if (typeof object.notifications[i] !== "object")
                            throw TypeError(".dataform.schedules.Schedule.notifications: object expected");
                        message.notifications[i] = $root.dataform.schedules.ScheduleNotification.fromObject(object.notifications[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Schedule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.Schedule
             * @static
             * @param {dataform.schedules.Schedule} message Schedule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Schedule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.notifications = [];
                if (options.defaults) {
                    object.name = "";
                    object.disabled = false;
                    object.options = null;
                    object.cron = "";
                    object.notification = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.dataform.schedules.ScheduleOptions.toObject(message.options, options);
                if (message.cron != null && message.hasOwnProperty("cron"))
                    object.cron = message.cron;
                if (message.notification != null && message.hasOwnProperty("notification"))
                    object.notification = $root.dataform.schedules.NotificationSettings.toObject(message.notification, options);
                if (message.notifications && message.notifications.length) {
                    object.notifications = [];
                    for (let j = 0; j < message.notifications.length; ++j)
                        object.notifications[j] = $root.dataform.schedules.ScheduleNotification.toObject(message.notifications[j], options);
                }
                return object;
            };

            /**
             * Converts this Schedule to JSON.
             * @function toJSON
             * @memberof dataform.schedules.Schedule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Schedule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Schedule;
        })();

        schedules.SchedulesJSON = (function() {

            /**
             * Properties of a SchedulesJSON.
             * @memberof dataform.schedules
             * @interface ISchedulesJSON
             * @property {Array.<dataform.schedules.ISchedule>|null} [schedules] SchedulesJSON schedules
             * @property {Array.<dataform.schedules.INotificationChannel>|null} [notificationChannels] SchedulesJSON notificationChannels
             */

            /**
             * Constructs a new SchedulesJSON.
             * @memberof dataform.schedules
             * @classdesc Represents a SchedulesJSON.
             * @implements ISchedulesJSON
             * @constructor
             * @param {dataform.schedules.ISchedulesJSON=} [properties] Properties to set
             */
            function SchedulesJSON(properties) {
                this.schedules = [];
                this.notificationChannels = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SchedulesJSON schedules.
             * @member {Array.<dataform.schedules.ISchedule>} schedules
             * @memberof dataform.schedules.SchedulesJSON
             * @instance
             */
            SchedulesJSON.prototype.schedules = $util.emptyArray;

            /**
             * SchedulesJSON notificationChannels.
             * @member {Array.<dataform.schedules.INotificationChannel>} notificationChannels
             * @memberof dataform.schedules.SchedulesJSON
             * @instance
             */
            SchedulesJSON.prototype.notificationChannels = $util.emptyArray;

            /**
             * Creates a new SchedulesJSON instance using the specified properties.
             * @function create
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {dataform.schedules.ISchedulesJSON=} [properties] Properties to set
             * @returns {dataform.schedules.SchedulesJSON} SchedulesJSON instance
             */
            SchedulesJSON.create = function create(properties) {
                return new SchedulesJSON(properties);
            };

            /**
             * Encodes the specified SchedulesJSON message. Does not implicitly {@link dataform.schedules.SchedulesJSON.verify|verify} messages.
             * @function encode
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {dataform.schedules.ISchedulesJSON} message SchedulesJSON message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SchedulesJSON.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.schedules != null && message.schedules.length)
                    for (let i = 0; i < message.schedules.length; ++i)
                        $root.dataform.schedules.Schedule.encode(message.schedules[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.notificationChannels != null && message.notificationChannels.length)
                    for (let i = 0; i < message.notificationChannels.length; ++i)
                        $root.dataform.schedules.NotificationChannel.encode(message.notificationChannels[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SchedulesJSON message, length delimited. Does not implicitly {@link dataform.schedules.SchedulesJSON.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {dataform.schedules.ISchedulesJSON} message SchedulesJSON message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SchedulesJSON.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SchedulesJSON message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.schedules.SchedulesJSON} SchedulesJSON
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SchedulesJSON.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.schedules.SchedulesJSON();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.schedules && message.schedules.length))
                            message.schedules = [];
                        message.schedules.push($root.dataform.schedules.Schedule.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.notificationChannels && message.notificationChannels.length))
                            message.notificationChannels = [];
                        message.notificationChannels.push($root.dataform.schedules.NotificationChannel.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SchedulesJSON message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.schedules.SchedulesJSON} SchedulesJSON
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SchedulesJSON.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SchedulesJSON message.
             * @function verify
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SchedulesJSON.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.schedules != null && message.hasOwnProperty("schedules")) {
                    if (!Array.isArray(message.schedules))
                        return "schedules: array expected";
                    for (let i = 0; i < message.schedules.length; ++i) {
                        let error = $root.dataform.schedules.Schedule.verify(message.schedules[i]);
                        if (error)
                            return "schedules." + error;
                    }
                }
                if (message.notificationChannels != null && message.hasOwnProperty("notificationChannels")) {
                    if (!Array.isArray(message.notificationChannels))
                        return "notificationChannels: array expected";
                    for (let i = 0; i < message.notificationChannels.length; ++i) {
                        let error = $root.dataform.schedules.NotificationChannel.verify(message.notificationChannels[i]);
                        if (error)
                            return "notificationChannels." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SchedulesJSON message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.schedules.SchedulesJSON} SchedulesJSON
             */
            SchedulesJSON.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.schedules.SchedulesJSON)
                    return object;
                let message = new $root.dataform.schedules.SchedulesJSON();
                if (object.schedules) {
                    if (!Array.isArray(object.schedules))
                        throw TypeError(".dataform.schedules.SchedulesJSON.schedules: array expected");
                    message.schedules = [];
                    for (let i = 0; i < object.schedules.length; ++i) {
                        if (typeof object.schedules[i] !== "object")
                            throw TypeError(".dataform.schedules.SchedulesJSON.schedules: object expected");
                        message.schedules[i] = $root.dataform.schedules.Schedule.fromObject(object.schedules[i]);
                    }
                }
                if (object.notificationChannels) {
                    if (!Array.isArray(object.notificationChannels))
                        throw TypeError(".dataform.schedules.SchedulesJSON.notificationChannels: array expected");
                    message.notificationChannels = [];
                    for (let i = 0; i < object.notificationChannels.length; ++i) {
                        if (typeof object.notificationChannels[i] !== "object")
                            throw TypeError(".dataform.schedules.SchedulesJSON.notificationChannels: object expected");
                        message.notificationChannels[i] = $root.dataform.schedules.NotificationChannel.fromObject(object.notificationChannels[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SchedulesJSON message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.schedules.SchedulesJSON
             * @static
             * @param {dataform.schedules.SchedulesJSON} message SchedulesJSON
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SchedulesJSON.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.schedules = [];
                    object.notificationChannels = [];
                }
                if (message.schedules && message.schedules.length) {
                    object.schedules = [];
                    for (let j = 0; j < message.schedules.length; ++j)
                        object.schedules[j] = $root.dataform.schedules.Schedule.toObject(message.schedules[j], options);
                }
                if (message.notificationChannels && message.notificationChannels.length) {
                    object.notificationChannels = [];
                    for (let j = 0; j < message.notificationChannels.length; ++j)
                        object.notificationChannels[j] = $root.dataform.schedules.NotificationChannel.toObject(message.notificationChannels[j], options);
                }
                return object;
            };

            /**
             * Converts this SchedulesJSON to JSON.
             * @function toJSON
             * @memberof dataform.schedules.SchedulesJSON
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SchedulesJSON.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SchedulesJSON;
        })();

        return schedules;
    })();

    dataform.server = (function() {

        /**
         * Namespace server.
         * @memberof dataform
         * @namespace
         */
        const server = {};

        server.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof dataform.server
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof dataform.server
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {dataform.server.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty=} [properties] Properties to set
             * @returns {dataform.server.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link dataform.server.Empty.verify|verify} messages.
             * @function encode
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link dataform.server.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.server.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.server.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.server.Empty();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.server.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.server.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof dataform.server.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.server.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.server.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.server.Empty)
                    return object;
                return new $root.dataform.server.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof dataform.server.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        server.MetadataResponse = (function() {

            /**
             * Properties of a MetadataResponse.
             * @memberof dataform.server
             * @interface IMetadataResponse
             * @property {string|null} [projectDir] MetadataResponse projectDir
             */

            /**
             * Constructs a new MetadataResponse.
             * @memberof dataform.server
             * @classdesc Represents a MetadataResponse.
             * @implements IMetadataResponse
             * @constructor
             * @param {dataform.server.IMetadataResponse=} [properties] Properties to set
             */
            function MetadataResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MetadataResponse projectDir.
             * @member {string} projectDir
             * @memberof dataform.server.MetadataResponse
             * @instance
             */
            MetadataResponse.prototype.projectDir = "";

            /**
             * Creates a new MetadataResponse instance using the specified properties.
             * @function create
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse=} [properties] Properties to set
             * @returns {dataform.server.MetadataResponse} MetadataResponse instance
             */
            MetadataResponse.create = function create(properties) {
                return new MetadataResponse(properties);
            };

            /**
             * Encodes the specified MetadataResponse message. Does not implicitly {@link dataform.server.MetadataResponse.verify|verify} messages.
             * @function encode
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse} message MetadataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectDir);
                return writer;
            };

            /**
             * Encodes the specified MetadataResponse message, length delimited. Does not implicitly {@link dataform.server.MetadataResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse} message MetadataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MetadataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.server.MetadataResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.projectDir = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MetadataResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MetadataResponse message.
             * @function verify
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetadataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                    if (!$util.isString(message.projectDir))
                        return "projectDir: string expected";
                return null;
            };

            /**
             * Creates a MetadataResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             */
            MetadataResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.server.MetadataResponse)
                    return object;
                let message = new $root.dataform.server.MetadataResponse();
                if (object.projectDir != null)
                    message.projectDir = String(object.projectDir);
                return message;
            };

            /**
             * Creates a plain object from a MetadataResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.MetadataResponse} message MetadataResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetadataResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.projectDir = "";
                if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                    object.projectDir = message.projectDir;
                return object;
            };

            /**
             * Converts this MetadataResponse to JSON.
             * @function toJSON
             * @memberof dataform.server.MetadataResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetadataResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MetadataResponse;
        })();

        server.Service = (function() {

            /**
             * Constructs a new Service service.
             * @memberof dataform.server
             * @classdesc Represents a Service
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Service(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Service.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Service;

            /**
             * Creates new Service service using the specified rpc implementation.
             * @function create
             * @memberof dataform.server.Service
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Service} RPC service. Useful where requests and/or responses are streamed.
             */
            Service.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link dataform.server.Service#metadata}.
             * @memberof dataform.server.Service
             * @typedef MetadataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dataform.server.MetadataResponse} [response] MetadataResponse
             */

            /**
             * Calls Metadata.
             * @function metadata
             * @memberof dataform.server.Service
             * @instance
             * @param {dataform.server.IEmpty} request Empty message or plain object
             * @param {dataform.server.Service.MetadataCallback} callback Node-style callback called with the error, if any, and MetadataResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.metadata = function metadata(request, callback) {
                return this.rpcCall(metadata, $root.dataform.server.Empty, $root.dataform.server.MetadataResponse, request, callback);
            }, "name", { value: "Metadata" });

            /**
             * Calls Metadata.
             * @function metadata
             * @memberof dataform.server.Service
             * @instance
             * @param {dataform.server.IEmpty} request Empty message or plain object
             * @returns {Promise<dataform.server.MetadataResponse>} Promise
             * @variation 2
             */

            return Service;
        })();

        return server;
    })();

    return dataform;
})();

function createGenIndexConfig(compileConfig) {
    const includePaths = [];
    glob.sync("includes/*.js", { cwd: compileConfig.projectDir }).forEach(path => {
        if (includePaths.indexOf(path) < 0) {
            includePaths.push(path);
        }
    });
    const definitionPaths = [];
    glob.sync("definitions/**/*.{js,sql,sqlx}", { cwd: compileConfig.projectDir }).forEach(path => {
        if (definitionPaths.indexOf(path) < 0) {
            definitionPaths.push(path);
        }
    });
    glob.sync("models/**/*.{js,sql,sqlx}", { cwd: compileConfig.projectDir }).forEach(path => {
        if (definitionPaths.indexOf(path) < 0) {
            definitionPaths.push(path);
        }
    });
    return encode(dataform.GenerateIndexConfig, {
        compileConfig,
        includePaths,
        definitionPaths,
        returnOverride: compileConfig.returnOverride
    });
}

function baseFilename(fullPath) {
    return path.basename(fullPath).split(".")[0];
}

function compile(code, path) {
    if (path.endsWith(".assert.sql")) {
        return compileAssertionSql(code, path);
    }
    if (path.endsWith(".ops.sql")) {
        return compileOperationSql(code, path);
    }
    if (path.endsWith(".sql")) {
        return compileTableSql(code, path);
    }
    return code;
}
const tableContextPropertyNames = [
    "constructor",
    "config",
    "self",
    "ref",
    "resolve",
    "type",
    "where",
    "preOps",
    "postOps",
    "disabled",
    "redshift",
    "bigquery",
    "dependencies",
    "descriptor",
    "describe",
    "apply"
];
function compileTableSql(code, path) {
    const { sql, js } = extractJsBlocks(code);
    const functionsBindings = tableContextPropertyNames.map(name => `const ${name} = !!ctx.${name} ? ctx.${name}.bind(ctx) : () => "";`);
    return `
  const publish = global.publish || global.materialize;
  publish("${baseFilename(path)}").query(ctx => {
    ${functionsBindings.join("\n")}
    ${js}
    return \`${sql}\`;
  })`;
}
const operationContextPropertyNames = [
    "constructor",
    "self",
    "ref",
    "resolve",
    "dependencies",
    "hasOutput",
    "apply"
];
function compileOperationSql(code, path) {
    const { sql, js } = extractJsBlocks(code);
    const functionsBindings = operationContextPropertyNames.map(name => `const ${name} = !!ctx.${name} ? ctx.${name}.bind(ctx) : () => "";`);
    return `
  operate("${baseFilename(path)}").queries(ctx => {
    ${functionsBindings.join("\n")}
    ${js}
    return \`${sql}\`.split("\\n---\\n");
  })`;
}
const assertionContextPropertyNames = ["constructor", "ref", "resolve", "dependencies", "apply"];
function compileAssertionSql(code, path) {
    const { sql, js } = extractJsBlocks(code);
    const functionsBindings = assertionContextPropertyNames.map(name => `const ${name} = !!ctx.${name} ? ctx.${name}.bind(ctx) : () => "";`);
    return `
  assert("${baseFilename(path)}").query(ctx => {
    ${functionsBindings.join("\n")}
    ${js}
    return \`${sql}\`;
  })`;
}
function extractJsBlocks(code) {
    const JS_REGEX = /^\s*\/\*[jJ][sS]\s*[\r\n]+((?:[^*]|[\r\n]|(?:\*+(?:[^*/]|[\r\n])))*)\*+\/|^\s*\-\-[jJ][sS]\s(.*)/gm;
    const RAW_BACKTICKS_REGEX = /([^\\])`/g;
    const jsBlocks = [];
    const cleanSql = code
        .replace(JS_REGEX, (_, group1, group2) => {
        if (group1) {
            jsBlocks.push(group1);
        }
        if (group2) {
            jsBlocks.push(group2);
        }
        return "";
    })
        .replace(RAW_BACKTICKS_REGEX, (_, group1) => group1 + "\\`");
    return {
        sql: cleanSql.trim(),
        js: jsBlocks.map(block => block.trim()).join("\n")
    };
}

function legacyGenIndex(base64EncodedConfig) {
    const config = decode(dataform.GenerateIndexConfig, base64EncodedConfig);
    const includeRequires = config.includePaths
        .map(path => {
        return `
      try { global.${baseFilename(path)} = require("./${path}"); } catch (e) {
        if (global.session.compileError) {
          global.session.compileError(e, "${path}");
        } else {
          console.error('Error:', e.message, 'Path: "${path}"');
        }
      }`;
    })
        .join("\n");
    const definitionRequires = config.definitionPaths
        .map(path => {
        return `
      try { require("./${path}"); } catch (e) {
        if (global.session.compileError) {
          global.session.compileError(e, "${path}");
        } else {
          console.error('Error:', e.message, 'Path: "${path}"');
        }
      }`;
    })
        .join("\n");
    return `
    const { init, compile } = require("@dataform/core");
    const protos = require("@dataform/protos");
    const { util } = require("protobufjs");
    ${includeRequires}
    const projectConfig = require("./dataform.json");
    projectConfig.schemaSuffix = "${config.compileConfig.schemaSuffixOverride}" || projectConfig.schemaSuffix;
    init("${config.compileConfig.projectDir}", projectConfig);
    ${definitionRequires}
    const compiledGraph = compile();
    // Keep backwards compatibility with un-namespaced protobufs (i.e. before dataform protobufs were inside a package).
    const protoNamespace = (protos.dataform) ? protos.dataform : protos;
    // We return a base64 encoded proto via NodeVM, as returning a Uint8Array directly causes issues.
    const encodedGraphBytes = protoNamespace.CompiledGraph.encode(compiledGraph).finish();
    const base64EncodedGraphBytes = util.base64.encode(encodedGraphBytes, 0, encodedGraphBytes.length);
    return ${config.returnOverride || "base64EncodedGraphBytes"};`;
}

function compile$1(compileConfig) {
    const vmIndexFileName = path.resolve(path.join(compileConfig.projectDir, "index.js"));
    const indexGeneratorVm = new vm2.NodeVM({
        wrapper: "none",
        require: {
            context: "sandbox",
            root: compileConfig.projectDir,
            external: true,
            builtin: ["path"]
        }
    });
    const findGenIndex = () => {
        try {
            return (indexGeneratorVm.run('return require("@dataform/core").indexFileGenerator', vmIndexFileName) || legacyGenIndex);
        }
        catch (e) {
            return legacyGenIndex;
        }
    };
    const genIndex = findGenIndex();
    const findCompiler = () => {
        try {
            return (indexGeneratorVm.run('return require("@dataform/core").compiler', vmIndexFileName) ||
                compile);
        }
        catch (e) {
            return compile;
        }
    };
    const compiler = findCompiler();
    if (!compiler) {
        throw new Error("Could not find compiler function.");
    }
    const userCodeVm = new vm2.NodeVM({
        wrapper: "none",
        require: {
            builtin: ["path"],
            context: "sandbox",
            external: true,
            root: compileConfig.projectDir,
            resolve: (moduleName, parentDirName) => path.join(parentDirName, path.relative(parentDirName, compileConfig.projectDir), moduleName)
        },
        sourceExtensions: ["js", "sql", "sqlx"],
        compiler
    });
    return userCodeVm.run(genIndex(createGenIndexConfig(compileConfig)), vmIndexFileName);
}
function listenForCompileRequest() {
    process.on("message", (compileConfig) => {
        try {
            const compiledResult = compile$1(compileConfig);
            process.send(compiledResult);
        }
        catch (e) {
            const serializableError = {};
            for (const prop of Object.getOwnPropertyNames(e)) {
                serializableError[prop] = e[prop];
            }
            process.send(serializableError);
        }
    });
}
if (require.main === module) {
    listenForCompileRequest();
}

listenForCompileRequest();
