package protomongo

import (
	"reflect"
	"strconv"

	"github.com/golang/protobuf/descriptor"
	"github.com/golang/protobuf/proto"
	"go.mongodb.org/mongo-driver/bson/bsoncodec"
	"go.mongodb.org/mongo-driver/bson/bsonrw"
)

type ProtobufCodec struct {
}

func (e *ProtobufCodec) EncodeValue(ectx bsoncodec.EncodeContext, vw bsonrw.ValueWriter, val reflect.Value) error {
	oneofs := oneofNames(val.Interface().(descriptor.Message))
	for val.Kind() != reflect.Struct {
		val = val.Elem()
	}
	props := proto.GetProperties(val.Type())

	dw, err := vw.WriteDocument()
	if err != nil {
		return err
	}

	for _, prop := range props.Prop {
		fVal := val.FieldByName(prop.Name)
		if !fVal.IsZero() {
			tag := prop.Tag
			if oneofs[prop.OrigName] {
				oneof := fVal.Elem().Elem()
				singleProp := proto.GetProperties(oneof.Type()).Prop[0]
				tag = singleProp.Tag
				fVal = oneof.Field(0)
			}
			if err = writeProtobufElement(ectx, dw, tag, fVal); err != nil {
				return err
			}
		}
	}

	if err = dw.WriteDocumentEnd(); err != nil {
		return err
	}
	return nil
}

func writeProtobufElement(ectx bsoncodec.EncodeContext, dw bsonrw.DocumentWriter, tag int, val reflect.Value) error {
	fvw, err := dw.WriteDocumentElement(strconv.Itoa(tag))
	if err != nil {
		return err
	}
	enc, err := ectx.LookupEncoder(val.Type())
	if err != nil {
		return err
	}
	return enc.EncodeValue(ectx, fvw, val)
}

func (e *ProtobufCodec) DecodeValue(ectx bsoncodec.DecodeContext, vr bsonrw.ValueReader, val reflect.Value) error {
	oneofs := oneofNames(val.Interface().(descriptor.Message))
	if val.IsNil() {
		val.Set(reflect.New(val.Type().Elem()))
	}
	for val.Kind() != reflect.Struct {
		val = val.Elem()
	}
	props := proto.GetProperties(val.Type())

	dr, err := vr.ReadDocument()
	if err != nil {
		return err
	}

	indexedProps := make(map[string]*proto.Properties)
	for _, prop := range props.Prop {
		if !oneofs[prop.OrigName] {
			indexedProps[strconv.Itoa(prop.Tag)] = prop
		}
	}

	indexedOneofProps := make(map[string]*proto.OneofProperties)
	for _, oneof := range props.OneofTypes {
		indexedOneofProps[strconv.Itoa(oneof.Prop.Tag)] = oneof
	}

	for f, fvr, err := dr.ReadElement(); err != bsonrw.ErrEOD; f, fvr, err = dr.ReadElement() {
		if err != nil {
			return err
		}

		prop, isProp := indexedProps[f]
		oneof, isOneof := indexedOneofProps[f]

		// TODO: see if we can not skip the autogenerated ID field.
		if !isProp && !isOneof {
			if err = vr.Skip(); err != nil {
				return err
			}
			continue
		}

		var fVal reflect.Value
		if isProp {
			fVal = val.FieldByName(prop.Name)
		} else if isOneof {
			oneofVal := reflect.New(oneof.Type.Elem())
			val.Field(oneof.Field).Set(oneofVal)
			fVal = oneofVal.Elem().Field(0)
		}
		if err = decodeProtobufElement(ectx, fVal.Type(), fvr, fVal); err != nil {
			return err
		}
	}

	return nil
}

func decodeProtobufElement(ectx bsoncodec.DecodeContext, t reflect.Type, vr bsonrw.ValueReader, val reflect.Value) error {
	enc, err := ectx.LookupDecoder(t)
	if err != nil {
		return err
	}
	return enc.DecodeValue(ectx, vr, val)
}

func oneofNames(pb descriptor.Message) map[string]bool {
	_, msgDescriptor := descriptor.ForMessage(pb)
	names := make(map[string]bool)
	for _, oneof := range msgDescriptor.OneofDecl {
		names[*oneof.Name] = true
	}
	return names
}
